
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AddressUser
 * 
 */
export type AddressUser = $Result.DefaultSelection<Prisma.$AddressUserPayload>
/**
 * Model Banner
 * 
 */
export type Banner = $Result.DefaultSelection<Prisma.$BannerPayload>
/**
 * Model Blog
 * 
 */
export type Blog = $Result.DefaultSelection<Prisma.$BlogPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model OrderDetaill
 * 
 */
export type OrderDetaill = $Result.DefaultSelection<Prisma.$OrderDetaillPayload>
/**
 * Model OrderProduct
 * 
 */
export type OrderProduct = $Result.DefaultSelection<Prisma.$OrderProductPayload>
/**
 * Model ProductSize
 * 
 */
export type ProductSize = $Result.DefaultSelection<Prisma.$ProductSizePayload>
/**
 * Model ProductImage
 * 
 */
export type ProductImage = $Result.DefaultSelection<Prisma.$ProductImagePayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model RoomMessage
 * 
 */
export type RoomMessage = $Result.DefaultSelection<Prisma.$RoomMessagePayload>
/**
 * Model ShopCart
 * 
 */
export type ShopCart = $Result.DefaultSelection<Prisma.$ShopCartPayload>
/**
 * Model TypeShip
 * 
 */
export type TypeShip = $Result.DefaultSelection<Prisma.$TypeShipPayload>
/**
 * Model TypeVoucher
 * 
 */
export type TypeVoucher = $Result.DefaultSelection<Prisma.$TypeVoucherPayload>
/**
 * Model Voucher
 * 
 */
export type Voucher = $Result.DefaultSelection<Prisma.$VoucherPayload>
/**
 * Model VoucherUsed
 * 
 */
export type VoucherUsed = $Result.DefaultSelection<Prisma.$VoucherUsedPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model Receipt
 * 
 */
export type Receipt = $Result.DefaultSelection<Prisma.$ReceiptPayload>
/**
 * Model ReceiptDetail
 * 
 */
export type ReceiptDetail = $Result.DefaultSelection<Prisma.$ReceiptDetailPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  NAM: 'NAM',
  NU: 'NU',
  KHAC: 'KHAC'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const Role: {
  ADMIN: 'ADMIN',
  USER: 'USER',
  SHIPPER: 'SHIPPER',
  SALER: 'SALER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type Status = (typeof Status)[keyof typeof Status]


export const Subject: {
  CHAM_SOC_SUC_KHOE: 'CHAM_SOC_SUC_KHOE',
  CONG_NGHE_MOI: 'CONG_NGHE_MOI',
  THOI_TRANG_TUOI_TEEN: 'THOI_TRANG_TUOI_TEEN'
};

export type Subject = (typeof Subject)[keyof typeof Subject]


export const Size: {
  S: 'S',
  M: 'M',
  L: 'L',
  XL: 'XL',
  XXL: 'XXL'
};

export type Size = (typeof Size)[keyof typeof Size]


export const Discount: {
  PHAN_TRAM: 'PHAN_TRAM',
  VND: 'VND'
};

export type Discount = (typeof Discount)[keyof typeof Discount]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type Subject = $Enums.Subject

export const Subject: typeof $Enums.Subject

export type Size = $Enums.Size

export const Size: typeof $Enums.Size

export type Discount = $Enums.Discount

export const Discount: typeof $Enums.Discount

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.addressUser`: Exposes CRUD operations for the **AddressUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddressUsers
    * const addressUsers = await prisma.addressUser.findMany()
    * ```
    */
  get addressUser(): Prisma.AddressUserDelegate<ExtArgs>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **Banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.BannerDelegate<ExtArgs>;

  /**
   * `prisma.blog`: Exposes CRUD operations for the **Blog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blog.findMany()
    * ```
    */
  get blog(): Prisma.BlogDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.orderDetaill`: Exposes CRUD operations for the **OrderDetaill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderDetaills
    * const orderDetaills = await prisma.orderDetaill.findMany()
    * ```
    */
  get orderDetaill(): Prisma.OrderDetaillDelegate<ExtArgs>;

  /**
   * `prisma.orderProduct`: Exposes CRUD operations for the **OrderProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderProducts
    * const orderProducts = await prisma.orderProduct.findMany()
    * ```
    */
  get orderProduct(): Prisma.OrderProductDelegate<ExtArgs>;

  /**
   * `prisma.productSize`: Exposes CRUD operations for the **ProductSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductSizes
    * const productSizes = await prisma.productSize.findMany()
    * ```
    */
  get productSize(): Prisma.ProductSizeDelegate<ExtArgs>;

  /**
   * `prisma.productImage`: Exposes CRUD operations for the **ProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImage.findMany()
    * ```
    */
  get productImage(): Prisma.ProductImageDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.roomMessage`: Exposes CRUD operations for the **RoomMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomMessages
    * const roomMessages = await prisma.roomMessage.findMany()
    * ```
    */
  get roomMessage(): Prisma.RoomMessageDelegate<ExtArgs>;

  /**
   * `prisma.shopCart`: Exposes CRUD operations for the **ShopCart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShopCarts
    * const shopCarts = await prisma.shopCart.findMany()
    * ```
    */
  get shopCart(): Prisma.ShopCartDelegate<ExtArgs>;

  /**
   * `prisma.typeShip`: Exposes CRUD operations for the **TypeShip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypeShips
    * const typeShips = await prisma.typeShip.findMany()
    * ```
    */
  get typeShip(): Prisma.TypeShipDelegate<ExtArgs>;

  /**
   * `prisma.typeVoucher`: Exposes CRUD operations for the **TypeVoucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypeVouchers
    * const typeVouchers = await prisma.typeVoucher.findMany()
    * ```
    */
  get typeVoucher(): Prisma.TypeVoucherDelegate<ExtArgs>;

  /**
   * `prisma.voucher`: Exposes CRUD operations for the **Voucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vouchers
    * const vouchers = await prisma.voucher.findMany()
    * ```
    */
  get voucher(): Prisma.VoucherDelegate<ExtArgs>;

  /**
   * `prisma.voucherUsed`: Exposes CRUD operations for the **VoucherUsed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoucherUseds
    * const voucherUseds = await prisma.voucherUsed.findMany()
    * ```
    */
  get voucherUsed(): Prisma.VoucherUsedDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.receipt`: Exposes CRUD operations for the **Receipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receipts
    * const receipts = await prisma.receipt.findMany()
    * ```
    */
  get receipt(): Prisma.ReceiptDelegate<ExtArgs>;

  /**
   * `prisma.receiptDetail`: Exposes CRUD operations for the **ReceiptDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReceiptDetails
    * const receiptDetails = await prisma.receiptDetail.findMany()
    * ```
    */
  get receiptDetail(): Prisma.ReceiptDetailDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.11.0
   * Query Engine version: efd2449663b3d73d637ea1fd226bafbcf45b3102
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    AddressUser: 'AddressUser',
    Banner: 'Banner',
    Blog: 'Blog',
    Comment: 'Comment',
    Message: 'Message',
    OrderDetaill: 'OrderDetaill',
    OrderProduct: 'OrderProduct',
    ProductSize: 'ProductSize',
    ProductImage: 'ProductImage',
    Product: 'Product',
    RoomMessage: 'RoomMessage',
    ShopCart: 'ShopCart',
    TypeShip: 'TypeShip',
    TypeVoucher: 'TypeVoucher',
    Voucher: 'Voucher',
    VoucherUsed: 'VoucherUsed',
    Supplier: 'Supplier',
    Receipt: 'Receipt',
    ReceiptDetail: 'ReceiptDetail',
    Category: 'Category',
    Brand: 'Brand'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'addressUser' | 'banner' | 'blog' | 'comment' | 'message' | 'orderDetaill' | 'orderProduct' | 'productSize' | 'productImage' | 'product' | 'roomMessage' | 'shopCart' | 'typeShip' | 'typeVoucher' | 'voucher' | 'voucherUsed' | 'supplier' | 'receipt' | 'receiptDetail' | 'category' | 'brand'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AddressUser: {
        payload: Prisma.$AddressUserPayload<ExtArgs>
        fields: Prisma.AddressUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressUserPayload>
          }
          findFirst: {
            args: Prisma.AddressUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressUserPayload>
          }
          findMany: {
            args: Prisma.AddressUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressUserPayload>[]
          }
          create: {
            args: Prisma.AddressUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressUserPayload>
          }
          createMany: {
            args: Prisma.AddressUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AddressUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressUserPayload>
          }
          update: {
            args: Prisma.AddressUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressUserPayload>
          }
          deleteMany: {
            args: Prisma.AddressUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AddressUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AddressUserPayload>
          }
          aggregate: {
            args: Prisma.AddressUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAddressUser>
          }
          groupBy: {
            args: Prisma.AddressUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AddressUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressUserCountArgs<ExtArgs>,
            result: $Utils.Optional<AddressUserCountAggregateOutputType> | number
          }
        }
      }
      Banner: {
        payload: Prisma.$BannerPayload<ExtArgs>
        fields: Prisma.BannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BannerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BannerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findFirst: {
            args: Prisma.BannerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BannerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          findMany: {
            args: Prisma.BannerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>[]
          }
          create: {
            args: Prisma.BannerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          createMany: {
            args: Prisma.BannerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BannerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          update: {
            args: Prisma.BannerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          deleteMany: {
            args: Prisma.BannerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BannerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BannerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.BannerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BannerCountArgs<ExtArgs>,
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      Blog: {
        payload: Prisma.$BlogPayload<ExtArgs>
        fields: Prisma.BlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findFirst: {
            args: Prisma.BlogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findMany: {
            args: Prisma.BlogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          create: {
            args: Prisma.BlogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          createMany: {
            args: Prisma.BlogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BlogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          update: {
            args: Prisma.BlogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          deleteMany: {
            args: Prisma.BlogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BlogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BlogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          aggregate: {
            args: Prisma.BlogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBlog>
          }
          groupBy: {
            args: Prisma.BlogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogCountArgs<ExtArgs>,
            result: $Utils.Optional<BlogCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      OrderDetaill: {
        payload: Prisma.$OrderDetaillPayload<ExtArgs>
        fields: Prisma.OrderDetaillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderDetaillFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderDetaillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderDetaillFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderDetaillPayload>
          }
          findFirst: {
            args: Prisma.OrderDetaillFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderDetaillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderDetaillFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderDetaillPayload>
          }
          findMany: {
            args: Prisma.OrderDetaillFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderDetaillPayload>[]
          }
          create: {
            args: Prisma.OrderDetaillCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderDetaillPayload>
          }
          createMany: {
            args: Prisma.OrderDetaillCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderDetaillDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderDetaillPayload>
          }
          update: {
            args: Prisma.OrderDetaillUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderDetaillPayload>
          }
          deleteMany: {
            args: Prisma.OrderDetaillDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderDetaillUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderDetaillUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderDetaillPayload>
          }
          aggregate: {
            args: Prisma.OrderDetaillAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderDetaill>
          }
          groupBy: {
            args: Prisma.OrderDetaillGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderDetaillGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderDetaillCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderDetaillCountAggregateOutputType> | number
          }
        }
      }
      OrderProduct: {
        payload: Prisma.$OrderProductPayload<ExtArgs>
        fields: Prisma.OrderProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          findFirst: {
            args: Prisma.OrderProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          findMany: {
            args: Prisma.OrderProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>[]
          }
          create: {
            args: Prisma.OrderProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          createMany: {
            args: Prisma.OrderProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrderProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          update: {
            args: Prisma.OrderProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          deleteMany: {
            args: Prisma.OrderProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrderProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrderProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          aggregate: {
            args: Prisma.OrderProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrderProduct>
          }
          groupBy: {
            args: Prisma.OrderProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderProductCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderProductCountAggregateOutputType> | number
          }
        }
      }
      ProductSize: {
        payload: Prisma.$ProductSizePayload<ExtArgs>
        fields: Prisma.ProductSizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductSizeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductSizeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          findFirst: {
            args: Prisma.ProductSizeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductSizeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          findMany: {
            args: Prisma.ProductSizeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>[]
          }
          create: {
            args: Prisma.ProductSizeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          createMany: {
            args: Prisma.ProductSizeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductSizeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          update: {
            args: Prisma.ProductSizeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          deleteMany: {
            args: Prisma.ProductSizeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductSizeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductSizeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductSizePayload>
          }
          aggregate: {
            args: Prisma.ProductSizeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductSize>
          }
          groupBy: {
            args: Prisma.ProductSizeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductSizeCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductSizeCountAggregateOutputType> | number
          }
        }
      }
      ProductImage: {
        payload: Prisma.$ProductImagePayload<ExtArgs>
        fields: Prisma.ProductImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductImageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductImageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findFirst: {
            args: Prisma.ProductImageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductImageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findMany: {
            args: Prisma.ProductImageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          create: {
            args: Prisma.ProductImageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          createMany: {
            args: Prisma.ProductImageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductImageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          update: {
            args: Prisma.ProductImageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          deleteMany: {
            args: Prisma.ProductImageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductImageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductImageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          aggregate: {
            args: Prisma.ProductImageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProductImage>
          }
          groupBy: {
            args: Prisma.ProductImageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductImageCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductImageCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      RoomMessage: {
        payload: Prisma.$RoomMessagePayload<ExtArgs>
        fields: Prisma.RoomMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomMessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomMessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomMessagePayload>
          }
          findFirst: {
            args: Prisma.RoomMessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomMessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomMessagePayload>
          }
          findMany: {
            args: Prisma.RoomMessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomMessagePayload>[]
          }
          create: {
            args: Prisma.RoomMessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomMessagePayload>
          }
          createMany: {
            args: Prisma.RoomMessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomMessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomMessagePayload>
          }
          update: {
            args: Prisma.RoomMessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomMessagePayload>
          }
          deleteMany: {
            args: Prisma.RoomMessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomMessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomMessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomMessagePayload>
          }
          aggregate: {
            args: Prisma.RoomMessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoomMessage>
          }
          groupBy: {
            args: Prisma.RoomMessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomMessageCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomMessageCountAggregateOutputType> | number
          }
        }
      }
      ShopCart: {
        payload: Prisma.$ShopCartPayload<ExtArgs>
        fields: Prisma.ShopCartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopCartFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopCartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopCartFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopCartPayload>
          }
          findFirst: {
            args: Prisma.ShopCartFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopCartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopCartFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopCartPayload>
          }
          findMany: {
            args: Prisma.ShopCartFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopCartPayload>[]
          }
          create: {
            args: Prisma.ShopCartCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopCartPayload>
          }
          createMany: {
            args: Prisma.ShopCartCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ShopCartDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopCartPayload>
          }
          update: {
            args: Prisma.ShopCartUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopCartPayload>
          }
          deleteMany: {
            args: Prisma.ShopCartDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ShopCartUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ShopCartUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ShopCartPayload>
          }
          aggregate: {
            args: Prisma.ShopCartAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShopCart>
          }
          groupBy: {
            args: Prisma.ShopCartGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ShopCartGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopCartCountArgs<ExtArgs>,
            result: $Utils.Optional<ShopCartCountAggregateOutputType> | number
          }
        }
      }
      TypeShip: {
        payload: Prisma.$TypeShipPayload<ExtArgs>
        fields: Prisma.TypeShipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypeShipFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeShipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypeShipFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeShipPayload>
          }
          findFirst: {
            args: Prisma.TypeShipFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeShipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypeShipFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeShipPayload>
          }
          findMany: {
            args: Prisma.TypeShipFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeShipPayload>[]
          }
          create: {
            args: Prisma.TypeShipCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeShipPayload>
          }
          createMany: {
            args: Prisma.TypeShipCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TypeShipDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeShipPayload>
          }
          update: {
            args: Prisma.TypeShipUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeShipPayload>
          }
          deleteMany: {
            args: Prisma.TypeShipDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TypeShipUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TypeShipUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeShipPayload>
          }
          aggregate: {
            args: Prisma.TypeShipAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTypeShip>
          }
          groupBy: {
            args: Prisma.TypeShipGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TypeShipGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypeShipCountArgs<ExtArgs>,
            result: $Utils.Optional<TypeShipCountAggregateOutputType> | number
          }
        }
      }
      TypeVoucher: {
        payload: Prisma.$TypeVoucherPayload<ExtArgs>
        fields: Prisma.TypeVoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypeVoucherFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeVoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypeVoucherFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeVoucherPayload>
          }
          findFirst: {
            args: Prisma.TypeVoucherFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeVoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypeVoucherFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeVoucherPayload>
          }
          findMany: {
            args: Prisma.TypeVoucherFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeVoucherPayload>[]
          }
          create: {
            args: Prisma.TypeVoucherCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeVoucherPayload>
          }
          createMany: {
            args: Prisma.TypeVoucherCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TypeVoucherDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeVoucherPayload>
          }
          update: {
            args: Prisma.TypeVoucherUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeVoucherPayload>
          }
          deleteMany: {
            args: Prisma.TypeVoucherDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TypeVoucherUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TypeVoucherUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypeVoucherPayload>
          }
          aggregate: {
            args: Prisma.TypeVoucherAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTypeVoucher>
          }
          groupBy: {
            args: Prisma.TypeVoucherGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TypeVoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypeVoucherCountArgs<ExtArgs>,
            result: $Utils.Optional<TypeVoucherCountAggregateOutputType> | number
          }
        }
      }
      Voucher: {
        payload: Prisma.$VoucherPayload<ExtArgs>
        fields: Prisma.VoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findFirst: {
            args: Prisma.VoucherFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findMany: {
            args: Prisma.VoucherFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          create: {
            args: Prisma.VoucherCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          createMany: {
            args: Prisma.VoucherCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VoucherDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          update: {
            args: Prisma.VoucherUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          deleteMany: {
            args: Prisma.VoucherDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VoucherUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          aggregate: {
            args: Prisma.VoucherAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVoucher>
          }
          groupBy: {
            args: Prisma.VoucherGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherCountArgs<ExtArgs>,
            result: $Utils.Optional<VoucherCountAggregateOutputType> | number
          }
        }
      }
      VoucherUsed: {
        payload: Prisma.$VoucherUsedPayload<ExtArgs>
        fields: Prisma.VoucherUsedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherUsedFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherUsedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherUsedFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherUsedPayload>
          }
          findFirst: {
            args: Prisma.VoucherUsedFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherUsedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherUsedFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherUsedPayload>
          }
          findMany: {
            args: Prisma.VoucherUsedFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherUsedPayload>[]
          }
          create: {
            args: Prisma.VoucherUsedCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherUsedPayload>
          }
          createMany: {
            args: Prisma.VoucherUsedCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VoucherUsedDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherUsedPayload>
          }
          update: {
            args: Prisma.VoucherUsedUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherUsedPayload>
          }
          deleteMany: {
            args: Prisma.VoucherUsedDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUsedUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VoucherUsedUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VoucherUsedPayload>
          }
          aggregate: {
            args: Prisma.VoucherUsedAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVoucherUsed>
          }
          groupBy: {
            args: Prisma.VoucherUsedGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VoucherUsedGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherUsedCountArgs<ExtArgs>,
            result: $Utils.Optional<VoucherUsedCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Receipt: {
        payload: Prisma.$ReceiptPayload<ExtArgs>
        fields: Prisma.ReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceiptFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceiptFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          findFirst: {
            args: Prisma.ReceiptFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceiptFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          findMany: {
            args: Prisma.ReceiptFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
          }
          create: {
            args: Prisma.ReceiptCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          createMany: {
            args: Prisma.ReceiptCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReceiptDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          update: {
            args: Prisma.ReceiptUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          deleteMany: {
            args: Prisma.ReceiptDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReceiptUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReceiptUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptPayload>
          }
          aggregate: {
            args: Prisma.ReceiptAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReceipt>
          }
          groupBy: {
            args: Prisma.ReceiptGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceiptCountArgs<ExtArgs>,
            result: $Utils.Optional<ReceiptCountAggregateOutputType> | number
          }
        }
      }
      ReceiptDetail: {
        payload: Prisma.$ReceiptDetailPayload<ExtArgs>
        fields: Prisma.ReceiptDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceiptDetailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceiptDetailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptDetailPayload>
          }
          findFirst: {
            args: Prisma.ReceiptDetailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceiptDetailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptDetailPayload>
          }
          findMany: {
            args: Prisma.ReceiptDetailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptDetailPayload>[]
          }
          create: {
            args: Prisma.ReceiptDetailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptDetailPayload>
          }
          createMany: {
            args: Prisma.ReceiptDetailCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReceiptDetailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptDetailPayload>
          }
          update: {
            args: Prisma.ReceiptDetailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptDetailPayload>
          }
          deleteMany: {
            args: Prisma.ReceiptDetailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReceiptDetailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReceiptDetailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReceiptDetailPayload>
          }
          aggregate: {
            args: Prisma.ReceiptDetailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReceiptDetail>
          }
          groupBy: {
            args: Prisma.ReceiptDetailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReceiptDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceiptDetailCountArgs<ExtArgs>,
            result: $Utils.Optional<ReceiptDetailCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>,
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    addressUser: number
    blog: number
    Comment: number
    Message: number
    ShopCart: number
    roomMessagesOne: number
    roomMessagesTwo: number
    Receipt: number
    VoucherUsed: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addressUser?: boolean | UserCountOutputTypeCountAddressUserArgs
    blog?: boolean | UserCountOutputTypeCountBlogArgs
    Comment?: boolean | UserCountOutputTypeCountCommentArgs
    Message?: boolean | UserCountOutputTypeCountMessageArgs
    ShopCart?: boolean | UserCountOutputTypeCountShopCartArgs
    roomMessagesOne?: boolean | UserCountOutputTypeCountRoomMessagesOneArgs
    roomMessagesTwo?: boolean | UserCountOutputTypeCountRoomMessagesTwoArgs
    Receipt?: boolean | UserCountOutputTypeCountReceiptArgs
    VoucherUsed?: boolean | UserCountOutputTypeCountVoucherUsedArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressUserWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShopCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopCartWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoomMessagesOneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomMessageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoomMessagesTwoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomMessageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVoucherUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsedWhereInput
  }



  /**
   * Count Type AddressUserCountOutputType
   */

  export type AddressUserCountOutputType = {
    OrderProduct: number
  }

  export type AddressUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderProduct?: boolean | AddressUserCountOutputTypeCountOrderProductArgs
  }

  // Custom InputTypes

  /**
   * AddressUserCountOutputType without action
   */
  export type AddressUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUserCountOutputType
     */
    select?: AddressUserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AddressUserCountOutputType without action
   */
  export type AddressUserCountOutputTypeCountOrderProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderProductWhereInput
  }



  /**
   * Count Type BlogCountOutputType
   */

  export type BlogCountOutputType = {
    Comment: number
  }

  export type BlogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | BlogCountOutputTypeCountCommentArgs
  }

  // Custom InputTypes

  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogCountOutputType
     */
    select?: BlogCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BlogCountOutputType without action
   */
  export type BlogCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }



  /**
   * Count Type OrderProductCountOutputType
   */

  export type OrderProductCountOutputType = {
    OrderDetaill: number
  }

  export type OrderProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderDetaill?: boolean | OrderProductCountOutputTypeCountOrderDetaillArgs
  }

  // Custom InputTypes

  /**
   * OrderProductCountOutputType without action
   */
  export type OrderProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProductCountOutputType
     */
    select?: OrderProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OrderProductCountOutputType without action
   */
  export type OrderProductCountOutputTypeCountOrderDetaillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDetaillWhereInput
  }



  /**
   * Count Type ProductSizeCountOutputType
   */

  export type ProductSizeCountOutputType = {
    ShopCart: number
  }

  export type ProductSizeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ShopCart?: boolean | ProductSizeCountOutputTypeCountShopCartArgs
  }

  // Custom InputTypes

  /**
   * ProductSizeCountOutputType without action
   */
  export type ProductSizeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSizeCountOutputType
     */
    select?: ProductSizeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductSizeCountOutputType without action
   */
  export type ProductSizeCountOutputTypeCountShopCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopCartWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    Comment: number
    OrderDetaill: number
    ProductSize: number
    ProductImage: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | ProductCountOutputTypeCountCommentArgs
    OrderDetaill?: boolean | ProductCountOutputTypeCountOrderDetaillArgs
    ProductSize?: boolean | ProductCountOutputTypeCountProductSizeArgs
    ProductImage?: boolean | ProductCountOutputTypeCountProductImageArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderDetaillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDetaillWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductSizeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductSizeWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
  }



  /**
   * Count Type RoomMessageCountOutputType
   */

  export type RoomMessageCountOutputType = {
    messages: number
  }

  export type RoomMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | RoomMessageCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes

  /**
   * RoomMessageCountOutputType without action
   */
  export type RoomMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessageCountOutputType
     */
    select?: RoomMessageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RoomMessageCountOutputType without action
   */
  export type RoomMessageCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }



  /**
   * Count Type TypeShipCountOutputType
   */

  export type TypeShipCountOutputType = {
    OrderProduct: number
  }

  export type TypeShipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderProduct?: boolean | TypeShipCountOutputTypeCountOrderProductArgs
  }

  // Custom InputTypes

  /**
   * TypeShipCountOutputType without action
   */
  export type TypeShipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeShipCountOutputType
     */
    select?: TypeShipCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TypeShipCountOutputType without action
   */
  export type TypeShipCountOutputTypeCountOrderProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderProductWhereInput
  }



  /**
   * Count Type TypeVoucherCountOutputType
   */

  export type TypeVoucherCountOutputType = {
    Voucher: number
  }

  export type TypeVoucherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Voucher?: boolean | TypeVoucherCountOutputTypeCountVoucherArgs
  }

  // Custom InputTypes

  /**
   * TypeVoucherCountOutputType without action
   */
  export type TypeVoucherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeVoucherCountOutputType
     */
    select?: TypeVoucherCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TypeVoucherCountOutputType without action
   */
  export type TypeVoucherCountOutputTypeCountVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
  }



  /**
   * Count Type VoucherCountOutputType
   */

  export type VoucherCountOutputType = {
    OrderProduct: number
    VoucherUsed: number
  }

  export type VoucherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderProduct?: boolean | VoucherCountOutputTypeCountOrderProductArgs
    VoucherUsed?: boolean | VoucherCountOutputTypeCountVoucherUsedArgs
  }

  // Custom InputTypes

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherCountOutputType
     */
    select?: VoucherCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountOrderProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderProductWhereInput
  }


  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountVoucherUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsedWhereInput
  }



  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    Product: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | CategoryCountOutputTypeCountProductArgs
  }

  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    Product: number
    Category: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | BrandCountOutputTypeCountProductArgs
    Category?: boolean | BrandCountOutputTypeCountCategoryArgs
  }

  // Custom InputTypes

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    address: string | null
    gender: $Enums.Gender | null
    phoneNumber: string | null
    image: string | null
    dob: Date | null
    isActiveEmail: boolean | null
    roleId: $Enums.Role | null
    status: $Enums.Status | null
    userToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    address: string | null
    gender: $Enums.Gender | null
    phoneNumber: string | null
    image: string | null
    dob: Date | null
    isActiveEmail: boolean | null
    roleId: $Enums.Role | null
    status: $Enums.Status | null
    userToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    address: number
    gender: number
    phoneNumber: number
    image: number
    dob: number
    isActiveEmail: number
    roleId: number
    status: number
    userToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    address?: true
    gender?: true
    phoneNumber?: true
    image?: true
    dob?: true
    isActiveEmail?: true
    roleId?: true
    status?: true
    userToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    address?: true
    gender?: true
    phoneNumber?: true
    image?: true
    dob?: true
    isActiveEmail?: true
    roleId?: true
    status?: true
    userToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    address?: true
    gender?: true
    phoneNumber?: true
    image?: true
    dob?: true
    isActiveEmail?: true
    roleId?: true
    status?: true
    userToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    firstName: string
    lastName: string
    address: string | null
    gender: $Enums.Gender | null
    phoneNumber: string | null
    image: string | null
    dob: Date | null
    isActiveEmail: boolean | null
    roleId: $Enums.Role
    status: $Enums.Status | null
    userToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    address?: boolean
    gender?: boolean
    phoneNumber?: boolean
    image?: boolean
    dob?: boolean
    isActiveEmail?: boolean
    roleId?: boolean
    status?: boolean
    userToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addressUser?: boolean | User$addressUserArgs<ExtArgs>
    blog?: boolean | User$blogArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    Message?: boolean | User$MessageArgs<ExtArgs>
    ShopCart?: boolean | User$ShopCartArgs<ExtArgs>
    roomMessagesOne?: boolean | User$roomMessagesOneArgs<ExtArgs>
    roomMessagesTwo?: boolean | User$roomMessagesTwoArgs<ExtArgs>
    Receipt?: boolean | User$ReceiptArgs<ExtArgs>
    VoucherUsed?: boolean | User$VoucherUsedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    address?: boolean
    gender?: boolean
    phoneNumber?: boolean
    image?: boolean
    dob?: boolean
    isActiveEmail?: boolean
    roleId?: boolean
    status?: boolean
    userToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addressUser?: boolean | User$addressUserArgs<ExtArgs>
    blog?: boolean | User$blogArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    Message?: boolean | User$MessageArgs<ExtArgs>
    ShopCart?: boolean | User$ShopCartArgs<ExtArgs>
    roomMessagesOne?: boolean | User$roomMessagesOneArgs<ExtArgs>
    roomMessagesTwo?: boolean | User$roomMessagesTwoArgs<ExtArgs>
    Receipt?: boolean | User$ReceiptArgs<ExtArgs>
    VoucherUsed?: boolean | User$VoucherUsedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      addressUser: Prisma.$AddressUserPayload<ExtArgs>[]
      blog: Prisma.$BlogPayload<ExtArgs>[]
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      Message: Prisma.$MessagePayload<ExtArgs>[]
      ShopCart: Prisma.$ShopCartPayload<ExtArgs>[]
      roomMessagesOne: Prisma.$RoomMessagePayload<ExtArgs>[]
      roomMessagesTwo: Prisma.$RoomMessagePayload<ExtArgs>[]
      Receipt: Prisma.$ReceiptPayload<ExtArgs>[]
      VoucherUsed: Prisma.$VoucherUsedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      firstName: string
      lastName: string
      address: string | null
      gender: $Enums.Gender | null
      phoneNumber: string | null
      image: string | null
      dob: Date | null
      isActiveEmail: boolean | null
      roleId: $Enums.Role
      status: $Enums.Status | null
      userToken: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    addressUser<T extends User$addressUserArgs<ExtArgs> = {}>(args?: Subset<T, User$addressUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressUserPayload<ExtArgs>, T, 'findMany'> | Null>;

    blog<T extends User$blogArgs<ExtArgs> = {}>(args?: Subset<T, User$blogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, 'findMany'> | Null>;

    Comment<T extends User$CommentArgs<ExtArgs> = {}>(args?: Subset<T, User$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    Message<T extends User$MessageArgs<ExtArgs> = {}>(args?: Subset<T, User$MessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    ShopCart<T extends User$ShopCartArgs<ExtArgs> = {}>(args?: Subset<T, User$ShopCartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopCartPayload<ExtArgs>, T, 'findMany'> | Null>;

    roomMessagesOne<T extends User$roomMessagesOneArgs<ExtArgs> = {}>(args?: Subset<T, User$roomMessagesOneArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    roomMessagesTwo<T extends User$roomMessagesTwoArgs<ExtArgs> = {}>(args?: Subset<T, User$roomMessagesTwoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    Receipt<T extends User$ReceiptArgs<ExtArgs> = {}>(args?: Subset<T, User$ReceiptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, 'findMany'> | Null>;

    VoucherUsed<T extends User$VoucherUsedArgs<ExtArgs> = {}>(args?: Subset<T, User$VoucherUsedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsedPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly dob: FieldRef<"User", 'DateTime'>
    readonly isActiveEmail: FieldRef<"User", 'Boolean'>
    readonly roleId: FieldRef<"User", 'Role'>
    readonly status: FieldRef<"User", 'Status'>
    readonly userToken: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.addressUser
   */
  export type User$addressUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUser
     */
    select?: AddressUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressUserInclude<ExtArgs> | null
    where?: AddressUserWhereInput
    orderBy?: AddressUserOrderByWithRelationInput | AddressUserOrderByWithRelationInput[]
    cursor?: AddressUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressUserScalarFieldEnum | AddressUserScalarFieldEnum[]
  }


  /**
   * User.blog
   */
  export type User$blogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlogInclude<ExtArgs> | null
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    cursor?: BlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }


  /**
   * User.Comment
   */
  export type User$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * User.Message
   */
  export type User$MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * User.ShopCart
   */
  export type User$ShopCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCart
     */
    select?: ShopCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopCartInclude<ExtArgs> | null
    where?: ShopCartWhereInput
    orderBy?: ShopCartOrderByWithRelationInput | ShopCartOrderByWithRelationInput[]
    cursor?: ShopCartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopCartScalarFieldEnum | ShopCartScalarFieldEnum[]
  }


  /**
   * User.roomMessagesOne
   */
  export type User$roomMessagesOneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
    where?: RoomMessageWhereInput
    orderBy?: RoomMessageOrderByWithRelationInput | RoomMessageOrderByWithRelationInput[]
    cursor?: RoomMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomMessageScalarFieldEnum | RoomMessageScalarFieldEnum[]
  }


  /**
   * User.roomMessagesTwo
   */
  export type User$roomMessagesTwoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
    where?: RoomMessageWhereInput
    orderBy?: RoomMessageOrderByWithRelationInput | RoomMessageOrderByWithRelationInput[]
    cursor?: RoomMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomMessageScalarFieldEnum | RoomMessageScalarFieldEnum[]
  }


  /**
   * User.Receipt
   */
  export type User$ReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude<ExtArgs> | null
    where?: ReceiptWhereInput
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    cursor?: ReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }


  /**
   * User.VoucherUsed
   */
  export type User$VoucherUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsed
     */
    select?: VoucherUsedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherUsedInclude<ExtArgs> | null
    where?: VoucherUsedWhereInput
    orderBy?: VoucherUsedOrderByWithRelationInput | VoucherUsedOrderByWithRelationInput[]
    cursor?: VoucherUsedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherUsedScalarFieldEnum | VoucherUsedScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model AddressUser
   */

  export type AggregateAddressUser = {
    _count: AddressUserCountAggregateOutputType | null
    _avg: AddressUserAvgAggregateOutputType | null
    _sum: AddressUserSumAggregateOutputType | null
    _min: AddressUserMinAggregateOutputType | null
    _max: AddressUserMaxAggregateOutputType | null
  }

  export type AddressUserAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AddressUserSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AddressUserMinAggregateOutputType = {
    id: number | null
    userId: number | null
    shipName: string | null
    shipAdress: string | null
    shipPhone: string | null
    shipEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressUserMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    shipName: string | null
    shipAdress: string | null
    shipPhone: string | null
    shipEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressUserCountAggregateOutputType = {
    id: number
    userId: number
    shipName: number
    shipAdress: number
    shipPhone: number
    shipEmail: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressUserAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AddressUserSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AddressUserMinAggregateInputType = {
    id?: true
    userId?: true
    shipName?: true
    shipAdress?: true
    shipPhone?: true
    shipEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressUserMaxAggregateInputType = {
    id?: true
    userId?: true
    shipName?: true
    shipAdress?: true
    shipPhone?: true
    shipEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressUserCountAggregateInputType = {
    id?: true
    userId?: true
    shipName?: true
    shipAdress?: true
    shipPhone?: true
    shipEmail?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddressUser to aggregate.
     */
    where?: AddressUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressUsers to fetch.
     */
    orderBy?: AddressUserOrderByWithRelationInput | AddressUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddressUsers
    **/
    _count?: true | AddressUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressUserMaxAggregateInputType
  }

  export type GetAddressUserAggregateType<T extends AddressUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAddressUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddressUser[P]>
      : GetScalarType<T[P], AggregateAddressUser[P]>
  }




  export type AddressUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressUserWhereInput
    orderBy?: AddressUserOrderByWithAggregationInput | AddressUserOrderByWithAggregationInput[]
    by: AddressUserScalarFieldEnum[] | AddressUserScalarFieldEnum
    having?: AddressUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressUserCountAggregateInputType | true
    _avg?: AddressUserAvgAggregateInputType
    _sum?: AddressUserSumAggregateInputType
    _min?: AddressUserMinAggregateInputType
    _max?: AddressUserMaxAggregateInputType
  }

  export type AddressUserGroupByOutputType = {
    id: number
    userId: number
    shipName: string | null
    shipAdress: string | null
    shipPhone: string | null
    shipEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: AddressUserCountAggregateOutputType | null
    _avg: AddressUserAvgAggregateOutputType | null
    _sum: AddressUserSumAggregateOutputType | null
    _min: AddressUserMinAggregateOutputType | null
    _max: AddressUserMaxAggregateOutputType | null
  }

  type GetAddressUserGroupByPayload<T extends AddressUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressUserGroupByOutputType[P]>
            : GetScalarType<T[P], AddressUserGroupByOutputType[P]>
        }
      >
    >


  export type AddressUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    shipName?: boolean
    shipAdress?: boolean
    shipPhone?: boolean
    shipEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    OrderProduct?: boolean | AddressUser$OrderProductArgs<ExtArgs>
    _count?: boolean | AddressUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addressUser"]>

  export type AddressUserSelectScalar = {
    id?: boolean
    userId?: boolean
    shipName?: boolean
    shipAdress?: boolean
    shipPhone?: boolean
    shipEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    OrderProduct?: boolean | AddressUser$OrderProductArgs<ExtArgs>
    _count?: boolean | AddressUserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AddressUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddressUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      OrderProduct: Prisma.$OrderProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      shipName: string | null
      shipAdress: string | null
      shipPhone: string | null
      shipEmail: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["addressUser"]>
    composites: {}
  }


  type AddressUserGetPayload<S extends boolean | null | undefined | AddressUserDefaultArgs> = $Result.GetResult<Prisma.$AddressUserPayload, S>

  type AddressUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AddressUserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddressUserCountAggregateInputType | true
    }

  export interface AddressUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddressUser'], meta: { name: 'AddressUser' } }
    /**
     * Find zero or one AddressUser that matches the filter.
     * @param {AddressUserFindUniqueArgs} args - Arguments to find a AddressUser
     * @example
     * // Get one AddressUser
     * const addressUser = await prisma.addressUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressUserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUserFindUniqueArgs<ExtArgs>>
    ): Prisma__AddressUserClient<$Result.GetResult<Prisma.$AddressUserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AddressUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddressUserFindUniqueOrThrowArgs} args - Arguments to find a AddressUser
     * @example
     * // Get one AddressUser
     * const addressUser = await prisma.addressUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AddressUserClient<$Result.GetResult<Prisma.$AddressUserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AddressUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUserFindFirstArgs} args - Arguments to find a AddressUser
     * @example
     * // Get one AddressUser
     * const addressUser = await prisma.addressUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressUserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressUserFindFirstArgs<ExtArgs>>
    ): Prisma__AddressUserClient<$Result.GetResult<Prisma.$AddressUserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AddressUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUserFindFirstOrThrowArgs} args - Arguments to find a AddressUser
     * @example
     * // Get one AddressUser
     * const addressUser = await prisma.addressUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AddressUserClient<$Result.GetResult<Prisma.$AddressUserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AddressUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddressUsers
     * const addressUsers = await prisma.addressUser.findMany()
     * 
     * // Get first 10 AddressUsers
     * const addressUsers = await prisma.addressUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressUserWithIdOnly = await prisma.addressUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressUserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AddressUser.
     * @param {AddressUserCreateArgs} args - Arguments to create a AddressUser.
     * @example
     * // Create one AddressUser
     * const AddressUser = await prisma.addressUser.create({
     *   data: {
     *     // ... data to create a AddressUser
     *   }
     * })
     * 
    **/
    create<T extends AddressUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUserCreateArgs<ExtArgs>>
    ): Prisma__AddressUserClient<$Result.GetResult<Prisma.$AddressUserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AddressUsers.
     *     @param {AddressUserCreateManyArgs} args - Arguments to create many AddressUsers.
     *     @example
     *     // Create many AddressUsers
     *     const addressUser = await prisma.addressUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AddressUser.
     * @param {AddressUserDeleteArgs} args - Arguments to delete one AddressUser.
     * @example
     * // Delete one AddressUser
     * const AddressUser = await prisma.addressUser.delete({
     *   where: {
     *     // ... filter to delete one AddressUser
     *   }
     * })
     * 
    **/
    delete<T extends AddressUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUserDeleteArgs<ExtArgs>>
    ): Prisma__AddressUserClient<$Result.GetResult<Prisma.$AddressUserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AddressUser.
     * @param {AddressUserUpdateArgs} args - Arguments to update one AddressUser.
     * @example
     * // Update one AddressUser
     * const addressUser = await prisma.addressUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUserUpdateArgs<ExtArgs>>
    ): Prisma__AddressUserClient<$Result.GetResult<Prisma.$AddressUserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AddressUsers.
     * @param {AddressUserDeleteManyArgs} args - Arguments to filter AddressUsers to delete.
     * @example
     * // Delete a few AddressUsers
     * const { count } = await prisma.addressUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AddressUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddressUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddressUsers
     * const addressUser = await prisma.addressUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AddressUser.
     * @param {AddressUserUpsertArgs} args - Arguments to update or create a AddressUser.
     * @example
     * // Update or create a AddressUser
     * const addressUser = await prisma.addressUser.upsert({
     *   create: {
     *     // ... data to create a AddressUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddressUser we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AddressUserUpsertArgs<ExtArgs>>
    ): Prisma__AddressUserClient<$Result.GetResult<Prisma.$AddressUserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AddressUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUserCountArgs} args - Arguments to filter AddressUsers to count.
     * @example
     * // Count the number of AddressUsers
     * const count = await prisma.addressUser.count({
     *   where: {
     *     // ... the filter for the AddressUsers we want to count
     *   }
     * })
    **/
    count<T extends AddressUserCountArgs>(
      args?: Subset<T, AddressUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddressUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressUserAggregateArgs>(args: Subset<T, AddressUserAggregateArgs>): Prisma.PrismaPromise<GetAddressUserAggregateType<T>>

    /**
     * Group by AddressUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressUserGroupByArgs['orderBy'] }
        : { orderBy?: AddressUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddressUser model
   */
  readonly fields: AddressUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddressUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    OrderProduct<T extends AddressUser$OrderProductArgs<ExtArgs> = {}>(args?: Subset<T, AddressUser$OrderProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AddressUser model
   */ 
  interface AddressUserFieldRefs {
    readonly id: FieldRef<"AddressUser", 'Int'>
    readonly userId: FieldRef<"AddressUser", 'Int'>
    readonly shipName: FieldRef<"AddressUser", 'String'>
    readonly shipAdress: FieldRef<"AddressUser", 'String'>
    readonly shipPhone: FieldRef<"AddressUser", 'String'>
    readonly shipEmail: FieldRef<"AddressUser", 'String'>
    readonly createdAt: FieldRef<"AddressUser", 'DateTime'>
    readonly updatedAt: FieldRef<"AddressUser", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AddressUser findUnique
   */
  export type AddressUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUser
     */
    select?: AddressUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressUserInclude<ExtArgs> | null
    /**
     * Filter, which AddressUser to fetch.
     */
    where: AddressUserWhereUniqueInput
  }


  /**
   * AddressUser findUniqueOrThrow
   */
  export type AddressUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUser
     */
    select?: AddressUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressUserInclude<ExtArgs> | null
    /**
     * Filter, which AddressUser to fetch.
     */
    where: AddressUserWhereUniqueInput
  }


  /**
   * AddressUser findFirst
   */
  export type AddressUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUser
     */
    select?: AddressUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressUserInclude<ExtArgs> | null
    /**
     * Filter, which AddressUser to fetch.
     */
    where?: AddressUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressUsers to fetch.
     */
    orderBy?: AddressUserOrderByWithRelationInput | AddressUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddressUsers.
     */
    cursor?: AddressUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddressUsers.
     */
    distinct?: AddressUserScalarFieldEnum | AddressUserScalarFieldEnum[]
  }


  /**
   * AddressUser findFirstOrThrow
   */
  export type AddressUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUser
     */
    select?: AddressUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressUserInclude<ExtArgs> | null
    /**
     * Filter, which AddressUser to fetch.
     */
    where?: AddressUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressUsers to fetch.
     */
    orderBy?: AddressUserOrderByWithRelationInput | AddressUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddressUsers.
     */
    cursor?: AddressUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddressUsers.
     */
    distinct?: AddressUserScalarFieldEnum | AddressUserScalarFieldEnum[]
  }


  /**
   * AddressUser findMany
   */
  export type AddressUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUser
     */
    select?: AddressUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressUserInclude<ExtArgs> | null
    /**
     * Filter, which AddressUsers to fetch.
     */
    where?: AddressUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddressUsers to fetch.
     */
    orderBy?: AddressUserOrderByWithRelationInput | AddressUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddressUsers.
     */
    cursor?: AddressUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddressUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddressUsers.
     */
    skip?: number
    distinct?: AddressUserScalarFieldEnum | AddressUserScalarFieldEnum[]
  }


  /**
   * AddressUser create
   */
  export type AddressUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUser
     */
    select?: AddressUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AddressUser.
     */
    data: XOR<AddressUserCreateInput, AddressUserUncheckedCreateInput>
  }


  /**
   * AddressUser createMany
   */
  export type AddressUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddressUsers.
     */
    data: AddressUserCreateManyInput | AddressUserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AddressUser update
   */
  export type AddressUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUser
     */
    select?: AddressUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AddressUser.
     */
    data: XOR<AddressUserUpdateInput, AddressUserUncheckedUpdateInput>
    /**
     * Choose, which AddressUser to update.
     */
    where: AddressUserWhereUniqueInput
  }


  /**
   * AddressUser updateMany
   */
  export type AddressUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddressUsers.
     */
    data: XOR<AddressUserUpdateManyMutationInput, AddressUserUncheckedUpdateManyInput>
    /**
     * Filter which AddressUsers to update
     */
    where?: AddressUserWhereInput
  }


  /**
   * AddressUser upsert
   */
  export type AddressUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUser
     */
    select?: AddressUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AddressUser to update in case it exists.
     */
    where: AddressUserWhereUniqueInput
    /**
     * In case the AddressUser found by the `where` argument doesn't exist, create a new AddressUser with this data.
     */
    create: XOR<AddressUserCreateInput, AddressUserUncheckedCreateInput>
    /**
     * In case the AddressUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUserUpdateInput, AddressUserUncheckedUpdateInput>
  }


  /**
   * AddressUser delete
   */
  export type AddressUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUser
     */
    select?: AddressUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressUserInclude<ExtArgs> | null
    /**
     * Filter which AddressUser to delete.
     */
    where: AddressUserWhereUniqueInput
  }


  /**
   * AddressUser deleteMany
   */
  export type AddressUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddressUsers to delete
     */
    where?: AddressUserWhereInput
  }


  /**
   * AddressUser.OrderProduct
   */
  export type AddressUser$OrderProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    where?: OrderProductWhereInput
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    cursor?: OrderProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }


  /**
   * AddressUser without action
   */
  export type AddressUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUser
     */
    select?: AddressUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressUserInclude<ExtArgs> | null
  }



  /**
   * Model Banner
   */

  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerAvgAggregateOutputType = {
    id: number | null
  }

  export type BannerSumAggregateOutputType = {
    id: number | null
  }

  export type BannerMinAggregateOutputType = {
    id: number | null
    description: string | null
    name: string | null
    status: $Enums.Status | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerMaxAggregateOutputType = {
    id: number | null
    description: string | null
    name: string | null
    status: $Enums.Status | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    description: number
    name: number
    status: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BannerAvgAggregateInputType = {
    id?: true
  }

  export type BannerSumAggregateInputType = {
    id?: true
  }

  export type BannerMinAggregateInputType = {
    id?: true
    description?: true
    name?: true
    status?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    description?: true
    name?: true
    status?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    description?: true
    name?: true
    status?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banner to aggregate.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type BannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BannerWhereInput
    orderBy?: BannerOrderByWithAggregationInput | BannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: BannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _avg?: BannerAvgAggregateInputType
    _sum?: BannerSumAggregateInputType
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }

  export type BannerGroupByOutputType = {
    id: number
    description: string | null
    name: string | null
    status: $Enums.Status | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends BannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type BannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    name?: boolean
    status?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banner"]>

  export type BannerSelectScalar = {
    id?: boolean
    description?: boolean
    name?: boolean
    status?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Banner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string | null
      name: string | null
      status: $Enums.Status | null
      image: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["banner"]>
    composites: {}
  }


  type BannerGetPayload<S extends boolean | null | undefined | BannerDefaultArgs> = $Result.GetResult<Prisma.$BannerPayload, S>

  type BannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BannerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface BannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Banner'], meta: { name: 'Banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {BannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BannerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BannerFindUniqueArgs<ExtArgs>>
    ): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Banner that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BannerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BannerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BannerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BannerFindFirstArgs<ExtArgs>>
    ): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BannerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BannerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BannerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BannerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Banner.
     * @param {BannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
    **/
    create<T extends BannerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BannerCreateArgs<ExtArgs>>
    ): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Banners.
     *     @param {BannerCreateManyArgs} args - Arguments to create many Banners.
     *     @example
     *     // Create many Banners
     *     const banner = await prisma.banner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BannerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BannerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banner.
     * @param {BannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
    **/
    delete<T extends BannerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BannerDeleteArgs<ExtArgs>>
    ): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Banner.
     * @param {BannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BannerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BannerUpdateArgs<ExtArgs>>
    ): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Banners.
     * @param {BannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BannerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BannerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BannerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BannerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banner.
     * @param {BannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
    **/
    upsert<T extends BannerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BannerUpsertArgs<ExtArgs>>
    ): Prisma__BannerClient<$Result.GetResult<Prisma.$BannerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends BannerCountArgs>(
      args?: Subset<T, BannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerGroupByArgs['orderBy'] }
        : { orderBy?: BannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Banner model
   */
  readonly fields: BannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Banner model
   */ 
  interface BannerFieldRefs {
    readonly id: FieldRef<"Banner", 'Int'>
    readonly description: FieldRef<"Banner", 'String'>
    readonly name: FieldRef<"Banner", 'String'>
    readonly status: FieldRef<"Banner", 'Status'>
    readonly image: FieldRef<"Banner", 'String'>
    readonly createdAt: FieldRef<"Banner", 'DateTime'>
    readonly updatedAt: FieldRef<"Banner", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Banner findUnique
   */
  export type BannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }


  /**
   * Banner findUniqueOrThrow
   */
  export type BannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where: BannerWhereUniqueInput
  }


  /**
   * Banner findFirst
   */
  export type BannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }


  /**
   * Banner findFirstOrThrow
   */
  export type BannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banner to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }


  /**
   * Banner findMany
   */
  export type BannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter, which Banners to fetch.
     */
    where?: BannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banners to fetch.
     */
    orderBy?: BannerOrderByWithRelationInput | BannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banners.
     */
    cursor?: BannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }


  /**
   * Banner create
   */
  export type BannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * The data needed to create a Banner.
     */
    data?: XOR<BannerCreateInput, BannerUncheckedCreateInput>
  }


  /**
   * Banner createMany
   */
  export type BannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Banners.
     */
    data: BannerCreateManyInput | BannerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Banner update
   */
  export type BannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * The data needed to update a Banner.
     */
    data: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
    /**
     * Choose, which Banner to update.
     */
    where: BannerWhereUniqueInput
  }


  /**
   * Banner updateMany
   */
  export type BannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Banners.
     */
    data: XOR<BannerUpdateManyMutationInput, BannerUncheckedUpdateManyInput>
    /**
     * Filter which Banners to update
     */
    where?: BannerWhereInput
  }


  /**
   * Banner upsert
   */
  export type BannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * The filter to search for the Banner to update in case it exists.
     */
    where: BannerWhereUniqueInput
    /**
     * In case the Banner found by the `where` argument doesn't exist, create a new Banner with this data.
     */
    create: XOR<BannerCreateInput, BannerUncheckedCreateInput>
    /**
     * In case the Banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerUpdateInput, BannerUncheckedUpdateInput>
  }


  /**
   * Banner delete
   */
  export type BannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
    /**
     * Filter which Banner to delete.
     */
    where: BannerWhereUniqueInput
  }


  /**
   * Banner deleteMany
   */
  export type BannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Banners to delete
     */
    where?: BannerWhereInput
  }


  /**
   * Banner without action
   */
  export type BannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Banner
     */
    select?: BannerSelect<ExtArgs> | null
  }



  /**
   * Model Blog
   */

  export type AggregateBlog = {
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  export type BlogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    view: number | null
  }

  export type BlogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    view: number | null
  }

  export type BlogMinAggregateOutputType = {
    id: number | null
    title: string | null
    subject: $Enums.Subject | null
    status: $Enums.Status | null
    image: string | null
    contentMarkdown: string | null
    contentHTML: string | null
    userId: number | null
    view: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogMaxAggregateOutputType = {
    id: number | null
    title: string | null
    subject: $Enums.Subject | null
    status: $Enums.Status | null
    image: string | null
    contentMarkdown: string | null
    contentHTML: string | null
    userId: number | null
    view: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogCountAggregateOutputType = {
    id: number
    title: number
    subject: number
    status: number
    image: number
    contentMarkdown: number
    contentHTML: number
    userId: number
    view: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogAvgAggregateInputType = {
    id?: true
    userId?: true
    view?: true
  }

  export type BlogSumAggregateInputType = {
    id?: true
    userId?: true
    view?: true
  }

  export type BlogMinAggregateInputType = {
    id?: true
    title?: true
    subject?: true
    status?: true
    image?: true
    contentMarkdown?: true
    contentHTML?: true
    userId?: true
    view?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogMaxAggregateInputType = {
    id?: true
    title?: true
    subject?: true
    status?: true
    image?: true
    contentMarkdown?: true
    contentHTML?: true
    userId?: true
    view?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogCountAggregateInputType = {
    id?: true
    title?: true
    subject?: true
    status?: true
    image?: true
    contentMarkdown?: true
    contentHTML?: true
    userId?: true
    view?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blog to aggregate.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blogs
    **/
    _count?: true | BlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogMaxAggregateInputType
  }

  export type GetBlogAggregateType<T extends BlogAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog[P]>
      : GetScalarType<T[P], AggregateBlog[P]>
  }




  export type BlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithAggregationInput | BlogOrderByWithAggregationInput[]
    by: BlogScalarFieldEnum[] | BlogScalarFieldEnum
    having?: BlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCountAggregateInputType | true
    _avg?: BlogAvgAggregateInputType
    _sum?: BlogSumAggregateInputType
    _min?: BlogMinAggregateInputType
    _max?: BlogMaxAggregateInputType
  }

  export type BlogGroupByOutputType = {
    id: number
    title: string | null
    subject: $Enums.Subject | null
    status: $Enums.Status | null
    image: string | null
    contentMarkdown: string | null
    contentHTML: string | null
    userId: number | null
    view: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  type GetBlogGroupByPayload<T extends BlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogGroupByOutputType[P]>
            : GetScalarType<T[P], BlogGroupByOutputType[P]>
        }
      >
    >


  export type BlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subject?: boolean
    status?: boolean
    image?: boolean
    contentMarkdown?: boolean
    contentHTML?: boolean
    userId?: boolean
    view?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Blog$userArgs<ExtArgs>
    Comment?: boolean | Blog$CommentArgs<ExtArgs>
    _count?: boolean | BlogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blog"]>

  export type BlogSelectScalar = {
    id?: boolean
    title?: boolean
    subject?: boolean
    status?: boolean
    image?: boolean
    contentMarkdown?: boolean
    contentHTML?: boolean
    userId?: boolean
    view?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Blog$userArgs<ExtArgs>
    Comment?: boolean | Blog$CommentArgs<ExtArgs>
    _count?: boolean | BlogCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      Comment: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      subject: $Enums.Subject | null
      status: $Enums.Status | null
      image: string | null
      contentMarkdown: string | null
      contentHTML: string | null
      userId: number | null
      view: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["blog"]>
    composites: {}
  }


  type BlogGetPayload<S extends boolean | null | undefined | BlogDefaultArgs> = $Result.GetResult<Prisma.$BlogPayload, S>

  type BlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlogCountAggregateInputType | true
    }

  export interface BlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blog'], meta: { name: 'Blog' } }
    /**
     * Find zero or one Blog that matches the filter.
     * @param {BlogFindUniqueArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BlogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BlogFindUniqueArgs<ExtArgs>>
    ): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Blog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BlogFindUniqueOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BlogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Blog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BlogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogFindFirstArgs<ExtArgs>>
    ): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Blog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BlogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blog.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogWithIdOnly = await prisma.blog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BlogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Blog.
     * @param {BlogCreateArgs} args - Arguments to create a Blog.
     * @example
     * // Create one Blog
     * const Blog = await prisma.blog.create({
     *   data: {
     *     // ... data to create a Blog
     *   }
     * })
     * 
    **/
    create<T extends BlogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BlogCreateArgs<ExtArgs>>
    ): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Blogs.
     *     @param {BlogCreateManyArgs} args - Arguments to create many Blogs.
     *     @example
     *     // Create many Blogs
     *     const blog = await prisma.blog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BlogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog.
     * @param {BlogDeleteArgs} args - Arguments to delete one Blog.
     * @example
     * // Delete one Blog
     * const Blog = await prisma.blog.delete({
     *   where: {
     *     // ... filter to delete one Blog
     *   }
     * })
     * 
    **/
    delete<T extends BlogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BlogDeleteArgs<ExtArgs>>
    ): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Blog.
     * @param {BlogUpdateArgs} args - Arguments to update one Blog.
     * @example
     * // Update one Blog
     * const blog = await prisma.blog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BlogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BlogUpdateArgs<ExtArgs>>
    ): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Blogs.
     * @param {BlogDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BlogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BlogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BlogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BlogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog.
     * @param {BlogUpsertArgs} args - Arguments to update or create a Blog.
     * @example
     * // Update or create a Blog
     * const blog = await prisma.blog.upsert({
     *   create: {
     *     // ... data to create a Blog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog we want to update
     *   }
     * })
    **/
    upsert<T extends BlogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BlogUpsertArgs<ExtArgs>>
    ): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blog.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends BlogCountArgs>(
      args?: Subset<T, BlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogAggregateArgs>(args: Subset<T, BlogAggregateArgs>): Prisma.PrismaPromise<GetBlogAggregateType<T>>

    /**
     * Group by Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogGroupByArgs['orderBy'] }
        : { orderBy?: BlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blog model
   */
  readonly fields: BlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends Blog$userArgs<ExtArgs> = {}>(args?: Subset<T, Blog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Comment<T extends Blog$CommentArgs<ExtArgs> = {}>(args?: Subset<T, Blog$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Blog model
   */ 
  interface BlogFieldRefs {
    readonly id: FieldRef<"Blog", 'Int'>
    readonly title: FieldRef<"Blog", 'String'>
    readonly subject: FieldRef<"Blog", 'Subject'>
    readonly status: FieldRef<"Blog", 'Status'>
    readonly image: FieldRef<"Blog", 'String'>
    readonly contentMarkdown: FieldRef<"Blog", 'String'>
    readonly contentHTML: FieldRef<"Blog", 'String'>
    readonly userId: FieldRef<"Blog", 'Int'>
    readonly view: FieldRef<"Blog", 'Int'>
    readonly createdAt: FieldRef<"Blog", 'DateTime'>
    readonly updatedAt: FieldRef<"Blog", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Blog findUnique
   */
  export type BlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }


  /**
   * Blog findUniqueOrThrow
   */
  export type BlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }


  /**
   * Blog findFirst
   */
  export type BlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }


  /**
   * Blog findFirstOrThrow
   */
  export type BlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }


  /**
   * Blog findMany
   */
  export type BlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }


  /**
   * Blog create
   */
  export type BlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The data needed to create a Blog.
     */
    data?: XOR<BlogCreateInput, BlogUncheckedCreateInput>
  }


  /**
   * Blog createMany
   */
  export type BlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blogs.
     */
    data: BlogCreateManyInput | BlogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Blog update
   */
  export type BlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The data needed to update a Blog.
     */
    data: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
    /**
     * Choose, which Blog to update.
     */
    where: BlogWhereUniqueInput
  }


  /**
   * Blog updateMany
   */
  export type BlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogWhereInput
  }


  /**
   * Blog upsert
   */
  export type BlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * The filter to search for the Blog to update in case it exists.
     */
    where: BlogWhereUniqueInput
    /**
     * In case the Blog found by the `where` argument doesn't exist, create a new Blog with this data.
     */
    create: XOR<BlogCreateInput, BlogUncheckedCreateInput>
    /**
     * In case the Blog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
  }


  /**
   * Blog delete
   */
  export type BlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlogInclude<ExtArgs> | null
    /**
     * Filter which Blog to delete.
     */
    where: BlogWhereUniqueInput
  }


  /**
   * Blog deleteMany
   */
  export type BlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blogs to delete
     */
    where?: BlogWhereInput
  }


  /**
   * Blog.user
   */
  export type Blog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Blog.Comment
   */
  export type Blog$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Blog without action
   */
  export type BlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlogInclude<ExtArgs> | null
  }



  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    productId: number | null
    userId: number | null
    blogId: number | null
    star: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    parentId: number | null
    productId: number | null
    userId: number | null
    blogId: number | null
    star: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    content: string | null
    image: string | null
    parentId: number | null
    productId: number | null
    userId: number | null
    blogId: number | null
    star: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    content: string | null
    image: string | null
    parentId: number | null
    productId: number | null
    userId: number | null
    blogId: number | null
    star: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    image: number
    parentId: number
    productId: number
    userId: number
    blogId: number
    star: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    parentId?: true
    productId?: true
    userId?: true
    blogId?: true
    star?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    parentId?: true
    productId?: true
    userId?: true
    blogId?: true
    star?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    image?: true
    parentId?: true
    productId?: true
    userId?: true
    blogId?: true
    star?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    image?: true
    parentId?: true
    productId?: true
    userId?: true
    blogId?: true
    star?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    image?: true
    parentId?: true
    productId?: true
    userId?: true
    blogId?: true
    star?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    content: string | null
    image: string | null
    parentId: number | null
    productId: number | null
    userId: number | null
    blogId: number | null
    star: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    image?: boolean
    parentId?: boolean
    productId?: boolean
    userId?: boolean
    blogId?: boolean
    star?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | Comment$productArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
    blog?: boolean | Comment$blogArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    image?: boolean
    parentId?: boolean
    productId?: boolean
    userId?: boolean
    blogId?: boolean
    star?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | Comment$productArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
    blog?: boolean | Comment$blogArgs<ExtArgs>
  }


  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      blog: Prisma.$BlogPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string | null
      image: string | null
      parentId: number | null
      productId: number | null
      userId: number | null
      blogId: number | null
      star: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends Comment$productArgs<ExtArgs> = {}>(args?: Subset<T, Comment$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    user<T extends Comment$userArgs<ExtArgs> = {}>(args?: Subset<T, Comment$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    blog<T extends Comment$blogArgs<ExtArgs> = {}>(args?: Subset<T, Comment$blogArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly image: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'Int'>
    readonly productId: FieldRef<"Comment", 'Int'>
    readonly userId: FieldRef<"Comment", 'Int'>
    readonly blogId: FieldRef<"Comment", 'Int'>
    readonly star: FieldRef<"Comment", 'Int'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data?: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment.product
   */
  export type Comment$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }


  /**
   * Comment.user
   */
  export type Comment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Comment.blog
   */
  export type Comment$blogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BlogInclude<ExtArgs> | null
    where?: BlogWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roomId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    text: string | null
    userId: number | null
    roomId: number | null
    unRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    text: string | null
    userId: number | null
    roomId: number | null
    unRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    text: number
    userId: number
    roomId: number
    unRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    userId?: true
    roomId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    text?: true
    userId?: true
    roomId?: true
    unRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    text?: true
    userId?: true
    roomId?: true
    unRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    text?: true
    userId?: true
    roomId?: true
    unRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    text: string | null
    userId: number | null
    roomId: number | null
    unRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    userId?: boolean
    roomId?: boolean
    unRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Message$userArgs<ExtArgs>
    room?: boolean | Message$roomArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    text?: boolean
    userId?: boolean
    roomId?: boolean
    unRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Message$userArgs<ExtArgs>
    room?: boolean | Message$roomArgs<ExtArgs>
  }


  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      room: Prisma.$RoomMessagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      text: string | null
      userId: number | null
      roomId: number | null
      unRead: boolean | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }


  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageCreateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends Message$userArgs<ExtArgs> = {}>(args?: Subset<T, Message$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    room<T extends Message$roomArgs<ExtArgs> = {}>(args?: Subset<T, Message$roomArgs<ExtArgs>>): Prisma__RoomMessageClient<$Result.GetResult<Prisma.$RoomMessagePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly text: FieldRef<"Message", 'String'>
    readonly userId: FieldRef<"Message", 'Int'>
    readonly roomId: FieldRef<"Message", 'Int'>
    readonly unRead: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data?: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }


  /**
   * Message.user
   */
  export type Message$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Message.room
   */
  export type Message$roomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
    where?: RoomMessageWhereInput
  }


  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
  }



  /**
   * Model OrderDetaill
   */

  export type AggregateOrderDetaill = {
    _count: OrderDetaillCountAggregateOutputType | null
    _avg: OrderDetaillAvgAggregateOutputType | null
    _sum: OrderDetaillSumAggregateOutputType | null
    _min: OrderDetaillMinAggregateOutputType | null
    _max: OrderDetaillMaxAggregateOutputType | null
  }

  export type OrderDetaillAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    realPrice: number | null
  }

  export type OrderDetaillSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    realPrice: number | null
  }

  export type OrderDetaillMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    realPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderDetaillMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    realPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderDetaillCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    realPrice: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderDetaillAvgAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    realPrice?: true
  }

  export type OrderDetaillSumAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    realPrice?: true
  }

  export type OrderDetaillMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    realPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderDetaillMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    realPrice?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderDetaillCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    realPrice?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderDetaillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderDetaill to aggregate.
     */
    where?: OrderDetaillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetaills to fetch.
     */
    orderBy?: OrderDetaillOrderByWithRelationInput | OrderDetaillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderDetaillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetaills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetaills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderDetaills
    **/
    _count?: true | OrderDetaillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderDetaillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderDetaillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderDetaillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderDetaillMaxAggregateInputType
  }

  export type GetOrderDetaillAggregateType<T extends OrderDetaillAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderDetaill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderDetaill[P]>
      : GetScalarType<T[P], AggregateOrderDetaill[P]>
  }




  export type OrderDetaillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderDetaillWhereInput
    orderBy?: OrderDetaillOrderByWithAggregationInput | OrderDetaillOrderByWithAggregationInput[]
    by: OrderDetaillScalarFieldEnum[] | OrderDetaillScalarFieldEnum
    having?: OrderDetaillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderDetaillCountAggregateInputType | true
    _avg?: OrderDetaillAvgAggregateInputType
    _sum?: OrderDetaillSumAggregateInputType
    _min?: OrderDetaillMinAggregateInputType
    _max?: OrderDetaillMaxAggregateInputType
  }

  export type OrderDetaillGroupByOutputType = {
    id: number
    orderId: number | null
    productId: number | null
    quantity: number | null
    realPrice: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: OrderDetaillCountAggregateOutputType | null
    _avg: OrderDetaillAvgAggregateOutputType | null
    _sum: OrderDetaillSumAggregateOutputType | null
    _min: OrderDetaillMinAggregateOutputType | null
    _max: OrderDetaillMaxAggregateOutputType | null
  }

  type GetOrderDetaillGroupByPayload<T extends OrderDetaillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderDetaillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderDetaillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderDetaillGroupByOutputType[P]>
            : GetScalarType<T[P], OrderDetaillGroupByOutputType[P]>
        }
      >
    >


  export type OrderDetaillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    realPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDetaill$orderArgs<ExtArgs>
    product?: boolean | OrderDetaill$productArgs<ExtArgs>
  }, ExtArgs["result"]["orderDetaill"]>

  export type OrderDetaillSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    realPrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderDetaillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDetaill$orderArgs<ExtArgs>
    product?: boolean | OrderDetaill$productArgs<ExtArgs>
  }


  export type $OrderDetaillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderDetaill"
    objects: {
      order: Prisma.$OrderProductPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number | null
      productId: number | null
      quantity: number | null
      realPrice: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["orderDetaill"]>
    composites: {}
  }


  type OrderDetaillGetPayload<S extends boolean | null | undefined | OrderDetaillDefaultArgs> = $Result.GetResult<Prisma.$OrderDetaillPayload, S>

  type OrderDetaillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderDetaillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderDetaillCountAggregateInputType | true
    }

  export interface OrderDetaillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderDetaill'], meta: { name: 'OrderDetaill' } }
    /**
     * Find zero or one OrderDetaill that matches the filter.
     * @param {OrderDetaillFindUniqueArgs} args - Arguments to find a OrderDetaill
     * @example
     * // Get one OrderDetaill
     * const orderDetaill = await prisma.orderDetaill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderDetaillFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDetaillFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderDetaillClient<$Result.GetResult<Prisma.$OrderDetaillPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderDetaill that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderDetaillFindUniqueOrThrowArgs} args - Arguments to find a OrderDetaill
     * @example
     * // Get one OrderDetaill
     * const orderDetaill = await prisma.orderDetaill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderDetaillFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDetaillFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderDetaillClient<$Result.GetResult<Prisma.$OrderDetaillPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderDetaill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetaillFindFirstArgs} args - Arguments to find a OrderDetaill
     * @example
     * // Get one OrderDetaill
     * const orderDetaill = await prisma.orderDetaill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderDetaillFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDetaillFindFirstArgs<ExtArgs>>
    ): Prisma__OrderDetaillClient<$Result.GetResult<Prisma.$OrderDetaillPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderDetaill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetaillFindFirstOrThrowArgs} args - Arguments to find a OrderDetaill
     * @example
     * // Get one OrderDetaill
     * const orderDetaill = await prisma.orderDetaill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderDetaillFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDetaillFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderDetaillClient<$Result.GetResult<Prisma.$OrderDetaillPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderDetaills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetaillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderDetaills
     * const orderDetaills = await prisma.orderDetaill.findMany()
     * 
     * // Get first 10 OrderDetaills
     * const orderDetaills = await prisma.orderDetaill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderDetaillWithIdOnly = await prisma.orderDetaill.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderDetaillFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDetaillFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetaillPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderDetaill.
     * @param {OrderDetaillCreateArgs} args - Arguments to create a OrderDetaill.
     * @example
     * // Create one OrderDetaill
     * const OrderDetaill = await prisma.orderDetaill.create({
     *   data: {
     *     // ... data to create a OrderDetaill
     *   }
     * })
     * 
    **/
    create<T extends OrderDetaillCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDetaillCreateArgs<ExtArgs>>
    ): Prisma__OrderDetaillClient<$Result.GetResult<Prisma.$OrderDetaillPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderDetaills.
     *     @param {OrderDetaillCreateManyArgs} args - Arguments to create many OrderDetaills.
     *     @example
     *     // Create many OrderDetaills
     *     const orderDetaill = await prisma.orderDetaill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderDetaillCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDetaillCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderDetaill.
     * @param {OrderDetaillDeleteArgs} args - Arguments to delete one OrderDetaill.
     * @example
     * // Delete one OrderDetaill
     * const OrderDetaill = await prisma.orderDetaill.delete({
     *   where: {
     *     // ... filter to delete one OrderDetaill
     *   }
     * })
     * 
    **/
    delete<T extends OrderDetaillDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDetaillDeleteArgs<ExtArgs>>
    ): Prisma__OrderDetaillClient<$Result.GetResult<Prisma.$OrderDetaillPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderDetaill.
     * @param {OrderDetaillUpdateArgs} args - Arguments to update one OrderDetaill.
     * @example
     * // Update one OrderDetaill
     * const orderDetaill = await prisma.orderDetaill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderDetaillUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDetaillUpdateArgs<ExtArgs>>
    ): Prisma__OrderDetaillClient<$Result.GetResult<Prisma.$OrderDetaillPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderDetaills.
     * @param {OrderDetaillDeleteManyArgs} args - Arguments to filter OrderDetaills to delete.
     * @example
     * // Delete a few OrderDetaills
     * const { count } = await prisma.orderDetaill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDetaillDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderDetaillDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderDetaills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetaillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderDetaills
     * const orderDetaill = await prisma.orderDetaill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderDetaillUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDetaillUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderDetaill.
     * @param {OrderDetaillUpsertArgs} args - Arguments to update or create a OrderDetaill.
     * @example
     * // Update or create a OrderDetaill
     * const orderDetaill = await prisma.orderDetaill.upsert({
     *   create: {
     *     // ... data to create a OrderDetaill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderDetaill we want to update
     *   }
     * })
    **/
    upsert<T extends OrderDetaillUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderDetaillUpsertArgs<ExtArgs>>
    ): Prisma__OrderDetaillClient<$Result.GetResult<Prisma.$OrderDetaillPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderDetaills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetaillCountArgs} args - Arguments to filter OrderDetaills to count.
     * @example
     * // Count the number of OrderDetaills
     * const count = await prisma.orderDetaill.count({
     *   where: {
     *     // ... the filter for the OrderDetaills we want to count
     *   }
     * })
    **/
    count<T extends OrderDetaillCountArgs>(
      args?: Subset<T, OrderDetaillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderDetaillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderDetaill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetaillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderDetaillAggregateArgs>(args: Subset<T, OrderDetaillAggregateArgs>): Prisma.PrismaPromise<GetOrderDetaillAggregateType<T>>

    /**
     * Group by OrderDetaill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderDetaillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderDetaillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderDetaillGroupByArgs['orderBy'] }
        : { orderBy?: OrderDetaillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderDetaillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderDetaillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderDetaill model
   */
  readonly fields: OrderDetaillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderDetaill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderDetaillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    order<T extends OrderDetaill$orderArgs<ExtArgs> = {}>(args?: Subset<T, OrderDetaill$orderArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    product<T extends OrderDetaill$productArgs<ExtArgs> = {}>(args?: Subset<T, OrderDetaill$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OrderDetaill model
   */ 
  interface OrderDetaillFieldRefs {
    readonly id: FieldRef<"OrderDetaill", 'Int'>
    readonly orderId: FieldRef<"OrderDetaill", 'Int'>
    readonly productId: FieldRef<"OrderDetaill", 'Int'>
    readonly quantity: FieldRef<"OrderDetaill", 'Int'>
    readonly realPrice: FieldRef<"OrderDetaill", 'Int'>
    readonly createdAt: FieldRef<"OrderDetaill", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderDetaill", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OrderDetaill findUnique
   */
  export type OrderDetaillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetaill
     */
    select?: OrderDetaillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderDetaillInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetaill to fetch.
     */
    where: OrderDetaillWhereUniqueInput
  }


  /**
   * OrderDetaill findUniqueOrThrow
   */
  export type OrderDetaillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetaill
     */
    select?: OrderDetaillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderDetaillInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetaill to fetch.
     */
    where: OrderDetaillWhereUniqueInput
  }


  /**
   * OrderDetaill findFirst
   */
  export type OrderDetaillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetaill
     */
    select?: OrderDetaillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderDetaillInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetaill to fetch.
     */
    where?: OrderDetaillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetaills to fetch.
     */
    orderBy?: OrderDetaillOrderByWithRelationInput | OrderDetaillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderDetaills.
     */
    cursor?: OrderDetaillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetaills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetaills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderDetaills.
     */
    distinct?: OrderDetaillScalarFieldEnum | OrderDetaillScalarFieldEnum[]
  }


  /**
   * OrderDetaill findFirstOrThrow
   */
  export type OrderDetaillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetaill
     */
    select?: OrderDetaillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderDetaillInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetaill to fetch.
     */
    where?: OrderDetaillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetaills to fetch.
     */
    orderBy?: OrderDetaillOrderByWithRelationInput | OrderDetaillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderDetaills.
     */
    cursor?: OrderDetaillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetaills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetaills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderDetaills.
     */
    distinct?: OrderDetaillScalarFieldEnum | OrderDetaillScalarFieldEnum[]
  }


  /**
   * OrderDetaill findMany
   */
  export type OrderDetaillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetaill
     */
    select?: OrderDetaillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderDetaillInclude<ExtArgs> | null
    /**
     * Filter, which OrderDetaills to fetch.
     */
    where?: OrderDetaillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderDetaills to fetch.
     */
    orderBy?: OrderDetaillOrderByWithRelationInput | OrderDetaillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderDetaills.
     */
    cursor?: OrderDetaillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderDetaills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderDetaills.
     */
    skip?: number
    distinct?: OrderDetaillScalarFieldEnum | OrderDetaillScalarFieldEnum[]
  }


  /**
   * OrderDetaill create
   */
  export type OrderDetaillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetaill
     */
    select?: OrderDetaillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderDetaillInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderDetaill.
     */
    data?: XOR<OrderDetaillCreateInput, OrderDetaillUncheckedCreateInput>
  }


  /**
   * OrderDetaill createMany
   */
  export type OrderDetaillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderDetaills.
     */
    data: OrderDetaillCreateManyInput | OrderDetaillCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OrderDetaill update
   */
  export type OrderDetaillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetaill
     */
    select?: OrderDetaillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderDetaillInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderDetaill.
     */
    data: XOR<OrderDetaillUpdateInput, OrderDetaillUncheckedUpdateInput>
    /**
     * Choose, which OrderDetaill to update.
     */
    where: OrderDetaillWhereUniqueInput
  }


  /**
   * OrderDetaill updateMany
   */
  export type OrderDetaillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderDetaills.
     */
    data: XOR<OrderDetaillUpdateManyMutationInput, OrderDetaillUncheckedUpdateManyInput>
    /**
     * Filter which OrderDetaills to update
     */
    where?: OrderDetaillWhereInput
  }


  /**
   * OrderDetaill upsert
   */
  export type OrderDetaillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetaill
     */
    select?: OrderDetaillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderDetaillInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderDetaill to update in case it exists.
     */
    where: OrderDetaillWhereUniqueInput
    /**
     * In case the OrderDetaill found by the `where` argument doesn't exist, create a new OrderDetaill with this data.
     */
    create: XOR<OrderDetaillCreateInput, OrderDetaillUncheckedCreateInput>
    /**
     * In case the OrderDetaill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderDetaillUpdateInput, OrderDetaillUncheckedUpdateInput>
  }


  /**
   * OrderDetaill delete
   */
  export type OrderDetaillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetaill
     */
    select?: OrderDetaillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderDetaillInclude<ExtArgs> | null
    /**
     * Filter which OrderDetaill to delete.
     */
    where: OrderDetaillWhereUniqueInput
  }


  /**
   * OrderDetaill deleteMany
   */
  export type OrderDetaillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderDetaills to delete
     */
    where?: OrderDetaillWhereInput
  }


  /**
   * OrderDetaill.order
   */
  export type OrderDetaill$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    where?: OrderProductWhereInput
  }


  /**
   * OrderDetaill.product
   */
  export type OrderDetaill$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }


  /**
   * OrderDetaill without action
   */
  export type OrderDetaillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetaill
     */
    select?: OrderDetaillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderDetaillInclude<ExtArgs> | null
  }



  /**
   * Model OrderProduct
   */

  export type AggregateOrderProduct = {
    _count: OrderProductCountAggregateOutputType | null
    _avg: OrderProductAvgAggregateOutputType | null
    _sum: OrderProductSumAggregateOutputType | null
    _min: OrderProductMinAggregateOutputType | null
    _max: OrderProductMaxAggregateOutputType | null
  }

  export type OrderProductAvgAggregateOutputType = {
    id: number | null
    addressUserId: number | null
    typeShipId: number | null
    voucherId: number | null
  }

  export type OrderProductSumAggregateOutputType = {
    id: number | null
    addressUserId: number | null
    typeShipId: number | null
    voucherId: number | null
  }

  export type OrderProductMinAggregateOutputType = {
    id: number | null
    addressUserId: number | null
    status: $Enums.Status | null
    typeShipId: number | null
    voucherId: number | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderProductMaxAggregateOutputType = {
    id: number | null
    addressUserId: number | null
    status: $Enums.Status | null
    typeShipId: number | null
    voucherId: number | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderProductCountAggregateOutputType = {
    id: number
    addressUserId: number
    status: number
    typeShipId: number
    voucherId: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderProductAvgAggregateInputType = {
    id?: true
    addressUserId?: true
    typeShipId?: true
    voucherId?: true
  }

  export type OrderProductSumAggregateInputType = {
    id?: true
    addressUserId?: true
    typeShipId?: true
    voucherId?: true
  }

  export type OrderProductMinAggregateInputType = {
    id?: true
    addressUserId?: true
    status?: true
    typeShipId?: true
    voucherId?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderProductMaxAggregateInputType = {
    id?: true
    addressUserId?: true
    status?: true
    typeShipId?: true
    voucherId?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderProductCountAggregateInputType = {
    id?: true
    addressUserId?: true
    status?: true
    typeShipId?: true
    voucherId?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderProduct to aggregate.
     */
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     */
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderProducts
    **/
    _count?: true | OrderProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderProductMaxAggregateInputType
  }

  export type GetOrderProductAggregateType<T extends OrderProductAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderProduct[P]>
      : GetScalarType<T[P], AggregateOrderProduct[P]>
  }




  export type OrderProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderProductWhereInput
    orderBy?: OrderProductOrderByWithAggregationInput | OrderProductOrderByWithAggregationInput[]
    by: OrderProductScalarFieldEnum[] | OrderProductScalarFieldEnum
    having?: OrderProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderProductCountAggregateInputType | true
    _avg?: OrderProductAvgAggregateInputType
    _sum?: OrderProductSumAggregateInputType
    _min?: OrderProductMinAggregateInputType
    _max?: OrderProductMaxAggregateInputType
  }

  export type OrderProductGroupByOutputType = {
    id: number
    addressUserId: number | null
    status: $Enums.Status | null
    typeShipId: number | null
    voucherId: number | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: OrderProductCountAggregateOutputType | null
    _avg: OrderProductAvgAggregateOutputType | null
    _sum: OrderProductSumAggregateOutputType | null
    _min: OrderProductMinAggregateOutputType | null
    _max: OrderProductMaxAggregateOutputType | null
  }

  type GetOrderProductGroupByPayload<T extends OrderProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderProductGroupByOutputType[P]>
            : GetScalarType<T[P], OrderProductGroupByOutputType[P]>
        }
      >
    >


  export type OrderProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addressUserId?: boolean
    status?: boolean
    typeShipId?: boolean
    voucherId?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addressUser?: boolean | OrderProduct$addressUserArgs<ExtArgs>
    typeShip?: boolean | OrderProduct$typeShipArgs<ExtArgs>
    voucher?: boolean | OrderProduct$voucherArgs<ExtArgs>
    OrderDetaill?: boolean | OrderProduct$OrderDetaillArgs<ExtArgs>
    _count?: boolean | OrderProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderProduct"]>

  export type OrderProductSelectScalar = {
    id?: boolean
    addressUserId?: boolean
    status?: boolean
    typeShipId?: boolean
    voucherId?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addressUser?: boolean | OrderProduct$addressUserArgs<ExtArgs>
    typeShip?: boolean | OrderProduct$typeShipArgs<ExtArgs>
    voucher?: boolean | OrderProduct$voucherArgs<ExtArgs>
    OrderDetaill?: boolean | OrderProduct$OrderDetaillArgs<ExtArgs>
    _count?: boolean | OrderProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OrderProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderProduct"
    objects: {
      addressUser: Prisma.$AddressUserPayload<ExtArgs> | null
      typeShip: Prisma.$TypeShipPayload<ExtArgs> | null
      voucher: Prisma.$VoucherPayload<ExtArgs> | null
      OrderDetaill: Prisma.$OrderDetaillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      addressUserId: number | null
      status: $Enums.Status | null
      typeShipId: number | null
      voucherId: number | null
      image: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["orderProduct"]>
    composites: {}
  }


  type OrderProductGetPayload<S extends boolean | null | undefined | OrderProductDefaultArgs> = $Result.GetResult<Prisma.$OrderProductPayload, S>

  type OrderProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderProductCountAggregateInputType | true
    }

  export interface OrderProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderProduct'], meta: { name: 'OrderProduct' } }
    /**
     * Find zero or one OrderProduct that matches the filter.
     * @param {OrderProductFindUniqueArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrderProductFindUniqueArgs<ExtArgs>>
    ): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OrderProduct that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderProductFindUniqueOrThrowArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OrderProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductFindFirstArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderProductFindFirstArgs<ExtArgs>>
    ): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OrderProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductFindFirstOrThrowArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OrderProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderProducts
     * const orderProducts = await prisma.orderProduct.findMany()
     * 
     * // Get first 10 OrderProducts
     * const orderProducts = await prisma.orderProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderProductWithIdOnly = await prisma.orderProduct.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OrderProduct.
     * @param {OrderProductCreateArgs} args - Arguments to create a OrderProduct.
     * @example
     * // Create one OrderProduct
     * const OrderProduct = await prisma.orderProduct.create({
     *   data: {
     *     // ... data to create a OrderProduct
     *   }
     * })
     * 
    **/
    create<T extends OrderProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderProductCreateArgs<ExtArgs>>
    ): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OrderProducts.
     *     @param {OrderProductCreateManyArgs} args - Arguments to create many OrderProducts.
     *     @example
     *     // Create many OrderProducts
     *     const orderProduct = await prisma.orderProduct.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderProduct.
     * @param {OrderProductDeleteArgs} args - Arguments to delete one OrderProduct.
     * @example
     * // Delete one OrderProduct
     * const OrderProduct = await prisma.orderProduct.delete({
     *   where: {
     *     // ... filter to delete one OrderProduct
     *   }
     * })
     * 
    **/
    delete<T extends OrderProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrderProductDeleteArgs<ExtArgs>>
    ): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OrderProduct.
     * @param {OrderProductUpdateArgs} args - Arguments to update one OrderProduct.
     * @example
     * // Update one OrderProduct
     * const orderProduct = await prisma.orderProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrderProductUpdateArgs<ExtArgs>>
    ): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OrderProducts.
     * @param {OrderProductDeleteManyArgs} args - Arguments to filter OrderProducts to delete.
     * @example
     * // Delete a few OrderProducts
     * const { count } = await prisma.orderProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrderProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderProducts
     * const orderProduct = await prisma.orderProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrderProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderProduct.
     * @param {OrderProductUpsertArgs} args - Arguments to update or create a OrderProduct.
     * @example
     * // Update or create a OrderProduct
     * const orderProduct = await prisma.orderProduct.upsert({
     *   create: {
     *     // ... data to create a OrderProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderProduct we want to update
     *   }
     * })
    **/
    upsert<T extends OrderProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrderProductUpsertArgs<ExtArgs>>
    ): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OrderProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductCountArgs} args - Arguments to filter OrderProducts to count.
     * @example
     * // Count the number of OrderProducts
     * const count = await prisma.orderProduct.count({
     *   where: {
     *     // ... the filter for the OrderProducts we want to count
     *   }
     * })
    **/
    count<T extends OrderProductCountArgs>(
      args?: Subset<T, OrderProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderProductAggregateArgs>(args: Subset<T, OrderProductAggregateArgs>): Prisma.PrismaPromise<GetOrderProductAggregateType<T>>

    /**
     * Group by OrderProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderProductGroupByArgs['orderBy'] }
        : { orderBy?: OrderProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderProduct model
   */
  readonly fields: OrderProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    addressUser<T extends OrderProduct$addressUserArgs<ExtArgs> = {}>(args?: Subset<T, OrderProduct$addressUserArgs<ExtArgs>>): Prisma__AddressUserClient<$Result.GetResult<Prisma.$AddressUserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    typeShip<T extends OrderProduct$typeShipArgs<ExtArgs> = {}>(args?: Subset<T, OrderProduct$typeShipArgs<ExtArgs>>): Prisma__TypeShipClient<$Result.GetResult<Prisma.$TypeShipPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    voucher<T extends OrderProduct$voucherArgs<ExtArgs> = {}>(args?: Subset<T, OrderProduct$voucherArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    OrderDetaill<T extends OrderProduct$OrderDetaillArgs<ExtArgs> = {}>(args?: Subset<T, OrderProduct$OrderDetaillArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetaillPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OrderProduct model
   */ 
  interface OrderProductFieldRefs {
    readonly id: FieldRef<"OrderProduct", 'Int'>
    readonly addressUserId: FieldRef<"OrderProduct", 'Int'>
    readonly status: FieldRef<"OrderProduct", 'Status'>
    readonly typeShipId: FieldRef<"OrderProduct", 'Int'>
    readonly voucherId: FieldRef<"OrderProduct", 'Int'>
    readonly image: FieldRef<"OrderProduct", 'String'>
    readonly createdAt: FieldRef<"OrderProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderProduct", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OrderProduct findUnique
   */
  export type OrderProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduct to fetch.
     */
    where: OrderProductWhereUniqueInput
  }


  /**
   * OrderProduct findUniqueOrThrow
   */
  export type OrderProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduct to fetch.
     */
    where: OrderProductWhereUniqueInput
  }


  /**
   * OrderProduct findFirst
   */
  export type OrderProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduct to fetch.
     */
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     */
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderProducts.
     */
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderProducts.
     */
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }


  /**
   * OrderProduct findFirstOrThrow
   */
  export type OrderProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduct to fetch.
     */
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     */
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderProducts.
     */
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderProducts.
     */
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }


  /**
   * OrderProduct findMany
   */
  export type OrderProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProducts to fetch.
     */
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     */
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderProducts.
     */
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     */
    skip?: number
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }


  /**
   * OrderProduct create
   */
  export type OrderProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderProduct.
     */
    data?: XOR<OrderProductCreateInput, OrderProductUncheckedCreateInput>
  }


  /**
   * OrderProduct createMany
   */
  export type OrderProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderProducts.
     */
    data: OrderProductCreateManyInput | OrderProductCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OrderProduct update
   */
  export type OrderProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderProduct.
     */
    data: XOR<OrderProductUpdateInput, OrderProductUncheckedUpdateInput>
    /**
     * Choose, which OrderProduct to update.
     */
    where: OrderProductWhereUniqueInput
  }


  /**
   * OrderProduct updateMany
   */
  export type OrderProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderProducts.
     */
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyInput>
    /**
     * Filter which OrderProducts to update
     */
    where?: OrderProductWhereInput
  }


  /**
   * OrderProduct upsert
   */
  export type OrderProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderProduct to update in case it exists.
     */
    where: OrderProductWhereUniqueInput
    /**
     * In case the OrderProduct found by the `where` argument doesn't exist, create a new OrderProduct with this data.
     */
    create: XOR<OrderProductCreateInput, OrderProductUncheckedCreateInput>
    /**
     * In case the OrderProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderProductUpdateInput, OrderProductUncheckedUpdateInput>
  }


  /**
   * OrderProduct delete
   */
  export type OrderProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter which OrderProduct to delete.
     */
    where: OrderProductWhereUniqueInput
  }


  /**
   * OrderProduct deleteMany
   */
  export type OrderProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderProducts to delete
     */
    where?: OrderProductWhereInput
  }


  /**
   * OrderProduct.addressUser
   */
  export type OrderProduct$addressUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressUser
     */
    select?: AddressUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressUserInclude<ExtArgs> | null
    where?: AddressUserWhereInput
  }


  /**
   * OrderProduct.typeShip
   */
  export type OrderProduct$typeShipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeShip
     */
    select?: TypeShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeShipInclude<ExtArgs> | null
    where?: TypeShipWhereInput
  }


  /**
   * OrderProduct.voucher
   */
  export type OrderProduct$voucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
  }


  /**
   * OrderProduct.OrderDetaill
   */
  export type OrderProduct$OrderDetaillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetaill
     */
    select?: OrderDetaillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderDetaillInclude<ExtArgs> | null
    where?: OrderDetaillWhereInput
    orderBy?: OrderDetaillOrderByWithRelationInput | OrderDetaillOrderByWithRelationInput[]
    cursor?: OrderDetaillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderDetaillScalarFieldEnum | OrderDetaillScalarFieldEnum[]
  }


  /**
   * OrderProduct without action
   */
  export type OrderProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
  }



  /**
   * Model ProductSize
   */

  export type AggregateProductSize = {
    _count: ProductSizeCountAggregateOutputType | null
    _avg: ProductSizeAvgAggregateOutputType | null
    _sum: ProductSizeSumAggregateOutputType | null
    _min: ProductSizeMinAggregateOutputType | null
    _max: ProductSizeMaxAggregateOutputType | null
  }

  export type ProductSizeAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
  }

  export type ProductSizeSumAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
  }

  export type ProductSizeMinAggregateOutputType = {
    id: number | null
    productId: number | null
    size: $Enums.Size | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductSizeMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    size: $Enums.Size | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductSizeCountAggregateOutputType = {
    id: number
    productId: number
    size: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductSizeAvgAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
  }

  export type ProductSizeSumAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
  }

  export type ProductSizeMinAggregateInputType = {
    id?: true
    productId?: true
    size?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductSizeMaxAggregateInputType = {
    id?: true
    productId?: true
    size?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductSizeCountAggregateInputType = {
    id?: true
    productId?: true
    size?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductSizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSize to aggregate.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductSizes
    **/
    _count?: true | ProductSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductSizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductSizeMaxAggregateInputType
  }

  export type GetProductSizeAggregateType<T extends ProductSizeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductSize[P]>
      : GetScalarType<T[P], AggregateProductSize[P]>
  }




  export type ProductSizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductSizeWhereInput
    orderBy?: ProductSizeOrderByWithAggregationInput | ProductSizeOrderByWithAggregationInput[]
    by: ProductSizeScalarFieldEnum[] | ProductSizeScalarFieldEnum
    having?: ProductSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductSizeCountAggregateInputType | true
    _avg?: ProductSizeAvgAggregateInputType
    _sum?: ProductSizeSumAggregateInputType
    _min?: ProductSizeMinAggregateInputType
    _max?: ProductSizeMaxAggregateInputType
  }

  export type ProductSizeGroupByOutputType = {
    id: number
    productId: number | null
    size: $Enums.Size | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: ProductSizeCountAggregateOutputType | null
    _avg: ProductSizeAvgAggregateOutputType | null
    _sum: ProductSizeSumAggregateOutputType | null
    _min: ProductSizeMinAggregateOutputType | null
    _max: ProductSizeMaxAggregateOutputType | null
  }

  type GetProductSizeGroupByPayload<T extends ProductSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductSizeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductSizeGroupByOutputType[P]>
        }
      >
    >


  export type ProductSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    size?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductSize$productArgs<ExtArgs>
    ShopCart?: boolean | ProductSize$ShopCartArgs<ExtArgs>
    _count?: boolean | ProductSizeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSize"]>

  export type ProductSizeSelectScalar = {
    id?: boolean
    productId?: boolean
    size?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductSizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductSize$productArgs<ExtArgs>
    ShopCart?: boolean | ProductSize$ShopCartArgs<ExtArgs>
    _count?: boolean | ProductSizeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProductSizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductSize"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs> | null
      ShopCart: Prisma.$ShopCartPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number | null
      size: $Enums.Size | null
      quantity: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["productSize"]>
    composites: {}
  }


  type ProductSizeGetPayload<S extends boolean | null | undefined | ProductSizeDefaultArgs> = $Result.GetResult<Prisma.$ProductSizePayload, S>

  type ProductSizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductSizeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductSizeCountAggregateInputType | true
    }

  export interface ProductSizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductSize'], meta: { name: 'ProductSize' } }
    /**
     * Find zero or one ProductSize that matches the filter.
     * @param {ProductSizeFindUniqueArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductSizeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductSizeFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProductSize that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductSizeFindUniqueOrThrowArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductSizeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductSizeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProductSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeFindFirstArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductSizeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductSizeFindFirstArgs<ExtArgs>>
    ): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProductSize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeFindFirstOrThrowArgs} args - Arguments to find a ProductSize
     * @example
     * // Get one ProductSize
     * const productSize = await prisma.productSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductSizeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductSizeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProductSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductSizes
     * const productSizes = await prisma.productSize.findMany()
     * 
     * // Get first 10 ProductSizes
     * const productSizes = await prisma.productSize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productSizeWithIdOnly = await prisma.productSize.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductSizeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductSizeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProductSize.
     * @param {ProductSizeCreateArgs} args - Arguments to create a ProductSize.
     * @example
     * // Create one ProductSize
     * const ProductSize = await prisma.productSize.create({
     *   data: {
     *     // ... data to create a ProductSize
     *   }
     * })
     * 
    **/
    create<T extends ProductSizeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductSizeCreateArgs<ExtArgs>>
    ): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ProductSizes.
     *     @param {ProductSizeCreateManyArgs} args - Arguments to create many ProductSizes.
     *     @example
     *     // Create many ProductSizes
     *     const productSize = await prisma.productSize.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductSizeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductSizeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductSize.
     * @param {ProductSizeDeleteArgs} args - Arguments to delete one ProductSize.
     * @example
     * // Delete one ProductSize
     * const ProductSize = await prisma.productSize.delete({
     *   where: {
     *     // ... filter to delete one ProductSize
     *   }
     * })
     * 
    **/
    delete<T extends ProductSizeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductSizeDeleteArgs<ExtArgs>>
    ): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProductSize.
     * @param {ProductSizeUpdateArgs} args - Arguments to update one ProductSize.
     * @example
     * // Update one ProductSize
     * const productSize = await prisma.productSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductSizeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductSizeUpdateArgs<ExtArgs>>
    ): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProductSizes.
     * @param {ProductSizeDeleteManyArgs} args - Arguments to filter ProductSizes to delete.
     * @example
     * // Delete a few ProductSizes
     * const { count } = await prisma.productSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductSizeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductSizeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductSizes
     * const productSize = await prisma.productSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductSizeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductSizeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductSize.
     * @param {ProductSizeUpsertArgs} args - Arguments to update or create a ProductSize.
     * @example
     * // Update or create a ProductSize
     * const productSize = await prisma.productSize.upsert({
     *   create: {
     *     // ... data to create a ProductSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductSize we want to update
     *   }
     * })
    **/
    upsert<T extends ProductSizeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductSizeUpsertArgs<ExtArgs>>
    ): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProductSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeCountArgs} args - Arguments to filter ProductSizes to count.
     * @example
     * // Count the number of ProductSizes
     * const count = await prisma.productSize.count({
     *   where: {
     *     // ... the filter for the ProductSizes we want to count
     *   }
     * })
    **/
    count<T extends ProductSizeCountArgs>(
      args?: Subset<T, ProductSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductSizeAggregateArgs>(args: Subset<T, ProductSizeAggregateArgs>): Prisma.PrismaPromise<GetProductSizeAggregateType<T>>

    /**
     * Group by ProductSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductSizeGroupByArgs['orderBy'] }
        : { orderBy?: ProductSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductSize model
   */
  readonly fields: ProductSizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductSizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends ProductSize$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductSize$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    ShopCart<T extends ProductSize$ShopCartArgs<ExtArgs> = {}>(args?: Subset<T, ProductSize$ShopCartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopCartPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProductSize model
   */ 
  interface ProductSizeFieldRefs {
    readonly id: FieldRef<"ProductSize", 'Int'>
    readonly productId: FieldRef<"ProductSize", 'Int'>
    readonly size: FieldRef<"ProductSize", 'Size'>
    readonly quantity: FieldRef<"ProductSize", 'Int'>
    readonly createdAt: FieldRef<"ProductSize", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductSize", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ProductSize findUnique
   */
  export type ProductSizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where: ProductSizeWhereUniqueInput
  }


  /**
   * ProductSize findUniqueOrThrow
   */
  export type ProductSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where: ProductSizeWhereUniqueInput
  }


  /**
   * ProductSize findFirst
   */
  export type ProductSizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSizes.
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSizes.
     */
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }


  /**
   * ProductSize findFirstOrThrow
   */
  export type ProductSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSize to fetch.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSizes.
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSizes.
     */
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }


  /**
   * ProductSize findMany
   */
  export type ProductSizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter, which ProductSizes to fetch.
     */
    where?: ProductSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSizes to fetch.
     */
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductSizes.
     */
    cursor?: ProductSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSizes.
     */
    skip?: number
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }


  /**
   * ProductSize create
   */
  export type ProductSizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductSize.
     */
    data?: XOR<ProductSizeCreateInput, ProductSizeUncheckedCreateInput>
  }


  /**
   * ProductSize createMany
   */
  export type ProductSizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductSizes.
     */
    data: ProductSizeCreateManyInput | ProductSizeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ProductSize update
   */
  export type ProductSizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductSize.
     */
    data: XOR<ProductSizeUpdateInput, ProductSizeUncheckedUpdateInput>
    /**
     * Choose, which ProductSize to update.
     */
    where: ProductSizeWhereUniqueInput
  }


  /**
   * ProductSize updateMany
   */
  export type ProductSizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductSizes.
     */
    data: XOR<ProductSizeUpdateManyMutationInput, ProductSizeUncheckedUpdateManyInput>
    /**
     * Filter which ProductSizes to update
     */
    where?: ProductSizeWhereInput
  }


  /**
   * ProductSize upsert
   */
  export type ProductSizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductSize to update in case it exists.
     */
    where: ProductSizeWhereUniqueInput
    /**
     * In case the ProductSize found by the `where` argument doesn't exist, create a new ProductSize with this data.
     */
    create: XOR<ProductSizeCreateInput, ProductSizeUncheckedCreateInput>
    /**
     * In case the ProductSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductSizeUpdateInput, ProductSizeUncheckedUpdateInput>
  }


  /**
   * ProductSize delete
   */
  export type ProductSizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSizeInclude<ExtArgs> | null
    /**
     * Filter which ProductSize to delete.
     */
    where: ProductSizeWhereUniqueInput
  }


  /**
   * ProductSize deleteMany
   */
  export type ProductSizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSizes to delete
     */
    where?: ProductSizeWhereInput
  }


  /**
   * ProductSize.product
   */
  export type ProductSize$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }


  /**
   * ProductSize.ShopCart
   */
  export type ProductSize$ShopCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCart
     */
    select?: ShopCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopCartInclude<ExtArgs> | null
    where?: ShopCartWhereInput
    orderBy?: ShopCartOrderByWithRelationInput | ShopCartOrderByWithRelationInput[]
    cursor?: ShopCartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopCartScalarFieldEnum | ShopCartScalarFieldEnum[]
  }


  /**
   * ProductSize without action
   */
  export type ProductSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSizeInclude<ExtArgs> | null
  }



  /**
   * Model ProductImage
   */

  export type AggregateProductImage = {
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  export type ProductImageAvgAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductImageSumAggregateOutputType = {
    id: number | null
    productId: number | null
  }

  export type ProductImageMinAggregateOutputType = {
    id: number | null
    productId: number | null
    image_url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductImageMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    image_url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductImageCountAggregateOutputType = {
    id: number
    productId: number
    image_url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductImageAvgAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductImageSumAggregateInputType = {
    id?: true
    productId?: true
  }

  export type ProductImageMinAggregateInputType = {
    id?: true
    productId?: true
    image_url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductImageMaxAggregateInputType = {
    id?: true
    productId?: true
    image_url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductImageCountAggregateInputType = {
    id?: true
    productId?: true
    image_url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImage to aggregate.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImageMaxAggregateInputType
  }

  export type GetProductImageAggregateType<T extends ProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImage[P]>
      : GetScalarType<T[P], AggregateProductImage[P]>
  }




  export type ProductImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithAggregationInput | ProductImageOrderByWithAggregationInput[]
    by: ProductImageScalarFieldEnum[] | ProductImageScalarFieldEnum
    having?: ProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImageCountAggregateInputType | true
    _avg?: ProductImageAvgAggregateInputType
    _sum?: ProductImageSumAggregateInputType
    _min?: ProductImageMinAggregateInputType
    _max?: ProductImageMaxAggregateInputType
  }

  export type ProductImageGroupByOutputType = {
    id: number
    productId: number | null
    image_url: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  type GetProductImageGroupByPayload<T extends ProductImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
        }
      >
    >


  export type ProductImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    image_url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductImage$productArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectScalar = {
    id?: boolean
    productId?: boolean
    image_url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductImage$productArgs<ExtArgs>
  }


  export type $ProductImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductImage"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number | null
      image_url: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["productImage"]>
    composites: {}
  }


  type ProductImageGetPayload<S extends boolean | null | undefined | ProductImageDefaultArgs> = $Result.GetResult<Prisma.$ProductImagePayload, S>

  type ProductImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductImageCountAggregateInputType | true
    }

  export interface ProductImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductImage'], meta: { name: 'ProductImage' } }
    /**
     * Find zero or one ProductImage that matches the filter.
     * @param {ProductImageFindUniqueArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductImageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductImageFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ProductImage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductImageFindUniqueOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductImageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductImageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductImageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductImageFindFirstArgs<ExtArgs>>
    ): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ProductImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductImageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductImageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImage.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImageWithIdOnly = await prisma.productImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductImageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductImageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ProductImage.
     * @param {ProductImageCreateArgs} args - Arguments to create a ProductImage.
     * @example
     * // Create one ProductImage
     * const ProductImage = await prisma.productImage.create({
     *   data: {
     *     // ... data to create a ProductImage
     *   }
     * })
     * 
    **/
    create<T extends ProductImageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductImageCreateArgs<ExtArgs>>
    ): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ProductImages.
     *     @param {ProductImageCreateManyArgs} args - Arguments to create many ProductImages.
     *     @example
     *     // Create many ProductImages
     *     const productImage = await prisma.productImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductImageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductImageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductImage.
     * @param {ProductImageDeleteArgs} args - Arguments to delete one ProductImage.
     * @example
     * // Delete one ProductImage
     * const ProductImage = await prisma.productImage.delete({
     *   where: {
     *     // ... filter to delete one ProductImage
     *   }
     * })
     * 
    **/
    delete<T extends ProductImageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductImageDeleteArgs<ExtArgs>>
    ): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ProductImage.
     * @param {ProductImageUpdateArgs} args - Arguments to update one ProductImage.
     * @example
     * // Update one ProductImage
     * const productImage = await prisma.productImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductImageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductImageUpdateArgs<ExtArgs>>
    ): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImageDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductImageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductImageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductImageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductImageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductImage.
     * @param {ProductImageUpsertArgs} args - Arguments to update or create a ProductImage.
     * @example
     * // Update or create a ProductImage
     * const productImage = await prisma.productImage.upsert({
     *   create: {
     *     // ... data to create a ProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImage we want to update
     *   }
     * })
    **/
    upsert<T extends ProductImageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductImageUpsertArgs<ExtArgs>>
    ): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImage.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImageCountArgs>(
      args?: Subset<T, ProductImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImageAggregateArgs>(args: Subset<T, ProductImageAggregateArgs>): Prisma.PrismaPromise<GetProductImageAggregateType<T>>

    /**
     * Group by ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageGroupByArgs['orderBy'] }
        : { orderBy?: ProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductImage model
   */
  readonly fields: ProductImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends ProductImage$productArgs<ExtArgs> = {}>(args?: Subset<T, ProductImage$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ProductImage model
   */ 
  interface ProductImageFieldRefs {
    readonly id: FieldRef<"ProductImage", 'Int'>
    readonly productId: FieldRef<"ProductImage", 'Int'>
    readonly image_url: FieldRef<"ProductImage", 'String'>
    readonly createdAt: FieldRef<"ProductImage", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductImage", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ProductImage findUnique
   */
  export type ProductImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage findUniqueOrThrow
   */
  export type ProductImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage findFirst
   */
  export type ProductImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }


  /**
   * ProductImage findFirstOrThrow
   */
  export type ProductImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }


  /**
   * ProductImage findMany
   */
  export type ProductImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }


  /**
   * ProductImage create
   */
  export type ProductImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductImage.
     */
    data?: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
  }


  /**
   * ProductImage createMany
   */
  export type ProductImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ProductImage update
   */
  export type ProductImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductImage.
     */
    data: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
    /**
     * Choose, which ProductImage to update.
     */
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage updateMany
   */
  export type ProductImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
  }


  /**
   * ProductImage upsert
   */
  export type ProductImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductImage to update in case it exists.
     */
    where: ProductImageWhereUniqueInput
    /**
     * In case the ProductImage found by the `where` argument doesn't exist, create a new ProductImage with this data.
     */
    create: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
    /**
     * In case the ProductImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
  }


  /**
   * ProductImage delete
   */
  export type ProductImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter which ProductImage to delete.
     */
    where: ProductImageWhereUniqueInput
  }


  /**
   * ProductImage deleteMany
   */
  export type ProductImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to delete
     */
    where?: ProductImageWhereInput
  }


  /**
   * ProductImage.product
   */
  export type ProductImage$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }


  /**
   * ProductImage without action
   */
  export type ProductImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude<ExtArgs> | null
  }



  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    view: number | null
    brandId: number | null
    originalPrice: number | null
    discountPrice: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    view: number | null
    brandId: number | null
    originalPrice: number | null
    discountPrice: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    contentHTML: string | null
    contentMarkdown: string | null
    status: $Enums.Status | null
    categoryId: number | null
    view: number | null
    material: string | null
    brandId: number | null
    originalPrice: number | null
    discountPrice: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    contentHTML: string | null
    contentMarkdown: string | null
    status: $Enums.Status | null
    categoryId: number | null
    view: number | null
    material: string | null
    brandId: number | null
    originalPrice: number | null
    discountPrice: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    contentHTML: number
    contentMarkdown: number
    status: number
    categoryId: number
    view: number
    material: number
    brandId: number
    originalPrice: number
    discountPrice: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    categoryId?: true
    view?: true
    brandId?: true
    originalPrice?: true
    discountPrice?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    categoryId?: true
    view?: true
    brandId?: true
    originalPrice?: true
    discountPrice?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    contentHTML?: true
    contentMarkdown?: true
    status?: true
    categoryId?: true
    view?: true
    material?: true
    brandId?: true
    originalPrice?: true
    discountPrice?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    contentHTML?: true
    contentMarkdown?: true
    status?: true
    categoryId?: true
    view?: true
    material?: true
    brandId?: true
    originalPrice?: true
    discountPrice?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    contentHTML?: true
    contentMarkdown?: true
    status?: true
    categoryId?: true
    view?: true
    material?: true
    brandId?: true
    originalPrice?: true
    discountPrice?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string | null
    contentHTML: string | null
    contentMarkdown: string | null
    status: $Enums.Status | null
    categoryId: number | null
    view: number | null
    material: string | null
    brandId: number | null
    originalPrice: number | null
    discountPrice: number | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contentHTML?: boolean
    contentMarkdown?: boolean
    status?: boolean
    categoryId?: boolean
    view?: boolean
    material?: boolean
    brandId?: boolean
    originalPrice?: boolean
    discountPrice?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
    brand?: boolean | Product$brandArgs<ExtArgs>
    Comment?: boolean | Product$CommentArgs<ExtArgs>
    OrderDetaill?: boolean | Product$OrderDetaillArgs<ExtArgs>
    ProductSize?: boolean | Product$ProductSizeArgs<ExtArgs>
    ProductImage?: boolean | Product$ProductImageArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    contentHTML?: boolean
    contentMarkdown?: boolean
    status?: boolean
    categoryId?: boolean
    view?: boolean
    material?: boolean
    brandId?: boolean
    originalPrice?: boolean
    discountPrice?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
    brand?: boolean | Product$brandArgs<ExtArgs>
    Comment?: boolean | Product$CommentArgs<ExtArgs>
    OrderDetaill?: boolean | Product$OrderDetaillArgs<ExtArgs>
    ProductSize?: boolean | Product$ProductSizeArgs<ExtArgs>
    ProductImage?: boolean | Product$ProductImageArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs> | null
      brand: Prisma.$BrandPayload<ExtArgs> | null
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      OrderDetaill: Prisma.$OrderDetaillPayload<ExtArgs>[]
      ProductSize: Prisma.$ProductSizePayload<ExtArgs>[]
      ProductImage: Prisma.$ProductImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      contentHTML: string | null
      contentMarkdown: string | null
      status: $Enums.Status | null
      categoryId: number | null
      view: number | null
      material: string | null
      brandId: number | null
      originalPrice: number | null
      discountPrice: number | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }


  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    brand<T extends Product$brandArgs<ExtArgs> = {}>(args?: Subset<T, Product$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Comment<T extends Product$CommentArgs<ExtArgs> = {}>(args?: Subset<T, Product$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    OrderDetaill<T extends Product$OrderDetaillArgs<ExtArgs> = {}>(args?: Subset<T, Product$OrderDetaillArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderDetaillPayload<ExtArgs>, T, 'findMany'> | Null>;

    ProductSize<T extends Product$ProductSizeArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductSizeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, 'findMany'> | Null>;

    ProductImage<T extends Product$ProductImageArgs<ExtArgs> = {}>(args?: Subset<T, Product$ProductImageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly contentHTML: FieldRef<"Product", 'String'>
    readonly contentMarkdown: FieldRef<"Product", 'String'>
    readonly status: FieldRef<"Product", 'Status'>
    readonly categoryId: FieldRef<"Product", 'Int'>
    readonly view: FieldRef<"Product", 'Int'>
    readonly material: FieldRef<"Product", 'String'>
    readonly brandId: FieldRef<"Product", 'Int'>
    readonly originalPrice: FieldRef<"Product", 'Int'>
    readonly discountPrice: FieldRef<"Product", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data?: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }


  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }


  /**
   * Product.brand
   */
  export type Product$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }


  /**
   * Product.Comment
   */
  export type Product$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Product.OrderDetaill
   */
  export type Product$OrderDetaillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderDetaill
     */
    select?: OrderDetaillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderDetaillInclude<ExtArgs> | null
    where?: OrderDetaillWhereInput
    orderBy?: OrderDetaillOrderByWithRelationInput | OrderDetaillOrderByWithRelationInput[]
    cursor?: OrderDetaillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderDetaillScalarFieldEnum | OrderDetaillScalarFieldEnum[]
  }


  /**
   * Product.ProductSize
   */
  export type Product$ProductSizeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSizeInclude<ExtArgs> | null
    where?: ProductSizeWhereInput
    orderBy?: ProductSizeOrderByWithRelationInput | ProductSizeOrderByWithRelationInput[]
    cursor?: ProductSizeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductSizeScalarFieldEnum | ProductSizeScalarFieldEnum[]
  }


  /**
   * Product.ProductImage
   */
  export type Product$ProductImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductImageInclude<ExtArgs> | null
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    cursor?: ProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }


  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
  }



  /**
   * Model RoomMessage
   */

  export type AggregateRoomMessage = {
    _count: RoomMessageCountAggregateOutputType | null
    _avg: RoomMessageAvgAggregateOutputType | null
    _sum: RoomMessageSumAggregateOutputType | null
    _min: RoomMessageMinAggregateOutputType | null
    _max: RoomMessageMaxAggregateOutputType | null
  }

  export type RoomMessageAvgAggregateOutputType = {
    id: number | null
    userOneId: number | null
    userTwoId: number | null
  }

  export type RoomMessageSumAggregateOutputType = {
    id: number | null
    userOneId: number | null
    userTwoId: number | null
  }

  export type RoomMessageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userOneId: number | null
    userTwoId: number | null
  }

  export type RoomMessageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userOneId: number | null
    userTwoId: number | null
  }

  export type RoomMessageCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userOneId: number
    userTwoId: number
    _all: number
  }


  export type RoomMessageAvgAggregateInputType = {
    id?: true
    userOneId?: true
    userTwoId?: true
  }

  export type RoomMessageSumAggregateInputType = {
    id?: true
    userOneId?: true
    userTwoId?: true
  }

  export type RoomMessageMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userOneId?: true
    userTwoId?: true
  }

  export type RoomMessageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userOneId?: true
    userTwoId?: true
  }

  export type RoomMessageCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userOneId?: true
    userTwoId?: true
    _all?: true
  }

  export type RoomMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomMessage to aggregate.
     */
    where?: RoomMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomMessages to fetch.
     */
    orderBy?: RoomMessageOrderByWithRelationInput | RoomMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomMessages
    **/
    _count?: true | RoomMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMessageMaxAggregateInputType
  }

  export type GetRoomMessageAggregateType<T extends RoomMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomMessage[P]>
      : GetScalarType<T[P], AggregateRoomMessage[P]>
  }




  export type RoomMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomMessageWhereInput
    orderBy?: RoomMessageOrderByWithAggregationInput | RoomMessageOrderByWithAggregationInput[]
    by: RoomMessageScalarFieldEnum[] | RoomMessageScalarFieldEnum
    having?: RoomMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomMessageCountAggregateInputType | true
    _avg?: RoomMessageAvgAggregateInputType
    _sum?: RoomMessageSumAggregateInputType
    _min?: RoomMessageMinAggregateInputType
    _max?: RoomMessageMaxAggregateInputType
  }

  export type RoomMessageGroupByOutputType = {
    id: number
    createdAt: Date | null
    updatedAt: Date | null
    userOneId: number | null
    userTwoId: number | null
    _count: RoomMessageCountAggregateOutputType | null
    _avg: RoomMessageAvgAggregateOutputType | null
    _sum: RoomMessageSumAggregateOutputType | null
    _min: RoomMessageMinAggregateOutputType | null
    _max: RoomMessageMaxAggregateOutputType | null
  }

  type GetRoomMessageGroupByPayload<T extends RoomMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomMessageGroupByOutputType[P]>
            : GetScalarType<T[P], RoomMessageGroupByOutputType[P]>
        }
      >
    >


  export type RoomMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userOneId?: boolean
    userTwoId?: boolean
    userOne?: boolean | RoomMessage$userOneArgs<ExtArgs>
    userTwo?: boolean | RoomMessage$userTwoArgs<ExtArgs>
    messages?: boolean | RoomMessage$messagesArgs<ExtArgs>
    _count?: boolean | RoomMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomMessage"]>

  export type RoomMessageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userOneId?: boolean
    userTwoId?: boolean
  }

  export type RoomMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userOne?: boolean | RoomMessage$userOneArgs<ExtArgs>
    userTwo?: boolean | RoomMessage$userTwoArgs<ExtArgs>
    messages?: boolean | RoomMessage$messagesArgs<ExtArgs>
    _count?: boolean | RoomMessageCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RoomMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomMessage"
    objects: {
      userOne: Prisma.$UserPayload<ExtArgs> | null
      userTwo: Prisma.$UserPayload<ExtArgs> | null
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date | null
      updatedAt: Date | null
      userOneId: number | null
      userTwoId: number | null
    }, ExtArgs["result"]["roomMessage"]>
    composites: {}
  }


  type RoomMessageGetPayload<S extends boolean | null | undefined | RoomMessageDefaultArgs> = $Result.GetResult<Prisma.$RoomMessagePayload, S>

  type RoomMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomMessageCountAggregateInputType | true
    }

  export interface RoomMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomMessage'], meta: { name: 'RoomMessage' } }
    /**
     * Find zero or one RoomMessage that matches the filter.
     * @param {RoomMessageFindUniqueArgs} args - Arguments to find a RoomMessage
     * @example
     * // Get one RoomMessage
     * const roomMessage = await prisma.roomMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomMessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomMessageFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomMessageClient<$Result.GetResult<Prisma.$RoomMessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RoomMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomMessageFindUniqueOrThrowArgs} args - Arguments to find a RoomMessage
     * @example
     * // Get one RoomMessage
     * const roomMessage = await prisma.roomMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomMessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomMessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomMessageClient<$Result.GetResult<Prisma.$RoomMessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RoomMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMessageFindFirstArgs} args - Arguments to find a RoomMessage
     * @example
     * // Get one RoomMessage
     * const roomMessage = await prisma.roomMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomMessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomMessageFindFirstArgs<ExtArgs>>
    ): Prisma__RoomMessageClient<$Result.GetResult<Prisma.$RoomMessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RoomMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMessageFindFirstOrThrowArgs} args - Arguments to find a RoomMessage
     * @example
     * // Get one RoomMessage
     * const roomMessage = await prisma.roomMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomMessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomMessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomMessageClient<$Result.GetResult<Prisma.$RoomMessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RoomMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomMessages
     * const roomMessages = await prisma.roomMessage.findMany()
     * 
     * // Get first 10 RoomMessages
     * const roomMessages = await prisma.roomMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomMessageWithIdOnly = await prisma.roomMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomMessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomMessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RoomMessage.
     * @param {RoomMessageCreateArgs} args - Arguments to create a RoomMessage.
     * @example
     * // Create one RoomMessage
     * const RoomMessage = await prisma.roomMessage.create({
     *   data: {
     *     // ... data to create a RoomMessage
     *   }
     * })
     * 
    **/
    create<T extends RoomMessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomMessageCreateArgs<ExtArgs>>
    ): Prisma__RoomMessageClient<$Result.GetResult<Prisma.$RoomMessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RoomMessages.
     *     @param {RoomMessageCreateManyArgs} args - Arguments to create many RoomMessages.
     *     @example
     *     // Create many RoomMessages
     *     const roomMessage = await prisma.roomMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomMessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomMessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoomMessage.
     * @param {RoomMessageDeleteArgs} args - Arguments to delete one RoomMessage.
     * @example
     * // Delete one RoomMessage
     * const RoomMessage = await prisma.roomMessage.delete({
     *   where: {
     *     // ... filter to delete one RoomMessage
     *   }
     * })
     * 
    **/
    delete<T extends RoomMessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomMessageDeleteArgs<ExtArgs>>
    ): Prisma__RoomMessageClient<$Result.GetResult<Prisma.$RoomMessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RoomMessage.
     * @param {RoomMessageUpdateArgs} args - Arguments to update one RoomMessage.
     * @example
     * // Update one RoomMessage
     * const roomMessage = await prisma.roomMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomMessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomMessageUpdateArgs<ExtArgs>>
    ): Prisma__RoomMessageClient<$Result.GetResult<Prisma.$RoomMessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RoomMessages.
     * @param {RoomMessageDeleteManyArgs} args - Arguments to filter RoomMessages to delete.
     * @example
     * // Delete a few RoomMessages
     * const { count } = await prisma.roomMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomMessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomMessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomMessages
     * const roomMessage = await prisma.roomMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomMessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomMessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomMessage.
     * @param {RoomMessageUpsertArgs} args - Arguments to update or create a RoomMessage.
     * @example
     * // Update or create a RoomMessage
     * const roomMessage = await prisma.roomMessage.upsert({
     *   create: {
     *     // ... data to create a RoomMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomMessage we want to update
     *   }
     * })
    **/
    upsert<T extends RoomMessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomMessageUpsertArgs<ExtArgs>>
    ): Prisma__RoomMessageClient<$Result.GetResult<Prisma.$RoomMessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RoomMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMessageCountArgs} args - Arguments to filter RoomMessages to count.
     * @example
     * // Count the number of RoomMessages
     * const count = await prisma.roomMessage.count({
     *   where: {
     *     // ... the filter for the RoomMessages we want to count
     *   }
     * })
    **/
    count<T extends RoomMessageCountArgs>(
      args?: Subset<T, RoomMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomMessageAggregateArgs>(args: Subset<T, RoomMessageAggregateArgs>): Prisma.PrismaPromise<GetRoomMessageAggregateType<T>>

    /**
     * Group by RoomMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomMessageGroupByArgs['orderBy'] }
        : { orderBy?: RoomMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomMessage model
   */
  readonly fields: RoomMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    userOne<T extends RoomMessage$userOneArgs<ExtArgs> = {}>(args?: Subset<T, RoomMessage$userOneArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    userTwo<T extends RoomMessage$userTwoArgs<ExtArgs> = {}>(args?: Subset<T, RoomMessage$userTwoArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    messages<T extends RoomMessage$messagesArgs<ExtArgs> = {}>(args?: Subset<T, RoomMessage$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RoomMessage model
   */ 
  interface RoomMessageFieldRefs {
    readonly id: FieldRef<"RoomMessage", 'Int'>
    readonly createdAt: FieldRef<"RoomMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomMessage", 'DateTime'>
    readonly userOneId: FieldRef<"RoomMessage", 'Int'>
    readonly userTwoId: FieldRef<"RoomMessage", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * RoomMessage findUnique
   */
  export type RoomMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
    /**
     * Filter, which RoomMessage to fetch.
     */
    where: RoomMessageWhereUniqueInput
  }


  /**
   * RoomMessage findUniqueOrThrow
   */
  export type RoomMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
    /**
     * Filter, which RoomMessage to fetch.
     */
    where: RoomMessageWhereUniqueInput
  }


  /**
   * RoomMessage findFirst
   */
  export type RoomMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
    /**
     * Filter, which RoomMessage to fetch.
     */
    where?: RoomMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomMessages to fetch.
     */
    orderBy?: RoomMessageOrderByWithRelationInput | RoomMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomMessages.
     */
    cursor?: RoomMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomMessages.
     */
    distinct?: RoomMessageScalarFieldEnum | RoomMessageScalarFieldEnum[]
  }


  /**
   * RoomMessage findFirstOrThrow
   */
  export type RoomMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
    /**
     * Filter, which RoomMessage to fetch.
     */
    where?: RoomMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomMessages to fetch.
     */
    orderBy?: RoomMessageOrderByWithRelationInput | RoomMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomMessages.
     */
    cursor?: RoomMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomMessages.
     */
    distinct?: RoomMessageScalarFieldEnum | RoomMessageScalarFieldEnum[]
  }


  /**
   * RoomMessage findMany
   */
  export type RoomMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
    /**
     * Filter, which RoomMessages to fetch.
     */
    where?: RoomMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomMessages to fetch.
     */
    orderBy?: RoomMessageOrderByWithRelationInput | RoomMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomMessages.
     */
    cursor?: RoomMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomMessages.
     */
    skip?: number
    distinct?: RoomMessageScalarFieldEnum | RoomMessageScalarFieldEnum[]
  }


  /**
   * RoomMessage create
   */
  export type RoomMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomMessage.
     */
    data?: XOR<RoomMessageCreateInput, RoomMessageUncheckedCreateInput>
  }


  /**
   * RoomMessage createMany
   */
  export type RoomMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomMessages.
     */
    data: RoomMessageCreateManyInput | RoomMessageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RoomMessage update
   */
  export type RoomMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomMessage.
     */
    data: XOR<RoomMessageUpdateInput, RoomMessageUncheckedUpdateInput>
    /**
     * Choose, which RoomMessage to update.
     */
    where: RoomMessageWhereUniqueInput
  }


  /**
   * RoomMessage updateMany
   */
  export type RoomMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomMessages.
     */
    data: XOR<RoomMessageUpdateManyMutationInput, RoomMessageUncheckedUpdateManyInput>
    /**
     * Filter which RoomMessages to update
     */
    where?: RoomMessageWhereInput
  }


  /**
   * RoomMessage upsert
   */
  export type RoomMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomMessage to update in case it exists.
     */
    where: RoomMessageWhereUniqueInput
    /**
     * In case the RoomMessage found by the `where` argument doesn't exist, create a new RoomMessage with this data.
     */
    create: XOR<RoomMessageCreateInput, RoomMessageUncheckedCreateInput>
    /**
     * In case the RoomMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomMessageUpdateInput, RoomMessageUncheckedUpdateInput>
  }


  /**
   * RoomMessage delete
   */
  export type RoomMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
    /**
     * Filter which RoomMessage to delete.
     */
    where: RoomMessageWhereUniqueInput
  }


  /**
   * RoomMessage deleteMany
   */
  export type RoomMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomMessages to delete
     */
    where?: RoomMessageWhereInput
  }


  /**
   * RoomMessage.userOne
   */
  export type RoomMessage$userOneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * RoomMessage.userTwo
   */
  export type RoomMessage$userTwoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * RoomMessage.messages
   */
  export type RoomMessage$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * RoomMessage without action
   */
  export type RoomMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMessage
     */
    select?: RoomMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomMessageInclude<ExtArgs> | null
  }



  /**
   * Model ShopCart
   */

  export type AggregateShopCart = {
    _count: ShopCartCountAggregateOutputType | null
    _avg: ShopCartAvgAggregateOutputType | null
    _sum: ShopCartSumAggregateOutputType | null
    _min: ShopCartMinAggregateOutputType | null
    _max: ShopCartMaxAggregateOutputType | null
  }

  export type ShopCartAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    productSizeId: number | null
    quantity: number | null
  }

  export type ShopCartSumAggregateOutputType = {
    id: number | null
    userId: number | null
    productSizeId: number | null
    quantity: number | null
  }

  export type ShopCartMinAggregateOutputType = {
    id: number | null
    userId: number | null
    productSizeId: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopCartMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    productSizeId: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShopCartCountAggregateOutputType = {
    id: number
    userId: number
    productSizeId: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShopCartAvgAggregateInputType = {
    id?: true
    userId?: true
    productSizeId?: true
    quantity?: true
  }

  export type ShopCartSumAggregateInputType = {
    id?: true
    userId?: true
    productSizeId?: true
    quantity?: true
  }

  export type ShopCartMinAggregateInputType = {
    id?: true
    userId?: true
    productSizeId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopCartMaxAggregateInputType = {
    id?: true
    userId?: true
    productSizeId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShopCartCountAggregateInputType = {
    id?: true
    userId?: true
    productSizeId?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShopCartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopCart to aggregate.
     */
    where?: ShopCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopCarts to fetch.
     */
    orderBy?: ShopCartOrderByWithRelationInput | ShopCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShopCarts
    **/
    _count?: true | ShopCartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopCartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopCartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopCartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopCartMaxAggregateInputType
  }

  export type GetShopCartAggregateType<T extends ShopCartAggregateArgs> = {
        [P in keyof T & keyof AggregateShopCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopCart[P]>
      : GetScalarType<T[P], AggregateShopCart[P]>
  }




  export type ShopCartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopCartWhereInput
    orderBy?: ShopCartOrderByWithAggregationInput | ShopCartOrderByWithAggregationInput[]
    by: ShopCartScalarFieldEnum[] | ShopCartScalarFieldEnum
    having?: ShopCartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopCartCountAggregateInputType | true
    _avg?: ShopCartAvgAggregateInputType
    _sum?: ShopCartSumAggregateInputType
    _min?: ShopCartMinAggregateInputType
    _max?: ShopCartMaxAggregateInputType
  }

  export type ShopCartGroupByOutputType = {
    id: number
    userId: number | null
    productSizeId: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: ShopCartCountAggregateOutputType | null
    _avg: ShopCartAvgAggregateOutputType | null
    _sum: ShopCartSumAggregateOutputType | null
    _min: ShopCartMinAggregateOutputType | null
    _max: ShopCartMaxAggregateOutputType | null
  }

  type GetShopCartGroupByPayload<T extends ShopCartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopCartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopCartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopCartGroupByOutputType[P]>
            : GetScalarType<T[P], ShopCartGroupByOutputType[P]>
        }
      >
    >


  export type ShopCartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productSizeId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | ShopCart$userArgs<ExtArgs>
    productSize?: boolean | ShopCart$productSizeArgs<ExtArgs>
  }, ExtArgs["result"]["shopCart"]>

  export type ShopCartSelectScalar = {
    id?: boolean
    userId?: boolean
    productSizeId?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShopCartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ShopCart$userArgs<ExtArgs>
    productSize?: boolean | ShopCart$productSizeArgs<ExtArgs>
  }


  export type $ShopCartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShopCart"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      productSize: Prisma.$ProductSizePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      productSizeId: number | null
      quantity: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["shopCart"]>
    composites: {}
  }


  type ShopCartGetPayload<S extends boolean | null | undefined | ShopCartDefaultArgs> = $Result.GetResult<Prisma.$ShopCartPayload, S>

  type ShopCartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShopCartFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShopCartCountAggregateInputType | true
    }

  export interface ShopCartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShopCart'], meta: { name: 'ShopCart' } }
    /**
     * Find zero or one ShopCart that matches the filter.
     * @param {ShopCartFindUniqueArgs} args - Arguments to find a ShopCart
     * @example
     * // Get one ShopCart
     * const shopCart = await prisma.shopCart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShopCartFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ShopCartFindUniqueArgs<ExtArgs>>
    ): Prisma__ShopCartClient<$Result.GetResult<Prisma.$ShopCartPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ShopCart that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ShopCartFindUniqueOrThrowArgs} args - Arguments to find a ShopCart
     * @example
     * // Get one ShopCart
     * const shopCart = await prisma.shopCart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShopCartFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopCartFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ShopCartClient<$Result.GetResult<Prisma.$ShopCartPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ShopCart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCartFindFirstArgs} args - Arguments to find a ShopCart
     * @example
     * // Get one ShopCart
     * const shopCart = await prisma.shopCart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShopCartFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopCartFindFirstArgs<ExtArgs>>
    ): Prisma__ShopCartClient<$Result.GetResult<Prisma.$ShopCartPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ShopCart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCartFindFirstOrThrowArgs} args - Arguments to find a ShopCart
     * @example
     * // Get one ShopCart
     * const shopCart = await prisma.shopCart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShopCartFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopCartFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ShopCartClient<$Result.GetResult<Prisma.$ShopCartPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ShopCarts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShopCarts
     * const shopCarts = await prisma.shopCart.findMany()
     * 
     * // Get first 10 ShopCarts
     * const shopCarts = await prisma.shopCart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopCartWithIdOnly = await prisma.shopCart.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShopCartFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopCartFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopCartPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ShopCart.
     * @param {ShopCartCreateArgs} args - Arguments to create a ShopCart.
     * @example
     * // Create one ShopCart
     * const ShopCart = await prisma.shopCart.create({
     *   data: {
     *     // ... data to create a ShopCart
     *   }
     * })
     * 
    **/
    create<T extends ShopCartCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopCartCreateArgs<ExtArgs>>
    ): Prisma__ShopCartClient<$Result.GetResult<Prisma.$ShopCartPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ShopCarts.
     *     @param {ShopCartCreateManyArgs} args - Arguments to create many ShopCarts.
     *     @example
     *     // Create many ShopCarts
     *     const shopCart = await prisma.shopCart.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShopCartCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopCartCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShopCart.
     * @param {ShopCartDeleteArgs} args - Arguments to delete one ShopCart.
     * @example
     * // Delete one ShopCart
     * const ShopCart = await prisma.shopCart.delete({
     *   where: {
     *     // ... filter to delete one ShopCart
     *   }
     * })
     * 
    **/
    delete<T extends ShopCartDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ShopCartDeleteArgs<ExtArgs>>
    ): Prisma__ShopCartClient<$Result.GetResult<Prisma.$ShopCartPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ShopCart.
     * @param {ShopCartUpdateArgs} args - Arguments to update one ShopCart.
     * @example
     * // Update one ShopCart
     * const shopCart = await prisma.shopCart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShopCartUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ShopCartUpdateArgs<ExtArgs>>
    ): Prisma__ShopCartClient<$Result.GetResult<Prisma.$ShopCartPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ShopCarts.
     * @param {ShopCartDeleteManyArgs} args - Arguments to filter ShopCarts to delete.
     * @example
     * // Delete a few ShopCarts
     * const { count } = await prisma.shopCart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShopCartDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ShopCartDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShopCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShopCarts
     * const shopCart = await prisma.shopCart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShopCartUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ShopCartUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShopCart.
     * @param {ShopCartUpsertArgs} args - Arguments to update or create a ShopCart.
     * @example
     * // Update or create a ShopCart
     * const shopCart = await prisma.shopCart.upsert({
     *   create: {
     *     // ... data to create a ShopCart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShopCart we want to update
     *   }
     * })
    **/
    upsert<T extends ShopCartUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ShopCartUpsertArgs<ExtArgs>>
    ): Prisma__ShopCartClient<$Result.GetResult<Prisma.$ShopCartPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ShopCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCartCountArgs} args - Arguments to filter ShopCarts to count.
     * @example
     * // Count the number of ShopCarts
     * const count = await prisma.shopCart.count({
     *   where: {
     *     // ... the filter for the ShopCarts we want to count
     *   }
     * })
    **/
    count<T extends ShopCartCountArgs>(
      args?: Subset<T, ShopCartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopCartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShopCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopCartAggregateArgs>(args: Subset<T, ShopCartAggregateArgs>): Prisma.PrismaPromise<GetShopCartAggregateType<T>>

    /**
     * Group by ShopCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopCartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopCartGroupByArgs['orderBy'] }
        : { orderBy?: ShopCartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopCartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShopCart model
   */
  readonly fields: ShopCartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShopCart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopCartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends ShopCart$userArgs<ExtArgs> = {}>(args?: Subset<T, ShopCart$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    productSize<T extends ShopCart$productSizeArgs<ExtArgs> = {}>(args?: Subset<T, ShopCart$productSizeArgs<ExtArgs>>): Prisma__ProductSizeClient<$Result.GetResult<Prisma.$ProductSizePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ShopCart model
   */ 
  interface ShopCartFieldRefs {
    readonly id: FieldRef<"ShopCart", 'Int'>
    readonly userId: FieldRef<"ShopCart", 'Int'>
    readonly productSizeId: FieldRef<"ShopCart", 'Int'>
    readonly quantity: FieldRef<"ShopCart", 'Int'>
    readonly createdAt: FieldRef<"ShopCart", 'DateTime'>
    readonly updatedAt: FieldRef<"ShopCart", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ShopCart findUnique
   */
  export type ShopCartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCart
     */
    select?: ShopCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopCartInclude<ExtArgs> | null
    /**
     * Filter, which ShopCart to fetch.
     */
    where: ShopCartWhereUniqueInput
  }


  /**
   * ShopCart findUniqueOrThrow
   */
  export type ShopCartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCart
     */
    select?: ShopCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopCartInclude<ExtArgs> | null
    /**
     * Filter, which ShopCart to fetch.
     */
    where: ShopCartWhereUniqueInput
  }


  /**
   * ShopCart findFirst
   */
  export type ShopCartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCart
     */
    select?: ShopCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopCartInclude<ExtArgs> | null
    /**
     * Filter, which ShopCart to fetch.
     */
    where?: ShopCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopCarts to fetch.
     */
    orderBy?: ShopCartOrderByWithRelationInput | ShopCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopCarts.
     */
    cursor?: ShopCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopCarts.
     */
    distinct?: ShopCartScalarFieldEnum | ShopCartScalarFieldEnum[]
  }


  /**
   * ShopCart findFirstOrThrow
   */
  export type ShopCartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCart
     */
    select?: ShopCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopCartInclude<ExtArgs> | null
    /**
     * Filter, which ShopCart to fetch.
     */
    where?: ShopCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopCarts to fetch.
     */
    orderBy?: ShopCartOrderByWithRelationInput | ShopCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShopCarts.
     */
    cursor?: ShopCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShopCarts.
     */
    distinct?: ShopCartScalarFieldEnum | ShopCartScalarFieldEnum[]
  }


  /**
   * ShopCart findMany
   */
  export type ShopCartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCart
     */
    select?: ShopCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopCartInclude<ExtArgs> | null
    /**
     * Filter, which ShopCarts to fetch.
     */
    where?: ShopCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShopCarts to fetch.
     */
    orderBy?: ShopCartOrderByWithRelationInput | ShopCartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShopCarts.
     */
    cursor?: ShopCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShopCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShopCarts.
     */
    skip?: number
    distinct?: ShopCartScalarFieldEnum | ShopCartScalarFieldEnum[]
  }


  /**
   * ShopCart create
   */
  export type ShopCartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCart
     */
    select?: ShopCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopCartInclude<ExtArgs> | null
    /**
     * The data needed to create a ShopCart.
     */
    data?: XOR<ShopCartCreateInput, ShopCartUncheckedCreateInput>
  }


  /**
   * ShopCart createMany
   */
  export type ShopCartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShopCarts.
     */
    data: ShopCartCreateManyInput | ShopCartCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ShopCart update
   */
  export type ShopCartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCart
     */
    select?: ShopCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopCartInclude<ExtArgs> | null
    /**
     * The data needed to update a ShopCart.
     */
    data: XOR<ShopCartUpdateInput, ShopCartUncheckedUpdateInput>
    /**
     * Choose, which ShopCart to update.
     */
    where: ShopCartWhereUniqueInput
  }


  /**
   * ShopCart updateMany
   */
  export type ShopCartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShopCarts.
     */
    data: XOR<ShopCartUpdateManyMutationInput, ShopCartUncheckedUpdateManyInput>
    /**
     * Filter which ShopCarts to update
     */
    where?: ShopCartWhereInput
  }


  /**
   * ShopCart upsert
   */
  export type ShopCartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCart
     */
    select?: ShopCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopCartInclude<ExtArgs> | null
    /**
     * The filter to search for the ShopCart to update in case it exists.
     */
    where: ShopCartWhereUniqueInput
    /**
     * In case the ShopCart found by the `where` argument doesn't exist, create a new ShopCart with this data.
     */
    create: XOR<ShopCartCreateInput, ShopCartUncheckedCreateInput>
    /**
     * In case the ShopCart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopCartUpdateInput, ShopCartUncheckedUpdateInput>
  }


  /**
   * ShopCart delete
   */
  export type ShopCartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCart
     */
    select?: ShopCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopCartInclude<ExtArgs> | null
    /**
     * Filter which ShopCart to delete.
     */
    where: ShopCartWhereUniqueInput
  }


  /**
   * ShopCart deleteMany
   */
  export type ShopCartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShopCarts to delete
     */
    where?: ShopCartWhereInput
  }


  /**
   * ShopCart.user
   */
  export type ShopCart$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * ShopCart.productSize
   */
  export type ShopCart$productSizeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSize
     */
    select?: ProductSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductSizeInclude<ExtArgs> | null
    where?: ProductSizeWhereInput
  }


  /**
   * ShopCart without action
   */
  export type ShopCartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCart
     */
    select?: ShopCartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShopCartInclude<ExtArgs> | null
  }



  /**
   * Model TypeShip
   */

  export type AggregateTypeShip = {
    _count: TypeShipCountAggregateOutputType | null
    _avg: TypeShipAvgAggregateOutputType | null
    _sum: TypeShipSumAggregateOutputType | null
    _min: TypeShipMinAggregateOutputType | null
    _max: TypeShipMaxAggregateOutputType | null
  }

  export type TypeShipAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type TypeShipSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type TypeShipMinAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeShipMaxAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeShipCountAggregateOutputType = {
    id: number
    name: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TypeShipAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type TypeShipSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type TypeShipMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeShipMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeShipCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TypeShipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypeShip to aggregate.
     */
    where?: TypeShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeShips to fetch.
     */
    orderBy?: TypeShipOrderByWithRelationInput | TypeShipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypeShips
    **/
    _count?: true | TypeShipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypeShipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypeShipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeShipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeShipMaxAggregateInputType
  }

  export type GetTypeShipAggregateType<T extends TypeShipAggregateArgs> = {
        [P in keyof T & keyof AggregateTypeShip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypeShip[P]>
      : GetScalarType<T[P], AggregateTypeShip[P]>
  }




  export type TypeShipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeShipWhereInput
    orderBy?: TypeShipOrderByWithAggregationInput | TypeShipOrderByWithAggregationInput[]
    by: TypeShipScalarFieldEnum[] | TypeShipScalarFieldEnum
    having?: TypeShipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeShipCountAggregateInputType | true
    _avg?: TypeShipAvgAggregateInputType
    _sum?: TypeShipSumAggregateInputType
    _min?: TypeShipMinAggregateInputType
    _max?: TypeShipMaxAggregateInputType
  }

  export type TypeShipGroupByOutputType = {
    id: number
    name: string
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: TypeShipCountAggregateOutputType | null
    _avg: TypeShipAvgAggregateOutputType | null
    _sum: TypeShipSumAggregateOutputType | null
    _min: TypeShipMinAggregateOutputType | null
    _max: TypeShipMaxAggregateOutputType | null
  }

  type GetTypeShipGroupByPayload<T extends TypeShipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypeShipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeShipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeShipGroupByOutputType[P]>
            : GetScalarType<T[P], TypeShipGroupByOutputType[P]>
        }
      >
    >


  export type TypeShipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    OrderProduct?: boolean | TypeShip$OrderProductArgs<ExtArgs>
    _count?: boolean | TypeShipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["typeShip"]>

  export type TypeShipSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TypeShipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrderProduct?: boolean | TypeShip$OrderProductArgs<ExtArgs>
    _count?: boolean | TypeShipCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TypeShipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TypeShip"
    objects: {
      OrderProduct: Prisma.$OrderProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      price: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["typeShip"]>
    composites: {}
  }


  type TypeShipGetPayload<S extends boolean | null | undefined | TypeShipDefaultArgs> = $Result.GetResult<Prisma.$TypeShipPayload, S>

  type TypeShipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TypeShipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TypeShipCountAggregateInputType | true
    }

  export interface TypeShipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TypeShip'], meta: { name: 'TypeShip' } }
    /**
     * Find zero or one TypeShip that matches the filter.
     * @param {TypeShipFindUniqueArgs} args - Arguments to find a TypeShip
     * @example
     * // Get one TypeShip
     * const typeShip = await prisma.typeShip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TypeShipFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TypeShipFindUniqueArgs<ExtArgs>>
    ): Prisma__TypeShipClient<$Result.GetResult<Prisma.$TypeShipPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TypeShip that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TypeShipFindUniqueOrThrowArgs} args - Arguments to find a TypeShip
     * @example
     * // Get one TypeShip
     * const typeShip = await prisma.typeShip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TypeShipFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TypeShipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TypeShipClient<$Result.GetResult<Prisma.$TypeShipPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TypeShip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeShipFindFirstArgs} args - Arguments to find a TypeShip
     * @example
     * // Get one TypeShip
     * const typeShip = await prisma.typeShip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TypeShipFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TypeShipFindFirstArgs<ExtArgs>>
    ): Prisma__TypeShipClient<$Result.GetResult<Prisma.$TypeShipPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TypeShip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeShipFindFirstOrThrowArgs} args - Arguments to find a TypeShip
     * @example
     * // Get one TypeShip
     * const typeShip = await prisma.typeShip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TypeShipFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TypeShipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TypeShipClient<$Result.GetResult<Prisma.$TypeShipPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TypeShips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeShipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypeShips
     * const typeShips = await prisma.typeShip.findMany()
     * 
     * // Get first 10 TypeShips
     * const typeShips = await prisma.typeShip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeShipWithIdOnly = await prisma.typeShip.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TypeShipFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypeShipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeShipPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TypeShip.
     * @param {TypeShipCreateArgs} args - Arguments to create a TypeShip.
     * @example
     * // Create one TypeShip
     * const TypeShip = await prisma.typeShip.create({
     *   data: {
     *     // ... data to create a TypeShip
     *   }
     * })
     * 
    **/
    create<T extends TypeShipCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TypeShipCreateArgs<ExtArgs>>
    ): Prisma__TypeShipClient<$Result.GetResult<Prisma.$TypeShipPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TypeShips.
     *     @param {TypeShipCreateManyArgs} args - Arguments to create many TypeShips.
     *     @example
     *     // Create many TypeShips
     *     const typeShip = await prisma.typeShip.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TypeShipCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypeShipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TypeShip.
     * @param {TypeShipDeleteArgs} args - Arguments to delete one TypeShip.
     * @example
     * // Delete one TypeShip
     * const TypeShip = await prisma.typeShip.delete({
     *   where: {
     *     // ... filter to delete one TypeShip
     *   }
     * })
     * 
    **/
    delete<T extends TypeShipDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TypeShipDeleteArgs<ExtArgs>>
    ): Prisma__TypeShipClient<$Result.GetResult<Prisma.$TypeShipPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TypeShip.
     * @param {TypeShipUpdateArgs} args - Arguments to update one TypeShip.
     * @example
     * // Update one TypeShip
     * const typeShip = await prisma.typeShip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TypeShipUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TypeShipUpdateArgs<ExtArgs>>
    ): Prisma__TypeShipClient<$Result.GetResult<Prisma.$TypeShipPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TypeShips.
     * @param {TypeShipDeleteManyArgs} args - Arguments to filter TypeShips to delete.
     * @example
     * // Delete a few TypeShips
     * const { count } = await prisma.typeShip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TypeShipDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypeShipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypeShips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeShipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypeShips
     * const typeShip = await prisma.typeShip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TypeShipUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TypeShipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypeShip.
     * @param {TypeShipUpsertArgs} args - Arguments to update or create a TypeShip.
     * @example
     * // Update or create a TypeShip
     * const typeShip = await prisma.typeShip.upsert({
     *   create: {
     *     // ... data to create a TypeShip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypeShip we want to update
     *   }
     * })
    **/
    upsert<T extends TypeShipUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TypeShipUpsertArgs<ExtArgs>>
    ): Prisma__TypeShipClient<$Result.GetResult<Prisma.$TypeShipPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TypeShips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeShipCountArgs} args - Arguments to filter TypeShips to count.
     * @example
     * // Count the number of TypeShips
     * const count = await prisma.typeShip.count({
     *   where: {
     *     // ... the filter for the TypeShips we want to count
     *   }
     * })
    **/
    count<T extends TypeShipCountArgs>(
      args?: Subset<T, TypeShipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeShipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypeShip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeShipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeShipAggregateArgs>(args: Subset<T, TypeShipAggregateArgs>): Prisma.PrismaPromise<GetTypeShipAggregateType<T>>

    /**
     * Group by TypeShip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeShipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeShipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeShipGroupByArgs['orderBy'] }
        : { orderBy?: TypeShipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeShipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeShipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TypeShip model
   */
  readonly fields: TypeShipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TypeShip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypeShipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    OrderProduct<T extends TypeShip$OrderProductArgs<ExtArgs> = {}>(args?: Subset<T, TypeShip$OrderProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TypeShip model
   */ 
  interface TypeShipFieldRefs {
    readonly id: FieldRef<"TypeShip", 'Int'>
    readonly name: FieldRef<"TypeShip", 'String'>
    readonly price: FieldRef<"TypeShip", 'Int'>
    readonly createdAt: FieldRef<"TypeShip", 'DateTime'>
    readonly updatedAt: FieldRef<"TypeShip", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TypeShip findUnique
   */
  export type TypeShipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeShip
     */
    select?: TypeShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeShipInclude<ExtArgs> | null
    /**
     * Filter, which TypeShip to fetch.
     */
    where: TypeShipWhereUniqueInput
  }


  /**
   * TypeShip findUniqueOrThrow
   */
  export type TypeShipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeShip
     */
    select?: TypeShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeShipInclude<ExtArgs> | null
    /**
     * Filter, which TypeShip to fetch.
     */
    where: TypeShipWhereUniqueInput
  }


  /**
   * TypeShip findFirst
   */
  export type TypeShipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeShip
     */
    select?: TypeShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeShipInclude<ExtArgs> | null
    /**
     * Filter, which TypeShip to fetch.
     */
    where?: TypeShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeShips to fetch.
     */
    orderBy?: TypeShipOrderByWithRelationInput | TypeShipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeShips.
     */
    cursor?: TypeShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeShips.
     */
    distinct?: TypeShipScalarFieldEnum | TypeShipScalarFieldEnum[]
  }


  /**
   * TypeShip findFirstOrThrow
   */
  export type TypeShipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeShip
     */
    select?: TypeShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeShipInclude<ExtArgs> | null
    /**
     * Filter, which TypeShip to fetch.
     */
    where?: TypeShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeShips to fetch.
     */
    orderBy?: TypeShipOrderByWithRelationInput | TypeShipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeShips.
     */
    cursor?: TypeShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeShips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeShips.
     */
    distinct?: TypeShipScalarFieldEnum | TypeShipScalarFieldEnum[]
  }


  /**
   * TypeShip findMany
   */
  export type TypeShipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeShip
     */
    select?: TypeShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeShipInclude<ExtArgs> | null
    /**
     * Filter, which TypeShips to fetch.
     */
    where?: TypeShipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeShips to fetch.
     */
    orderBy?: TypeShipOrderByWithRelationInput | TypeShipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypeShips.
     */
    cursor?: TypeShipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeShips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeShips.
     */
    skip?: number
    distinct?: TypeShipScalarFieldEnum | TypeShipScalarFieldEnum[]
  }


  /**
   * TypeShip create
   */
  export type TypeShipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeShip
     */
    select?: TypeShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeShipInclude<ExtArgs> | null
    /**
     * The data needed to create a TypeShip.
     */
    data: XOR<TypeShipCreateInput, TypeShipUncheckedCreateInput>
  }


  /**
   * TypeShip createMany
   */
  export type TypeShipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TypeShips.
     */
    data: TypeShipCreateManyInput | TypeShipCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TypeShip update
   */
  export type TypeShipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeShip
     */
    select?: TypeShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeShipInclude<ExtArgs> | null
    /**
     * The data needed to update a TypeShip.
     */
    data: XOR<TypeShipUpdateInput, TypeShipUncheckedUpdateInput>
    /**
     * Choose, which TypeShip to update.
     */
    where: TypeShipWhereUniqueInput
  }


  /**
   * TypeShip updateMany
   */
  export type TypeShipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TypeShips.
     */
    data: XOR<TypeShipUpdateManyMutationInput, TypeShipUncheckedUpdateManyInput>
    /**
     * Filter which TypeShips to update
     */
    where?: TypeShipWhereInput
  }


  /**
   * TypeShip upsert
   */
  export type TypeShipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeShip
     */
    select?: TypeShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeShipInclude<ExtArgs> | null
    /**
     * The filter to search for the TypeShip to update in case it exists.
     */
    where: TypeShipWhereUniqueInput
    /**
     * In case the TypeShip found by the `where` argument doesn't exist, create a new TypeShip with this data.
     */
    create: XOR<TypeShipCreateInput, TypeShipUncheckedCreateInput>
    /**
     * In case the TypeShip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeShipUpdateInput, TypeShipUncheckedUpdateInput>
  }


  /**
   * TypeShip delete
   */
  export type TypeShipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeShip
     */
    select?: TypeShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeShipInclude<ExtArgs> | null
    /**
     * Filter which TypeShip to delete.
     */
    where: TypeShipWhereUniqueInput
  }


  /**
   * TypeShip deleteMany
   */
  export type TypeShipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypeShips to delete
     */
    where?: TypeShipWhereInput
  }


  /**
   * TypeShip.OrderProduct
   */
  export type TypeShip$OrderProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    where?: OrderProductWhereInput
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    cursor?: OrderProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }


  /**
   * TypeShip without action
   */
  export type TypeShipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeShip
     */
    select?: TypeShipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeShipInclude<ExtArgs> | null
  }



  /**
   * Model TypeVoucher
   */

  export type AggregateTypeVoucher = {
    _count: TypeVoucherCountAggregateOutputType | null
    _avg: TypeVoucherAvgAggregateOutputType | null
    _sum: TypeVoucherSumAggregateOutputType | null
    _min: TypeVoucherMinAggregateOutputType | null
    _max: TypeVoucherMaxAggregateOutputType | null
  }

  export type TypeVoucherAvgAggregateOutputType = {
    id: number | null
    value: number | null
    maxValue: number | null
    minValue: number | null
  }

  export type TypeVoucherSumAggregateOutputType = {
    id: number | null
    value: number | null
    maxValue: number | null
    minValue: number | null
  }

  export type TypeVoucherMinAggregateOutputType = {
    id: number | null
    typeVoucher: $Enums.Discount | null
    value: number | null
    maxValue: number | null
    minValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeVoucherMaxAggregateOutputType = {
    id: number | null
    typeVoucher: $Enums.Discount | null
    value: number | null
    maxValue: number | null
    minValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeVoucherCountAggregateOutputType = {
    id: number
    typeVoucher: number
    value: number
    maxValue: number
    minValue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TypeVoucherAvgAggregateInputType = {
    id?: true
    value?: true
    maxValue?: true
    minValue?: true
  }

  export type TypeVoucherSumAggregateInputType = {
    id?: true
    value?: true
    maxValue?: true
    minValue?: true
  }

  export type TypeVoucherMinAggregateInputType = {
    id?: true
    typeVoucher?: true
    value?: true
    maxValue?: true
    minValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeVoucherMaxAggregateInputType = {
    id?: true
    typeVoucher?: true
    value?: true
    maxValue?: true
    minValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeVoucherCountAggregateInputType = {
    id?: true
    typeVoucher?: true
    value?: true
    maxValue?: true
    minValue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TypeVoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypeVoucher to aggregate.
     */
    where?: TypeVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeVouchers to fetch.
     */
    orderBy?: TypeVoucherOrderByWithRelationInput | TypeVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypeVouchers
    **/
    _count?: true | TypeVoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypeVoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypeVoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeVoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeVoucherMaxAggregateInputType
  }

  export type GetTypeVoucherAggregateType<T extends TypeVoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateTypeVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypeVoucher[P]>
      : GetScalarType<T[P], AggregateTypeVoucher[P]>
  }




  export type TypeVoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeVoucherWhereInput
    orderBy?: TypeVoucherOrderByWithAggregationInput | TypeVoucherOrderByWithAggregationInput[]
    by: TypeVoucherScalarFieldEnum[] | TypeVoucherScalarFieldEnum
    having?: TypeVoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeVoucherCountAggregateInputType | true
    _avg?: TypeVoucherAvgAggregateInputType
    _sum?: TypeVoucherSumAggregateInputType
    _min?: TypeVoucherMinAggregateInputType
    _max?: TypeVoucherMaxAggregateInputType
  }

  export type TypeVoucherGroupByOutputType = {
    id: number
    typeVoucher: $Enums.Discount | null
    value: number | null
    maxValue: number | null
    minValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: TypeVoucherCountAggregateOutputType | null
    _avg: TypeVoucherAvgAggregateOutputType | null
    _sum: TypeVoucherSumAggregateOutputType | null
    _min: TypeVoucherMinAggregateOutputType | null
    _max: TypeVoucherMaxAggregateOutputType | null
  }

  type GetTypeVoucherGroupByPayload<T extends TypeVoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypeVoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeVoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeVoucherGroupByOutputType[P]>
            : GetScalarType<T[P], TypeVoucherGroupByOutputType[P]>
        }
      >
    >


  export type TypeVoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeVoucher?: boolean
    value?: boolean
    maxValue?: boolean
    minValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Voucher?: boolean | TypeVoucher$VoucherArgs<ExtArgs>
    _count?: boolean | TypeVoucherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["typeVoucher"]>

  export type TypeVoucherSelectScalar = {
    id?: boolean
    typeVoucher?: boolean
    value?: boolean
    maxValue?: boolean
    minValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TypeVoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Voucher?: boolean | TypeVoucher$VoucherArgs<ExtArgs>
    _count?: boolean | TypeVoucherCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TypeVoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TypeVoucher"
    objects: {
      Voucher: Prisma.$VoucherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      typeVoucher: $Enums.Discount | null
      value: number | null
      maxValue: number | null
      minValue: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["typeVoucher"]>
    composites: {}
  }


  type TypeVoucherGetPayload<S extends boolean | null | undefined | TypeVoucherDefaultArgs> = $Result.GetResult<Prisma.$TypeVoucherPayload, S>

  type TypeVoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TypeVoucherFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TypeVoucherCountAggregateInputType | true
    }

  export interface TypeVoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TypeVoucher'], meta: { name: 'TypeVoucher' } }
    /**
     * Find zero or one TypeVoucher that matches the filter.
     * @param {TypeVoucherFindUniqueArgs} args - Arguments to find a TypeVoucher
     * @example
     * // Get one TypeVoucher
     * const typeVoucher = await prisma.typeVoucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TypeVoucherFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TypeVoucherFindUniqueArgs<ExtArgs>>
    ): Prisma__TypeVoucherClient<$Result.GetResult<Prisma.$TypeVoucherPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TypeVoucher that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TypeVoucherFindUniqueOrThrowArgs} args - Arguments to find a TypeVoucher
     * @example
     * // Get one TypeVoucher
     * const typeVoucher = await prisma.typeVoucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TypeVoucherFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TypeVoucherFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TypeVoucherClient<$Result.GetResult<Prisma.$TypeVoucherPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TypeVoucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeVoucherFindFirstArgs} args - Arguments to find a TypeVoucher
     * @example
     * // Get one TypeVoucher
     * const typeVoucher = await prisma.typeVoucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TypeVoucherFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TypeVoucherFindFirstArgs<ExtArgs>>
    ): Prisma__TypeVoucherClient<$Result.GetResult<Prisma.$TypeVoucherPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TypeVoucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeVoucherFindFirstOrThrowArgs} args - Arguments to find a TypeVoucher
     * @example
     * // Get one TypeVoucher
     * const typeVoucher = await prisma.typeVoucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TypeVoucherFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TypeVoucherFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TypeVoucherClient<$Result.GetResult<Prisma.$TypeVoucherPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TypeVouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeVoucherFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypeVouchers
     * const typeVouchers = await prisma.typeVoucher.findMany()
     * 
     * // Get first 10 TypeVouchers
     * const typeVouchers = await prisma.typeVoucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeVoucherWithIdOnly = await prisma.typeVoucher.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TypeVoucherFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypeVoucherFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeVoucherPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TypeVoucher.
     * @param {TypeVoucherCreateArgs} args - Arguments to create a TypeVoucher.
     * @example
     * // Create one TypeVoucher
     * const TypeVoucher = await prisma.typeVoucher.create({
     *   data: {
     *     // ... data to create a TypeVoucher
     *   }
     * })
     * 
    **/
    create<T extends TypeVoucherCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TypeVoucherCreateArgs<ExtArgs>>
    ): Prisma__TypeVoucherClient<$Result.GetResult<Prisma.$TypeVoucherPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TypeVouchers.
     *     @param {TypeVoucherCreateManyArgs} args - Arguments to create many TypeVouchers.
     *     @example
     *     // Create many TypeVouchers
     *     const typeVoucher = await prisma.typeVoucher.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TypeVoucherCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypeVoucherCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TypeVoucher.
     * @param {TypeVoucherDeleteArgs} args - Arguments to delete one TypeVoucher.
     * @example
     * // Delete one TypeVoucher
     * const TypeVoucher = await prisma.typeVoucher.delete({
     *   where: {
     *     // ... filter to delete one TypeVoucher
     *   }
     * })
     * 
    **/
    delete<T extends TypeVoucherDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TypeVoucherDeleteArgs<ExtArgs>>
    ): Prisma__TypeVoucherClient<$Result.GetResult<Prisma.$TypeVoucherPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TypeVoucher.
     * @param {TypeVoucherUpdateArgs} args - Arguments to update one TypeVoucher.
     * @example
     * // Update one TypeVoucher
     * const typeVoucher = await prisma.typeVoucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TypeVoucherUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TypeVoucherUpdateArgs<ExtArgs>>
    ): Prisma__TypeVoucherClient<$Result.GetResult<Prisma.$TypeVoucherPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TypeVouchers.
     * @param {TypeVoucherDeleteManyArgs} args - Arguments to filter TypeVouchers to delete.
     * @example
     * // Delete a few TypeVouchers
     * const { count } = await prisma.typeVoucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TypeVoucherDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypeVoucherDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypeVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeVoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypeVouchers
     * const typeVoucher = await prisma.typeVoucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TypeVoucherUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TypeVoucherUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypeVoucher.
     * @param {TypeVoucherUpsertArgs} args - Arguments to update or create a TypeVoucher.
     * @example
     * // Update or create a TypeVoucher
     * const typeVoucher = await prisma.typeVoucher.upsert({
     *   create: {
     *     // ... data to create a TypeVoucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypeVoucher we want to update
     *   }
     * })
    **/
    upsert<T extends TypeVoucherUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TypeVoucherUpsertArgs<ExtArgs>>
    ): Prisma__TypeVoucherClient<$Result.GetResult<Prisma.$TypeVoucherPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TypeVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeVoucherCountArgs} args - Arguments to filter TypeVouchers to count.
     * @example
     * // Count the number of TypeVouchers
     * const count = await prisma.typeVoucher.count({
     *   where: {
     *     // ... the filter for the TypeVouchers we want to count
     *   }
     * })
    **/
    count<T extends TypeVoucherCountArgs>(
      args?: Subset<T, TypeVoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeVoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypeVoucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeVoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeVoucherAggregateArgs>(args: Subset<T, TypeVoucherAggregateArgs>): Prisma.PrismaPromise<GetTypeVoucherAggregateType<T>>

    /**
     * Group by TypeVoucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeVoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeVoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeVoucherGroupByArgs['orderBy'] }
        : { orderBy?: TypeVoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeVoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TypeVoucher model
   */
  readonly fields: TypeVoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TypeVoucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypeVoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Voucher<T extends TypeVoucher$VoucherArgs<ExtArgs> = {}>(args?: Subset<T, TypeVoucher$VoucherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TypeVoucher model
   */ 
  interface TypeVoucherFieldRefs {
    readonly id: FieldRef<"TypeVoucher", 'Int'>
    readonly typeVoucher: FieldRef<"TypeVoucher", 'Discount'>
    readonly value: FieldRef<"TypeVoucher", 'Int'>
    readonly maxValue: FieldRef<"TypeVoucher", 'Int'>
    readonly minValue: FieldRef<"TypeVoucher", 'Int'>
    readonly createdAt: FieldRef<"TypeVoucher", 'DateTime'>
    readonly updatedAt: FieldRef<"TypeVoucher", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TypeVoucher findUnique
   */
  export type TypeVoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeVoucher
     */
    select?: TypeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which TypeVoucher to fetch.
     */
    where: TypeVoucherWhereUniqueInput
  }


  /**
   * TypeVoucher findUniqueOrThrow
   */
  export type TypeVoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeVoucher
     */
    select?: TypeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which TypeVoucher to fetch.
     */
    where: TypeVoucherWhereUniqueInput
  }


  /**
   * TypeVoucher findFirst
   */
  export type TypeVoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeVoucher
     */
    select?: TypeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which TypeVoucher to fetch.
     */
    where?: TypeVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeVouchers to fetch.
     */
    orderBy?: TypeVoucherOrderByWithRelationInput | TypeVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeVouchers.
     */
    cursor?: TypeVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeVouchers.
     */
    distinct?: TypeVoucherScalarFieldEnum | TypeVoucherScalarFieldEnum[]
  }


  /**
   * TypeVoucher findFirstOrThrow
   */
  export type TypeVoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeVoucher
     */
    select?: TypeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which TypeVoucher to fetch.
     */
    where?: TypeVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeVouchers to fetch.
     */
    orderBy?: TypeVoucherOrderByWithRelationInput | TypeVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeVouchers.
     */
    cursor?: TypeVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeVouchers.
     */
    distinct?: TypeVoucherScalarFieldEnum | TypeVoucherScalarFieldEnum[]
  }


  /**
   * TypeVoucher findMany
   */
  export type TypeVoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeVoucher
     */
    select?: TypeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeVoucherInclude<ExtArgs> | null
    /**
     * Filter, which TypeVouchers to fetch.
     */
    where?: TypeVoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeVouchers to fetch.
     */
    orderBy?: TypeVoucherOrderByWithRelationInput | TypeVoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypeVouchers.
     */
    cursor?: TypeVoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeVouchers.
     */
    skip?: number
    distinct?: TypeVoucherScalarFieldEnum | TypeVoucherScalarFieldEnum[]
  }


  /**
   * TypeVoucher create
   */
  export type TypeVoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeVoucher
     */
    select?: TypeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeVoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a TypeVoucher.
     */
    data?: XOR<TypeVoucherCreateInput, TypeVoucherUncheckedCreateInput>
  }


  /**
   * TypeVoucher createMany
   */
  export type TypeVoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TypeVouchers.
     */
    data: TypeVoucherCreateManyInput | TypeVoucherCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TypeVoucher update
   */
  export type TypeVoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeVoucher
     */
    select?: TypeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeVoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a TypeVoucher.
     */
    data: XOR<TypeVoucherUpdateInput, TypeVoucherUncheckedUpdateInput>
    /**
     * Choose, which TypeVoucher to update.
     */
    where: TypeVoucherWhereUniqueInput
  }


  /**
   * TypeVoucher updateMany
   */
  export type TypeVoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TypeVouchers.
     */
    data: XOR<TypeVoucherUpdateManyMutationInput, TypeVoucherUncheckedUpdateManyInput>
    /**
     * Filter which TypeVouchers to update
     */
    where?: TypeVoucherWhereInput
  }


  /**
   * TypeVoucher upsert
   */
  export type TypeVoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeVoucher
     */
    select?: TypeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeVoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the TypeVoucher to update in case it exists.
     */
    where: TypeVoucherWhereUniqueInput
    /**
     * In case the TypeVoucher found by the `where` argument doesn't exist, create a new TypeVoucher with this data.
     */
    create: XOR<TypeVoucherCreateInput, TypeVoucherUncheckedCreateInput>
    /**
     * In case the TypeVoucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeVoucherUpdateInput, TypeVoucherUncheckedUpdateInput>
  }


  /**
   * TypeVoucher delete
   */
  export type TypeVoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeVoucher
     */
    select?: TypeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeVoucherInclude<ExtArgs> | null
    /**
     * Filter which TypeVoucher to delete.
     */
    where: TypeVoucherWhereUniqueInput
  }


  /**
   * TypeVoucher deleteMany
   */
  export type TypeVoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypeVouchers to delete
     */
    where?: TypeVoucherWhereInput
  }


  /**
   * TypeVoucher.Voucher
   */
  export type TypeVoucher$VoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    cursor?: VoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }


  /**
   * TypeVoucher without action
   */
  export type TypeVoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeVoucher
     */
    select?: TypeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeVoucherInclude<ExtArgs> | null
  }



  /**
   * Model Voucher
   */

  export type AggregateVoucher = {
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  export type VoucherAvgAggregateOutputType = {
    id: number | null
    typeVoucherId: number | null
    amount: number | null
  }

  export type VoucherSumAggregateOutputType = {
    id: number | null
    typeVoucherId: number | null
    amount: number | null
  }

  export type VoucherMinAggregateOutputType = {
    id: number | null
    fromDate: Date | null
    toDate: Date | null
    typeVoucherId: number | null
    amount: number | null
    codeVoucher: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherMaxAggregateOutputType = {
    id: number | null
    fromDate: Date | null
    toDate: Date | null
    typeVoucherId: number | null
    amount: number | null
    codeVoucher: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherCountAggregateOutputType = {
    id: number
    fromDate: number
    toDate: number
    typeVoucherId: number
    amount: number
    codeVoucher: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoucherAvgAggregateInputType = {
    id?: true
    typeVoucherId?: true
    amount?: true
  }

  export type VoucherSumAggregateInputType = {
    id?: true
    typeVoucherId?: true
    amount?: true
  }

  export type VoucherMinAggregateInputType = {
    id?: true
    fromDate?: true
    toDate?: true
    typeVoucherId?: true
    amount?: true
    codeVoucher?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherMaxAggregateInputType = {
    id?: true
    fromDate?: true
    toDate?: true
    typeVoucherId?: true
    amount?: true
    codeVoucher?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherCountAggregateInputType = {
    id?: true
    fromDate?: true
    toDate?: true
    typeVoucherId?: true
    amount?: true
    codeVoucher?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Voucher to aggregate.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vouchers
    **/
    _count?: true | VoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherMaxAggregateInputType
  }

  export type GetVoucherAggregateType<T extends VoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucher[P]>
      : GetScalarType<T[P], AggregateVoucher[P]>
  }




  export type VoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithAggregationInput | VoucherOrderByWithAggregationInput[]
    by: VoucherScalarFieldEnum[] | VoucherScalarFieldEnum
    having?: VoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherCountAggregateInputType | true
    _avg?: VoucherAvgAggregateInputType
    _sum?: VoucherSumAggregateInputType
    _min?: VoucherMinAggregateInputType
    _max?: VoucherMaxAggregateInputType
  }

  export type VoucherGroupByOutputType = {
    id: number
    fromDate: Date | null
    toDate: Date | null
    typeVoucherId: number | null
    amount: number | null
    codeVoucher: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  type GetVoucherGroupByPayload<T extends VoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherGroupByOutputType[P]>
        }
      >
    >


  export type VoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromDate?: boolean
    toDate?: boolean
    typeVoucherId?: boolean
    amount?: boolean
    codeVoucher?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    typeVoucher?: boolean | Voucher$typeVoucherArgs<ExtArgs>
    OrderProduct?: boolean | Voucher$OrderProductArgs<ExtArgs>
    VoucherUsed?: boolean | Voucher$VoucherUsedArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectScalar = {
    id?: boolean
    fromDate?: boolean
    toDate?: boolean
    typeVoucherId?: boolean
    amount?: boolean
    codeVoucher?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    typeVoucher?: boolean | Voucher$typeVoucherArgs<ExtArgs>
    OrderProduct?: boolean | Voucher$OrderProductArgs<ExtArgs>
    VoucherUsed?: boolean | Voucher$VoucherUsedArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $VoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Voucher"
    objects: {
      typeVoucher: Prisma.$TypeVoucherPayload<ExtArgs> | null
      OrderProduct: Prisma.$OrderProductPayload<ExtArgs>[]
      VoucherUsed: Prisma.$VoucherUsedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fromDate: Date | null
      toDate: Date | null
      typeVoucherId: number | null
      amount: number | null
      codeVoucher: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["voucher"]>
    composites: {}
  }


  type VoucherGetPayload<S extends boolean | null | undefined | VoucherDefaultArgs> = $Result.GetResult<Prisma.$VoucherPayload, S>

  type VoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VoucherFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VoucherCountAggregateInputType | true
    }

  export interface VoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Voucher'], meta: { name: 'Voucher' } }
    /**
     * Find zero or one Voucher that matches the filter.
     * @param {VoucherFindUniqueArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VoucherFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VoucherFindUniqueArgs<ExtArgs>>
    ): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Voucher that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VoucherFindUniqueOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VoucherFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VoucherFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Voucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VoucherFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VoucherFindFirstArgs<ExtArgs>>
    ): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Voucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VoucherFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VoucherFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Vouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vouchers
     * const vouchers = await prisma.voucher.findMany()
     * 
     * // Get first 10 Vouchers
     * const vouchers = await prisma.voucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherWithIdOnly = await prisma.voucher.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VoucherFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VoucherFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Voucher.
     * @param {VoucherCreateArgs} args - Arguments to create a Voucher.
     * @example
     * // Create one Voucher
     * const Voucher = await prisma.voucher.create({
     *   data: {
     *     // ... data to create a Voucher
     *   }
     * })
     * 
    **/
    create<T extends VoucherCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VoucherCreateArgs<ExtArgs>>
    ): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Vouchers.
     *     @param {VoucherCreateManyArgs} args - Arguments to create many Vouchers.
     *     @example
     *     // Create many Vouchers
     *     const voucher = await prisma.voucher.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VoucherCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VoucherCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Voucher.
     * @param {VoucherDeleteArgs} args - Arguments to delete one Voucher.
     * @example
     * // Delete one Voucher
     * const Voucher = await prisma.voucher.delete({
     *   where: {
     *     // ... filter to delete one Voucher
     *   }
     * })
     * 
    **/
    delete<T extends VoucherDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VoucherDeleteArgs<ExtArgs>>
    ): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Voucher.
     * @param {VoucherUpdateArgs} args - Arguments to update one Voucher.
     * @example
     * // Update one Voucher
     * const voucher = await prisma.voucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VoucherUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VoucherUpdateArgs<ExtArgs>>
    ): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Vouchers.
     * @param {VoucherDeleteManyArgs} args - Arguments to filter Vouchers to delete.
     * @example
     * // Delete a few Vouchers
     * const { count } = await prisma.voucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VoucherDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VoucherDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VoucherUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VoucherUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Voucher.
     * @param {VoucherUpsertArgs} args - Arguments to update or create a Voucher.
     * @example
     * // Update or create a Voucher
     * const voucher = await prisma.voucher.upsert({
     *   create: {
     *     // ... data to create a Voucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voucher we want to update
     *   }
     * })
    **/
    upsert<T extends VoucherUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VoucherUpsertArgs<ExtArgs>>
    ): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherCountArgs} args - Arguments to filter Vouchers to count.
     * @example
     * // Count the number of Vouchers
     * const count = await prisma.voucher.count({
     *   where: {
     *     // ... the filter for the Vouchers we want to count
     *   }
     * })
    **/
    count<T extends VoucherCountArgs>(
      args?: Subset<T, VoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherAggregateArgs>(args: Subset<T, VoucherAggregateArgs>): Prisma.PrismaPromise<GetVoucherAggregateType<T>>

    /**
     * Group by Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherGroupByArgs['orderBy'] }
        : { orderBy?: VoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Voucher model
   */
  readonly fields: VoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Voucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    typeVoucher<T extends Voucher$typeVoucherArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$typeVoucherArgs<ExtArgs>>): Prisma__TypeVoucherClient<$Result.GetResult<Prisma.$TypeVoucherPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    OrderProduct<T extends Voucher$OrderProductArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$OrderProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    VoucherUsed<T extends Voucher$VoucherUsedArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$VoucherUsedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsedPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Voucher model
   */ 
  interface VoucherFieldRefs {
    readonly id: FieldRef<"Voucher", 'Int'>
    readonly fromDate: FieldRef<"Voucher", 'DateTime'>
    readonly toDate: FieldRef<"Voucher", 'DateTime'>
    readonly typeVoucherId: FieldRef<"Voucher", 'Int'>
    readonly amount: FieldRef<"Voucher", 'Int'>
    readonly codeVoucher: FieldRef<"Voucher", 'String'>
    readonly createdAt: FieldRef<"Voucher", 'DateTime'>
    readonly updatedAt: FieldRef<"Voucher", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Voucher findUnique
   */
  export type VoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }


  /**
   * Voucher findUniqueOrThrow
   */
  export type VoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }


  /**
   * Voucher findFirst
   */
  export type VoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }


  /**
   * Voucher findFirstOrThrow
   */
  export type VoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }


  /**
   * Voucher findMany
   */
  export type VoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Vouchers to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }


  /**
   * Voucher create
   */
  export type VoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a Voucher.
     */
    data?: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
  }


  /**
   * Voucher createMany
   */
  export type VoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Voucher update
   */
  export type VoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a Voucher.
     */
    data: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
    /**
     * Choose, which Voucher to update.
     */
    where: VoucherWhereUniqueInput
  }


  /**
   * Voucher updateMany
   */
  export type VoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
  }


  /**
   * Voucher upsert
   */
  export type VoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the Voucher to update in case it exists.
     */
    where: VoucherWhereUniqueInput
    /**
     * In case the Voucher found by the `where` argument doesn't exist, create a new Voucher with this data.
     */
    create: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
    /**
     * In case the Voucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
  }


  /**
   * Voucher delete
   */
  export type VoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter which Voucher to delete.
     */
    where: VoucherWhereUniqueInput
  }


  /**
   * Voucher deleteMany
   */
  export type VoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vouchers to delete
     */
    where?: VoucherWhereInput
  }


  /**
   * Voucher.typeVoucher
   */
  export type Voucher$typeVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeVoucher
     */
    select?: TypeVoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeVoucherInclude<ExtArgs> | null
    where?: TypeVoucherWhereInput
  }


  /**
   * Voucher.OrderProduct
   */
  export type Voucher$OrderProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderProductInclude<ExtArgs> | null
    where?: OrderProductWhereInput
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    cursor?: OrderProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }


  /**
   * Voucher.VoucherUsed
   */
  export type Voucher$VoucherUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsed
     */
    select?: VoucherUsedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherUsedInclude<ExtArgs> | null
    where?: VoucherUsedWhereInput
    orderBy?: VoucherUsedOrderByWithRelationInput | VoucherUsedOrderByWithRelationInput[]
    cursor?: VoucherUsedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherUsedScalarFieldEnum | VoucherUsedScalarFieldEnum[]
  }


  /**
   * Voucher without action
   */
  export type VoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
  }



  /**
   * Model VoucherUsed
   */

  export type AggregateVoucherUsed = {
    _count: VoucherUsedCountAggregateOutputType | null
    _avg: VoucherUsedAvgAggregateOutputType | null
    _sum: VoucherUsedSumAggregateOutputType | null
    _min: VoucherUsedMinAggregateOutputType | null
    _max: VoucherUsedMaxAggregateOutputType | null
  }

  export type VoucherUsedAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    voucherId: number | null
  }

  export type VoucherUsedSumAggregateOutputType = {
    id: number | null
    userId: number | null
    voucherId: number | null
  }

  export type VoucherUsedMinAggregateOutputType = {
    id: number | null
    userId: number | null
    voucherId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherUsedMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    voucherId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherUsedCountAggregateOutputType = {
    id: number
    userId: number
    voucherId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoucherUsedAvgAggregateInputType = {
    id?: true
    userId?: true
    voucherId?: true
  }

  export type VoucherUsedSumAggregateInputType = {
    id?: true
    userId?: true
    voucherId?: true
  }

  export type VoucherUsedMinAggregateInputType = {
    id?: true
    userId?: true
    voucherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherUsedMaxAggregateInputType = {
    id?: true
    userId?: true
    voucherId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherUsedCountAggregateInputType = {
    id?: true
    userId?: true
    voucherId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoucherUsedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherUsed to aggregate.
     */
    where?: VoucherUsedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUseds to fetch.
     */
    orderBy?: VoucherUsedOrderByWithRelationInput | VoucherUsedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherUsedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUseds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoucherUseds
    **/
    _count?: true | VoucherUsedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherUsedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherUsedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherUsedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherUsedMaxAggregateInputType
  }

  export type GetVoucherUsedAggregateType<T extends VoucherUsedAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucherUsed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucherUsed[P]>
      : GetScalarType<T[P], AggregateVoucherUsed[P]>
  }




  export type VoucherUsedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsedWhereInput
    orderBy?: VoucherUsedOrderByWithAggregationInput | VoucherUsedOrderByWithAggregationInput[]
    by: VoucherUsedScalarFieldEnum[] | VoucherUsedScalarFieldEnum
    having?: VoucherUsedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherUsedCountAggregateInputType | true
    _avg?: VoucherUsedAvgAggregateInputType
    _sum?: VoucherUsedSumAggregateInputType
    _min?: VoucherUsedMinAggregateInputType
    _max?: VoucherUsedMaxAggregateInputType
  }

  export type VoucherUsedGroupByOutputType = {
    id: number
    userId: number | null
    voucherId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: VoucherUsedCountAggregateOutputType | null
    _avg: VoucherUsedAvgAggregateOutputType | null
    _sum: VoucherUsedSumAggregateOutputType | null
    _min: VoucherUsedMinAggregateOutputType | null
    _max: VoucherUsedMaxAggregateOutputType | null
  }

  type GetVoucherUsedGroupByPayload<T extends VoucherUsedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherUsedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherUsedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherUsedGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherUsedGroupByOutputType[P]>
        }
      >
    >


  export type VoucherUsedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    voucherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | VoucherUsed$userArgs<ExtArgs>
    voucher?: boolean | VoucherUsed$voucherArgs<ExtArgs>
  }, ExtArgs["result"]["voucherUsed"]>

  export type VoucherUsedSelectScalar = {
    id?: boolean
    userId?: boolean
    voucherId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoucherUsedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | VoucherUsed$userArgs<ExtArgs>
    voucher?: boolean | VoucherUsed$voucherArgs<ExtArgs>
  }


  export type $VoucherUsedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoucherUsed"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      voucher: Prisma.$VoucherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      voucherId: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["voucherUsed"]>
    composites: {}
  }


  type VoucherUsedGetPayload<S extends boolean | null | undefined | VoucherUsedDefaultArgs> = $Result.GetResult<Prisma.$VoucherUsedPayload, S>

  type VoucherUsedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VoucherUsedFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VoucherUsedCountAggregateInputType | true
    }

  export interface VoucherUsedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoucherUsed'], meta: { name: 'VoucherUsed' } }
    /**
     * Find zero or one VoucherUsed that matches the filter.
     * @param {VoucherUsedFindUniqueArgs} args - Arguments to find a VoucherUsed
     * @example
     * // Get one VoucherUsed
     * const voucherUsed = await prisma.voucherUsed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VoucherUsedFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VoucherUsedFindUniqueArgs<ExtArgs>>
    ): Prisma__VoucherUsedClient<$Result.GetResult<Prisma.$VoucherUsedPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one VoucherUsed that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VoucherUsedFindUniqueOrThrowArgs} args - Arguments to find a VoucherUsed
     * @example
     * // Get one VoucherUsed
     * const voucherUsed = await prisma.voucherUsed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VoucherUsedFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VoucherUsedFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VoucherUsedClient<$Result.GetResult<Prisma.$VoucherUsedPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first VoucherUsed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsedFindFirstArgs} args - Arguments to find a VoucherUsed
     * @example
     * // Get one VoucherUsed
     * const voucherUsed = await prisma.voucherUsed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VoucherUsedFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VoucherUsedFindFirstArgs<ExtArgs>>
    ): Prisma__VoucherUsedClient<$Result.GetResult<Prisma.$VoucherUsedPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first VoucherUsed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsedFindFirstOrThrowArgs} args - Arguments to find a VoucherUsed
     * @example
     * // Get one VoucherUsed
     * const voucherUsed = await prisma.voucherUsed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VoucherUsedFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VoucherUsedFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VoucherUsedClient<$Result.GetResult<Prisma.$VoucherUsedPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more VoucherUseds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoucherUseds
     * const voucherUseds = await prisma.voucherUsed.findMany()
     * 
     * // Get first 10 VoucherUseds
     * const voucherUseds = await prisma.voucherUsed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherUsedWithIdOnly = await prisma.voucherUsed.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VoucherUsedFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VoucherUsedFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsedPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a VoucherUsed.
     * @param {VoucherUsedCreateArgs} args - Arguments to create a VoucherUsed.
     * @example
     * // Create one VoucherUsed
     * const VoucherUsed = await prisma.voucherUsed.create({
     *   data: {
     *     // ... data to create a VoucherUsed
     *   }
     * })
     * 
    **/
    create<T extends VoucherUsedCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VoucherUsedCreateArgs<ExtArgs>>
    ): Prisma__VoucherUsedClient<$Result.GetResult<Prisma.$VoucherUsedPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many VoucherUseds.
     *     @param {VoucherUsedCreateManyArgs} args - Arguments to create many VoucherUseds.
     *     @example
     *     // Create many VoucherUseds
     *     const voucherUsed = await prisma.voucherUsed.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VoucherUsedCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VoucherUsedCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VoucherUsed.
     * @param {VoucherUsedDeleteArgs} args - Arguments to delete one VoucherUsed.
     * @example
     * // Delete one VoucherUsed
     * const VoucherUsed = await prisma.voucherUsed.delete({
     *   where: {
     *     // ... filter to delete one VoucherUsed
     *   }
     * })
     * 
    **/
    delete<T extends VoucherUsedDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VoucherUsedDeleteArgs<ExtArgs>>
    ): Prisma__VoucherUsedClient<$Result.GetResult<Prisma.$VoucherUsedPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one VoucherUsed.
     * @param {VoucherUsedUpdateArgs} args - Arguments to update one VoucherUsed.
     * @example
     * // Update one VoucherUsed
     * const voucherUsed = await prisma.voucherUsed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VoucherUsedUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VoucherUsedUpdateArgs<ExtArgs>>
    ): Prisma__VoucherUsedClient<$Result.GetResult<Prisma.$VoucherUsedPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more VoucherUseds.
     * @param {VoucherUsedDeleteManyArgs} args - Arguments to filter VoucherUseds to delete.
     * @example
     * // Delete a few VoucherUseds
     * const { count } = await prisma.voucherUsed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VoucherUsedDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VoucherUsedDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherUseds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoucherUseds
     * const voucherUsed = await prisma.voucherUsed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VoucherUsedUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VoucherUsedUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VoucherUsed.
     * @param {VoucherUsedUpsertArgs} args - Arguments to update or create a VoucherUsed.
     * @example
     * // Update or create a VoucherUsed
     * const voucherUsed = await prisma.voucherUsed.upsert({
     *   create: {
     *     // ... data to create a VoucherUsed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoucherUsed we want to update
     *   }
     * })
    **/
    upsert<T extends VoucherUsedUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VoucherUsedUpsertArgs<ExtArgs>>
    ): Prisma__VoucherUsedClient<$Result.GetResult<Prisma.$VoucherUsedPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of VoucherUseds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsedCountArgs} args - Arguments to filter VoucherUseds to count.
     * @example
     * // Count the number of VoucherUseds
     * const count = await prisma.voucherUsed.count({
     *   where: {
     *     // ... the filter for the VoucherUseds we want to count
     *   }
     * })
    **/
    count<T extends VoucherUsedCountArgs>(
      args?: Subset<T, VoucherUsedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherUsedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoucherUsed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherUsedAggregateArgs>(args: Subset<T, VoucherUsedAggregateArgs>): Prisma.PrismaPromise<GetVoucherUsedAggregateType<T>>

    /**
     * Group by VoucherUsed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherUsedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherUsedGroupByArgs['orderBy'] }
        : { orderBy?: VoucherUsedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherUsedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherUsedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoucherUsed model
   */
  readonly fields: VoucherUsedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoucherUsed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherUsedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends VoucherUsed$userArgs<ExtArgs> = {}>(args?: Subset<T, VoucherUsed$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    voucher<T extends VoucherUsed$voucherArgs<ExtArgs> = {}>(args?: Subset<T, VoucherUsed$voucherArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the VoucherUsed model
   */ 
  interface VoucherUsedFieldRefs {
    readonly id: FieldRef<"VoucherUsed", 'Int'>
    readonly userId: FieldRef<"VoucherUsed", 'Int'>
    readonly voucherId: FieldRef<"VoucherUsed", 'Int'>
    readonly createdAt: FieldRef<"VoucherUsed", 'DateTime'>
    readonly updatedAt: FieldRef<"VoucherUsed", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * VoucherUsed findUnique
   */
  export type VoucherUsedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsed
     */
    select?: VoucherUsedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherUsedInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsed to fetch.
     */
    where: VoucherUsedWhereUniqueInput
  }


  /**
   * VoucherUsed findUniqueOrThrow
   */
  export type VoucherUsedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsed
     */
    select?: VoucherUsedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherUsedInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsed to fetch.
     */
    where: VoucherUsedWhereUniqueInput
  }


  /**
   * VoucherUsed findFirst
   */
  export type VoucherUsedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsed
     */
    select?: VoucherUsedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherUsedInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsed to fetch.
     */
    where?: VoucherUsedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUseds to fetch.
     */
    orderBy?: VoucherUsedOrderByWithRelationInput | VoucherUsedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherUseds.
     */
    cursor?: VoucherUsedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUseds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherUseds.
     */
    distinct?: VoucherUsedScalarFieldEnum | VoucherUsedScalarFieldEnum[]
  }


  /**
   * VoucherUsed findFirstOrThrow
   */
  export type VoucherUsedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsed
     */
    select?: VoucherUsedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherUsedInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsed to fetch.
     */
    where?: VoucherUsedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUseds to fetch.
     */
    orderBy?: VoucherUsedOrderByWithRelationInput | VoucherUsedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherUseds.
     */
    cursor?: VoucherUsedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUseds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherUseds.
     */
    distinct?: VoucherUsedScalarFieldEnum | VoucherUsedScalarFieldEnum[]
  }


  /**
   * VoucherUsed findMany
   */
  export type VoucherUsedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsed
     */
    select?: VoucherUsedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherUsedInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUseds to fetch.
     */
    where?: VoucherUsedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUseds to fetch.
     */
    orderBy?: VoucherUsedOrderByWithRelationInput | VoucherUsedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoucherUseds.
     */
    cursor?: VoucherUsedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUseds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUseds.
     */
    skip?: number
    distinct?: VoucherUsedScalarFieldEnum | VoucherUsedScalarFieldEnum[]
  }


  /**
   * VoucherUsed create
   */
  export type VoucherUsedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsed
     */
    select?: VoucherUsedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherUsedInclude<ExtArgs> | null
    /**
     * The data needed to create a VoucherUsed.
     */
    data?: XOR<VoucherUsedCreateInput, VoucherUsedUncheckedCreateInput>
  }


  /**
   * VoucherUsed createMany
   */
  export type VoucherUsedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoucherUseds.
     */
    data: VoucherUsedCreateManyInput | VoucherUsedCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * VoucherUsed update
   */
  export type VoucherUsedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsed
     */
    select?: VoucherUsedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherUsedInclude<ExtArgs> | null
    /**
     * The data needed to update a VoucherUsed.
     */
    data: XOR<VoucherUsedUpdateInput, VoucherUsedUncheckedUpdateInput>
    /**
     * Choose, which VoucherUsed to update.
     */
    where: VoucherUsedWhereUniqueInput
  }


  /**
   * VoucherUsed updateMany
   */
  export type VoucherUsedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoucherUseds.
     */
    data: XOR<VoucherUsedUpdateManyMutationInput, VoucherUsedUncheckedUpdateManyInput>
    /**
     * Filter which VoucherUseds to update
     */
    where?: VoucherUsedWhereInput
  }


  /**
   * VoucherUsed upsert
   */
  export type VoucherUsedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsed
     */
    select?: VoucherUsedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherUsedInclude<ExtArgs> | null
    /**
     * The filter to search for the VoucherUsed to update in case it exists.
     */
    where: VoucherUsedWhereUniqueInput
    /**
     * In case the VoucherUsed found by the `where` argument doesn't exist, create a new VoucherUsed with this data.
     */
    create: XOR<VoucherUsedCreateInput, VoucherUsedUncheckedCreateInput>
    /**
     * In case the VoucherUsed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUsedUpdateInput, VoucherUsedUncheckedUpdateInput>
  }


  /**
   * VoucherUsed delete
   */
  export type VoucherUsedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsed
     */
    select?: VoucherUsedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherUsedInclude<ExtArgs> | null
    /**
     * Filter which VoucherUsed to delete.
     */
    where: VoucherUsedWhereUniqueInput
  }


  /**
   * VoucherUsed deleteMany
   */
  export type VoucherUsedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherUseds to delete
     */
    where?: VoucherUsedWhereInput
  }


  /**
   * VoucherUsed.user
   */
  export type VoucherUsed$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * VoucherUsed.voucher
   */
  export type VoucherUsed$voucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
  }


  /**
   * VoucherUsed without action
   */
  export type VoucherUsedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsed
     */
    select?: VoucherUsedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: VoucherUsedInclude<ExtArgs> | null
  }



  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    id: number | null
  }

  export type SupplierSumAggregateOutputType = {
    id: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    phoneNumber: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    phoneNumber: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phoneNumber: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    id?: true
  }

  export type SupplierSumAggregateInputType = {
    id?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phoneNumber?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phoneNumber?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phoneNumber?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: number
    name: string | null
    address: string | null
    phoneNumber: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phoneNumber?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phoneNumber?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      address: string | null
      phoneNumber: string | null
      email: string | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }


  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SupplierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SupplierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SupplierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends SupplierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Suppliers.
     *     @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     *     @example
     *     // Create many Suppliers
     *     const supplier = await prisma.supplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SupplierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends SupplierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SupplierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SupplierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SupplierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends SupplierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'Int'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly phoneNumber: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
    readonly updatedAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data?: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }


  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }


  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }


  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }


  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
  }



  /**
   * Model Receipt
   */

  export type AggregateReceipt = {
    _count: ReceiptCountAggregateOutputType | null
    _avg: ReceiptAvgAggregateOutputType | null
    _sum: ReceiptSumAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  export type ReceiptAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    supplierId: number | null
  }

  export type ReceiptSumAggregateOutputType = {
    id: number | null
    userId: number | null
    supplierId: number | null
  }

  export type ReceiptMinAggregateOutputType = {
    id: number | null
    userId: number | null
    supplierId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceiptMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    supplierId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceiptCountAggregateOutputType = {
    id: number
    userId: number
    supplierId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReceiptAvgAggregateInputType = {
    id?: true
    userId?: true
    supplierId?: true
  }

  export type ReceiptSumAggregateInputType = {
    id?: true
    userId?: true
    supplierId?: true
  }

  export type ReceiptMinAggregateInputType = {
    id?: true
    userId?: true
    supplierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceiptMaxAggregateInputType = {
    id?: true
    userId?: true
    supplierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceiptCountAggregateInputType = {
    id?: true
    userId?: true
    supplierId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receipt to aggregate.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receipts
    **/
    _count?: true | ReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceiptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceiptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptMaxAggregateInputType
  }

  export type GetReceiptAggregateType<T extends ReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceipt[P]>
      : GetScalarType<T[P], AggregateReceipt[P]>
  }




  export type ReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptWhereInput
    orderBy?: ReceiptOrderByWithAggregationInput | ReceiptOrderByWithAggregationInput[]
    by: ReceiptScalarFieldEnum[] | ReceiptScalarFieldEnum
    having?: ReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptCountAggregateInputType | true
    _avg?: ReceiptAvgAggregateInputType
    _sum?: ReceiptSumAggregateInputType
    _min?: ReceiptMinAggregateInputType
    _max?: ReceiptMaxAggregateInputType
  }

  export type ReceiptGroupByOutputType = {
    id: number
    userId: number | null
    supplierId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: ReceiptCountAggregateOutputType | null
    _avg: ReceiptAvgAggregateOutputType | null
    _sum: ReceiptSumAggregateOutputType | null
    _min: ReceiptMinAggregateOutputType | null
    _max: ReceiptMaxAggregateOutputType | null
  }

  type GetReceiptGroupByPayload<T extends ReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptGroupByOutputType[P]>
        }
      >
    >


  export type ReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    supplierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Receipt$userArgs<ExtArgs>
  }, ExtArgs["result"]["receipt"]>

  export type ReceiptSelectScalar = {
    id?: boolean
    userId?: boolean
    supplierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Receipt$userArgs<ExtArgs>
  }


  export type $ReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Receipt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      supplierId: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["receipt"]>
    composites: {}
  }


  type ReceiptGetPayload<S extends boolean | null | undefined | ReceiptDefaultArgs> = $Result.GetResult<Prisma.$ReceiptPayload, S>

  type ReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReceiptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReceiptCountAggregateInputType | true
    }

  export interface ReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Receipt'], meta: { name: 'Receipt' } }
    /**
     * Find zero or one Receipt that matches the filter.
     * @param {ReceiptFindUniqueArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReceiptFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReceiptFindUniqueArgs<ExtArgs>>
    ): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Receipt that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReceiptFindUniqueOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReceiptFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceiptFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Receipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReceiptFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceiptFindFirstArgs<ExtArgs>>
    ): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Receipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindFirstOrThrowArgs} args - Arguments to find a Receipt
     * @example
     * // Get one Receipt
     * const receipt = await prisma.receipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReceiptFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceiptFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Receipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receipts
     * const receipts = await prisma.receipt.findMany()
     * 
     * // Get first 10 Receipts
     * const receipts = await prisma.receipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptWithIdOnly = await prisma.receipt.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReceiptFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceiptFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Receipt.
     * @param {ReceiptCreateArgs} args - Arguments to create a Receipt.
     * @example
     * // Create one Receipt
     * const Receipt = await prisma.receipt.create({
     *   data: {
     *     // ... data to create a Receipt
     *   }
     * })
     * 
    **/
    create<T extends ReceiptCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReceiptCreateArgs<ExtArgs>>
    ): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Receipts.
     *     @param {ReceiptCreateManyArgs} args - Arguments to create many Receipts.
     *     @example
     *     // Create many Receipts
     *     const receipt = await prisma.receipt.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReceiptCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceiptCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Receipt.
     * @param {ReceiptDeleteArgs} args - Arguments to delete one Receipt.
     * @example
     * // Delete one Receipt
     * const Receipt = await prisma.receipt.delete({
     *   where: {
     *     // ... filter to delete one Receipt
     *   }
     * })
     * 
    **/
    delete<T extends ReceiptDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReceiptDeleteArgs<ExtArgs>>
    ): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Receipt.
     * @param {ReceiptUpdateArgs} args - Arguments to update one Receipt.
     * @example
     * // Update one Receipt
     * const receipt = await prisma.receipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReceiptUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReceiptUpdateArgs<ExtArgs>>
    ): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Receipts.
     * @param {ReceiptDeleteManyArgs} args - Arguments to filter Receipts to delete.
     * @example
     * // Delete a few Receipts
     * const { count } = await prisma.receipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReceiptDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceiptDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receipts
     * const receipt = await prisma.receipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReceiptUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReceiptUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Receipt.
     * @param {ReceiptUpsertArgs} args - Arguments to update or create a Receipt.
     * @example
     * // Update or create a Receipt
     * const receipt = await prisma.receipt.upsert({
     *   create: {
     *     // ... data to create a Receipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receipt we want to update
     *   }
     * })
    **/
    upsert<T extends ReceiptUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReceiptUpsertArgs<ExtArgs>>
    ): Prisma__ReceiptClient<$Result.GetResult<Prisma.$ReceiptPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Receipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptCountArgs} args - Arguments to filter Receipts to count.
     * @example
     * // Count the number of Receipts
     * const count = await prisma.receipt.count({
     *   where: {
     *     // ... the filter for the Receipts we want to count
     *   }
     * })
    **/
    count<T extends ReceiptCountArgs>(
      args?: Subset<T, ReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptAggregateArgs>(args: Subset<T, ReceiptAggregateArgs>): Prisma.PrismaPromise<GetReceiptAggregateType<T>>

    /**
     * Group by Receipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiptGroupByArgs['orderBy'] }
        : { orderBy?: ReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Receipt model
   */
  readonly fields: ReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Receipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends Receipt$userArgs<ExtArgs> = {}>(args?: Subset<T, Receipt$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Receipt model
   */ 
  interface ReceiptFieldRefs {
    readonly id: FieldRef<"Receipt", 'Int'>
    readonly userId: FieldRef<"Receipt", 'Int'>
    readonly supplierId: FieldRef<"Receipt", 'Int'>
    readonly createdAt: FieldRef<"Receipt", 'DateTime'>
    readonly updatedAt: FieldRef<"Receipt", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Receipt findUnique
   */
  export type ReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }


  /**
   * Receipt findUniqueOrThrow
   */
  export type ReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where: ReceiptWhereUniqueInput
  }


  /**
   * Receipt findFirst
   */
  export type ReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }


  /**
   * Receipt findFirstOrThrow
   */
  export type ReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipt to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receipts.
     */
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }


  /**
   * Receipt findMany
   */
  export type ReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter, which Receipts to fetch.
     */
    where?: ReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receipts to fetch.
     */
    orderBy?: ReceiptOrderByWithRelationInput | ReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receipts.
     */
    cursor?: ReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receipts.
     */
    skip?: number
    distinct?: ReceiptScalarFieldEnum | ReceiptScalarFieldEnum[]
  }


  /**
   * Receipt create
   */
  export type ReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a Receipt.
     */
    data?: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
  }


  /**
   * Receipt createMany
   */
  export type ReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Receipts.
     */
    data: ReceiptCreateManyInput | ReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Receipt update
   */
  export type ReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a Receipt.
     */
    data: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
    /**
     * Choose, which Receipt to update.
     */
    where: ReceiptWhereUniqueInput
  }


  /**
   * Receipt updateMany
   */
  export type ReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Receipts.
     */
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyInput>
    /**
     * Filter which Receipts to update
     */
    where?: ReceiptWhereInput
  }


  /**
   * Receipt upsert
   */
  export type ReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the Receipt to update in case it exists.
     */
    where: ReceiptWhereUniqueInput
    /**
     * In case the Receipt found by the `where` argument doesn't exist, create a new Receipt with this data.
     */
    create: XOR<ReceiptCreateInput, ReceiptUncheckedCreateInput>
    /**
     * In case the Receipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceiptUpdateInput, ReceiptUncheckedUpdateInput>
  }


  /**
   * Receipt delete
   */
  export type ReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude<ExtArgs> | null
    /**
     * Filter which Receipt to delete.
     */
    where: ReceiptWhereUniqueInput
  }


  /**
   * Receipt deleteMany
   */
  export type ReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receipts to delete
     */
    where?: ReceiptWhereInput
  }


  /**
   * Receipt.user
   */
  export type Receipt$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Receipt without action
   */
  export type ReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receipt
     */
    select?: ReceiptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiptInclude<ExtArgs> | null
  }



  /**
   * Model ReceiptDetail
   */

  export type AggregateReceiptDetail = {
    _count: ReceiptDetailCountAggregateOutputType | null
    _avg: ReceiptDetailAvgAggregateOutputType | null
    _sum: ReceiptDetailSumAggregateOutputType | null
    _min: ReceiptDetailMinAggregateOutputType | null
    _max: ReceiptDetailMaxAggregateOutputType | null
  }

  export type ReceiptDetailAvgAggregateOutputType = {
    id: number | null
    receiptId: number | null
    productDetailSizeId: number | null
    quantity: number | null
    price: number | null
  }

  export type ReceiptDetailSumAggregateOutputType = {
    id: number | null
    receiptId: number | null
    productDetailSizeId: number | null
    quantity: number | null
    price: number | null
  }

  export type ReceiptDetailMinAggregateOutputType = {
    id: number | null
    receiptId: number | null
    productDetailSizeId: number | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceiptDetailMaxAggregateOutputType = {
    id: number | null
    receiptId: number | null
    productDetailSizeId: number | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceiptDetailCountAggregateOutputType = {
    id: number
    receiptId: number
    productDetailSizeId: number
    quantity: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReceiptDetailAvgAggregateInputType = {
    id?: true
    receiptId?: true
    productDetailSizeId?: true
    quantity?: true
    price?: true
  }

  export type ReceiptDetailSumAggregateInputType = {
    id?: true
    receiptId?: true
    productDetailSizeId?: true
    quantity?: true
    price?: true
  }

  export type ReceiptDetailMinAggregateInputType = {
    id?: true
    receiptId?: true
    productDetailSizeId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceiptDetailMaxAggregateInputType = {
    id?: true
    receiptId?: true
    productDetailSizeId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceiptDetailCountAggregateInputType = {
    id?: true
    receiptId?: true
    productDetailSizeId?: true
    quantity?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReceiptDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceiptDetail to aggregate.
     */
    where?: ReceiptDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptDetails to fetch.
     */
    orderBy?: ReceiptDetailOrderByWithRelationInput | ReceiptDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceiptDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReceiptDetails
    **/
    _count?: true | ReceiptDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceiptDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceiptDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptDetailMaxAggregateInputType
  }

  export type GetReceiptDetailAggregateType<T extends ReceiptDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateReceiptDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceiptDetail[P]>
      : GetScalarType<T[P], AggregateReceiptDetail[P]>
  }




  export type ReceiptDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceiptDetailWhereInput
    orderBy?: ReceiptDetailOrderByWithAggregationInput | ReceiptDetailOrderByWithAggregationInput[]
    by: ReceiptDetailScalarFieldEnum[] | ReceiptDetailScalarFieldEnum
    having?: ReceiptDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptDetailCountAggregateInputType | true
    _avg?: ReceiptDetailAvgAggregateInputType
    _sum?: ReceiptDetailSumAggregateInputType
    _min?: ReceiptDetailMinAggregateInputType
    _max?: ReceiptDetailMaxAggregateInputType
  }

  export type ReceiptDetailGroupByOutputType = {
    id: number
    receiptId: number | null
    productDetailSizeId: number | null
    quantity: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: ReceiptDetailCountAggregateOutputType | null
    _avg: ReceiptDetailAvgAggregateOutputType | null
    _sum: ReceiptDetailSumAggregateOutputType | null
    _min: ReceiptDetailMinAggregateOutputType | null
    _max: ReceiptDetailMaxAggregateOutputType | null
  }

  type GetReceiptDetailGroupByPayload<T extends ReceiptDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptDetailGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptDetailGroupByOutputType[P]>
        }
      >
    >


  export type ReceiptDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receiptId?: boolean
    productDetailSizeId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["receiptDetail"]>

  export type ReceiptDetailSelectScalar = {
    id?: boolean
    receiptId?: boolean
    productDetailSizeId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ReceiptDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReceiptDetail"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      receiptId: number | null
      productDetailSizeId: number | null
      quantity: number | null
      price: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["receiptDetail"]>
    composites: {}
  }


  type ReceiptDetailGetPayload<S extends boolean | null | undefined | ReceiptDetailDefaultArgs> = $Result.GetResult<Prisma.$ReceiptDetailPayload, S>

  type ReceiptDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReceiptDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReceiptDetailCountAggregateInputType | true
    }

  export interface ReceiptDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReceiptDetail'], meta: { name: 'ReceiptDetail' } }
    /**
     * Find zero or one ReceiptDetail that matches the filter.
     * @param {ReceiptDetailFindUniqueArgs} args - Arguments to find a ReceiptDetail
     * @example
     * // Get one ReceiptDetail
     * const receiptDetail = await prisma.receiptDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReceiptDetailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReceiptDetailFindUniqueArgs<ExtArgs>>
    ): Prisma__ReceiptDetailClient<$Result.GetResult<Prisma.$ReceiptDetailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ReceiptDetail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReceiptDetailFindUniqueOrThrowArgs} args - Arguments to find a ReceiptDetail
     * @example
     * // Get one ReceiptDetail
     * const receiptDetail = await prisma.receiptDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReceiptDetailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceiptDetailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReceiptDetailClient<$Result.GetResult<Prisma.$ReceiptDetailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ReceiptDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptDetailFindFirstArgs} args - Arguments to find a ReceiptDetail
     * @example
     * // Get one ReceiptDetail
     * const receiptDetail = await prisma.receiptDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReceiptDetailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceiptDetailFindFirstArgs<ExtArgs>>
    ): Prisma__ReceiptDetailClient<$Result.GetResult<Prisma.$ReceiptDetailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ReceiptDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptDetailFindFirstOrThrowArgs} args - Arguments to find a ReceiptDetail
     * @example
     * // Get one ReceiptDetail
     * const receiptDetail = await prisma.receiptDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReceiptDetailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceiptDetailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReceiptDetailClient<$Result.GetResult<Prisma.$ReceiptDetailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ReceiptDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptDetailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReceiptDetails
     * const receiptDetails = await prisma.receiptDetail.findMany()
     * 
     * // Get first 10 ReceiptDetails
     * const receiptDetails = await prisma.receiptDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptDetailWithIdOnly = await prisma.receiptDetail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReceiptDetailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceiptDetailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceiptDetailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ReceiptDetail.
     * @param {ReceiptDetailCreateArgs} args - Arguments to create a ReceiptDetail.
     * @example
     * // Create one ReceiptDetail
     * const ReceiptDetail = await prisma.receiptDetail.create({
     *   data: {
     *     // ... data to create a ReceiptDetail
     *   }
     * })
     * 
    **/
    create<T extends ReceiptDetailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReceiptDetailCreateArgs<ExtArgs>>
    ): Prisma__ReceiptDetailClient<$Result.GetResult<Prisma.$ReceiptDetailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ReceiptDetails.
     *     @param {ReceiptDetailCreateManyArgs} args - Arguments to create many ReceiptDetails.
     *     @example
     *     // Create many ReceiptDetails
     *     const receiptDetail = await prisma.receiptDetail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReceiptDetailCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceiptDetailCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReceiptDetail.
     * @param {ReceiptDetailDeleteArgs} args - Arguments to delete one ReceiptDetail.
     * @example
     * // Delete one ReceiptDetail
     * const ReceiptDetail = await prisma.receiptDetail.delete({
     *   where: {
     *     // ... filter to delete one ReceiptDetail
     *   }
     * })
     * 
    **/
    delete<T extends ReceiptDetailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReceiptDetailDeleteArgs<ExtArgs>>
    ): Prisma__ReceiptDetailClient<$Result.GetResult<Prisma.$ReceiptDetailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ReceiptDetail.
     * @param {ReceiptDetailUpdateArgs} args - Arguments to update one ReceiptDetail.
     * @example
     * // Update one ReceiptDetail
     * const receiptDetail = await prisma.receiptDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReceiptDetailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReceiptDetailUpdateArgs<ExtArgs>>
    ): Prisma__ReceiptDetailClient<$Result.GetResult<Prisma.$ReceiptDetailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ReceiptDetails.
     * @param {ReceiptDetailDeleteManyArgs} args - Arguments to filter ReceiptDetails to delete.
     * @example
     * // Delete a few ReceiptDetails
     * const { count } = await prisma.receiptDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReceiptDetailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReceiptDetailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceiptDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReceiptDetails
     * const receiptDetail = await prisma.receiptDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReceiptDetailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReceiptDetailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReceiptDetail.
     * @param {ReceiptDetailUpsertArgs} args - Arguments to update or create a ReceiptDetail.
     * @example
     * // Update or create a ReceiptDetail
     * const receiptDetail = await prisma.receiptDetail.upsert({
     *   create: {
     *     // ... data to create a ReceiptDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReceiptDetail we want to update
     *   }
     * })
    **/
    upsert<T extends ReceiptDetailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReceiptDetailUpsertArgs<ExtArgs>>
    ): Prisma__ReceiptDetailClient<$Result.GetResult<Prisma.$ReceiptDetailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ReceiptDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptDetailCountArgs} args - Arguments to filter ReceiptDetails to count.
     * @example
     * // Count the number of ReceiptDetails
     * const count = await prisma.receiptDetail.count({
     *   where: {
     *     // ... the filter for the ReceiptDetails we want to count
     *   }
     * })
    **/
    count<T extends ReceiptDetailCountArgs>(
      args?: Subset<T, ReceiptDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReceiptDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptDetailAggregateArgs>(args: Subset<T, ReceiptDetailAggregateArgs>): Prisma.PrismaPromise<GetReceiptDetailAggregateType<T>>

    /**
     * Group by ReceiptDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiptDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiptDetailGroupByArgs['orderBy'] }
        : { orderBy?: ReceiptDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiptDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReceiptDetail model
   */
  readonly fields: ReceiptDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReceiptDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceiptDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ReceiptDetail model
   */ 
  interface ReceiptDetailFieldRefs {
    readonly id: FieldRef<"ReceiptDetail", 'Int'>
    readonly receiptId: FieldRef<"ReceiptDetail", 'Int'>
    readonly productDetailSizeId: FieldRef<"ReceiptDetail", 'Int'>
    readonly quantity: FieldRef<"ReceiptDetail", 'Int'>
    readonly price: FieldRef<"ReceiptDetail", 'Int'>
    readonly createdAt: FieldRef<"ReceiptDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"ReceiptDetail", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ReceiptDetail findUnique
   */
  export type ReceiptDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptDetail
     */
    select?: ReceiptDetailSelect<ExtArgs> | null
    /**
     * Filter, which ReceiptDetail to fetch.
     */
    where: ReceiptDetailWhereUniqueInput
  }


  /**
   * ReceiptDetail findUniqueOrThrow
   */
  export type ReceiptDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptDetail
     */
    select?: ReceiptDetailSelect<ExtArgs> | null
    /**
     * Filter, which ReceiptDetail to fetch.
     */
    where: ReceiptDetailWhereUniqueInput
  }


  /**
   * ReceiptDetail findFirst
   */
  export type ReceiptDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptDetail
     */
    select?: ReceiptDetailSelect<ExtArgs> | null
    /**
     * Filter, which ReceiptDetail to fetch.
     */
    where?: ReceiptDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptDetails to fetch.
     */
    orderBy?: ReceiptDetailOrderByWithRelationInput | ReceiptDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceiptDetails.
     */
    cursor?: ReceiptDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceiptDetails.
     */
    distinct?: ReceiptDetailScalarFieldEnum | ReceiptDetailScalarFieldEnum[]
  }


  /**
   * ReceiptDetail findFirstOrThrow
   */
  export type ReceiptDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptDetail
     */
    select?: ReceiptDetailSelect<ExtArgs> | null
    /**
     * Filter, which ReceiptDetail to fetch.
     */
    where?: ReceiptDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptDetails to fetch.
     */
    orderBy?: ReceiptDetailOrderByWithRelationInput | ReceiptDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceiptDetails.
     */
    cursor?: ReceiptDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceiptDetails.
     */
    distinct?: ReceiptDetailScalarFieldEnum | ReceiptDetailScalarFieldEnum[]
  }


  /**
   * ReceiptDetail findMany
   */
  export type ReceiptDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptDetail
     */
    select?: ReceiptDetailSelect<ExtArgs> | null
    /**
     * Filter, which ReceiptDetails to fetch.
     */
    where?: ReceiptDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceiptDetails to fetch.
     */
    orderBy?: ReceiptDetailOrderByWithRelationInput | ReceiptDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReceiptDetails.
     */
    cursor?: ReceiptDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceiptDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceiptDetails.
     */
    skip?: number
    distinct?: ReceiptDetailScalarFieldEnum | ReceiptDetailScalarFieldEnum[]
  }


  /**
   * ReceiptDetail create
   */
  export type ReceiptDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptDetail
     */
    select?: ReceiptDetailSelect<ExtArgs> | null
    /**
     * The data needed to create a ReceiptDetail.
     */
    data?: XOR<ReceiptDetailCreateInput, ReceiptDetailUncheckedCreateInput>
  }


  /**
   * ReceiptDetail createMany
   */
  export type ReceiptDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReceiptDetails.
     */
    data: ReceiptDetailCreateManyInput | ReceiptDetailCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ReceiptDetail update
   */
  export type ReceiptDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptDetail
     */
    select?: ReceiptDetailSelect<ExtArgs> | null
    /**
     * The data needed to update a ReceiptDetail.
     */
    data: XOR<ReceiptDetailUpdateInput, ReceiptDetailUncheckedUpdateInput>
    /**
     * Choose, which ReceiptDetail to update.
     */
    where: ReceiptDetailWhereUniqueInput
  }


  /**
   * ReceiptDetail updateMany
   */
  export type ReceiptDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReceiptDetails.
     */
    data: XOR<ReceiptDetailUpdateManyMutationInput, ReceiptDetailUncheckedUpdateManyInput>
    /**
     * Filter which ReceiptDetails to update
     */
    where?: ReceiptDetailWhereInput
  }


  /**
   * ReceiptDetail upsert
   */
  export type ReceiptDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptDetail
     */
    select?: ReceiptDetailSelect<ExtArgs> | null
    /**
     * The filter to search for the ReceiptDetail to update in case it exists.
     */
    where: ReceiptDetailWhereUniqueInput
    /**
     * In case the ReceiptDetail found by the `where` argument doesn't exist, create a new ReceiptDetail with this data.
     */
    create: XOR<ReceiptDetailCreateInput, ReceiptDetailUncheckedCreateInput>
    /**
     * In case the ReceiptDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceiptDetailUpdateInput, ReceiptDetailUncheckedUpdateInput>
  }


  /**
   * ReceiptDetail delete
   */
  export type ReceiptDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptDetail
     */
    select?: ReceiptDetailSelect<ExtArgs> | null
    /**
     * Filter which ReceiptDetail to delete.
     */
    where: ReceiptDetailWhereUniqueInput
  }


  /**
   * ReceiptDetail deleteMany
   */
  export type ReceiptDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceiptDetails to delete
     */
    where?: ReceiptDetailWhereInput
  }


  /**
   * ReceiptDetail without action
   */
  export type ReceiptDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceiptDetail
     */
    select?: ReceiptDetailSelect<ExtArgs> | null
  }



  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    brandId: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    brandId: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    brandId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    brandId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    brandId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    brandId?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    brandId?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    brandId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    brandId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    brandId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    brandId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brandId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | Category$brandArgs<ExtArgs>
    Product?: boolean | Category$ProductArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    brandId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | Category$brandArgs<ExtArgs>
    Product?: boolean | Category$ProductArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      brand: Prisma.$BrandPayload<ExtArgs> | null
      Product: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      brandId: number | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }


  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    brand<T extends Category$brandArgs<ExtArgs> = {}>(args?: Subset<T, Category$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    Product<T extends Category$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Category$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly brandId: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }


  /**
   * Category.brand
   */
  export type Category$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }


  /**
   * Category.Product
   */
  export type Category$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
  }



  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandAvgAggregateOutputType = {
    id: number | null
  }

  export type BrandSumAggregateOutputType = {
    id: number | null
  }

  export type BrandMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandAvgAggregateInputType = {
    id?: true
  }

  export type BrandSumAggregateInputType = {
    id?: true
  }

  export type BrandMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _avg?: BrandAvgAggregateInputType
    _sum?: BrandSumAggregateInputType
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: number
    name: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Product?: boolean | Brand$ProductArgs<ExtArgs>
    Category?: boolean | Brand$CategoryArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Product?: boolean | Brand$ProductArgs<ExtArgs>
    Category?: boolean | Brand$CategoryArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      Product: Prisma.$ProductPayload<ExtArgs>[]
      Category: Prisma.$CategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }


  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BrandFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Brand that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BrandFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BrandFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
    **/
    create<T extends BrandCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BrandCreateArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Brands.
     *     @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     *     @example
     *     // Create many Brands
     *     const brand = await prisma.brand.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BrandCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
    **/
    delete<T extends BrandDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BrandUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BrandDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BrandUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
    **/
    upsert<T extends BrandUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>
    ): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Product<T extends Brand$ProductArgs<ExtArgs> = {}>(args?: Subset<T, Brand$ProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    Category<T extends Brand$CategoryArgs<ExtArgs> = {}>(args?: Subset<T, Brand$CategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Brand model
   */ 
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'Int'>
    readonly name: FieldRef<"Brand", 'String'>
    readonly createdAt: FieldRef<"Brand", 'DateTime'>
    readonly updatedAt: FieldRef<"Brand", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }


  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }


  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }


  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }


  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }


  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }


  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }


  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
  }


  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }


  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }


  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
  }


  /**
   * Brand.Product
   */
  export type Brand$ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Brand.Category
   */
  export type Brand$CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    address: 'address',
    gender: 'gender',
    phoneNumber: 'phoneNumber',
    image: 'image',
    dob: 'dob',
    isActiveEmail: 'isActiveEmail',
    roleId: 'roleId',
    status: 'status',
    userToken: 'userToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AddressUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    shipName: 'shipName',
    shipAdress: 'shipAdress',
    shipPhone: 'shipPhone',
    shipEmail: 'shipEmail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressUserScalarFieldEnum = (typeof AddressUserScalarFieldEnum)[keyof typeof AddressUserScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    description: 'description',
    name: 'name',
    status: 'status',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const BlogScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subject: 'subject',
    status: 'status',
    image: 'image',
    contentMarkdown: 'contentMarkdown',
    contentHTML: 'contentHTML',
    userId: 'userId',
    view: 'view',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogScalarFieldEnum = (typeof BlogScalarFieldEnum)[keyof typeof BlogScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    image: 'image',
    parentId: 'parentId',
    productId: 'productId',
    userId: 'userId',
    blogId: 'blogId',
    star: 'star',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    text: 'text',
    userId: 'userId',
    roomId: 'roomId',
    unRead: 'unRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const OrderDetaillScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    realPrice: 'realPrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderDetaillScalarFieldEnum = (typeof OrderDetaillScalarFieldEnum)[keyof typeof OrderDetaillScalarFieldEnum]


  export const OrderProductScalarFieldEnum: {
    id: 'id',
    addressUserId: 'addressUserId',
    status: 'status',
    typeShipId: 'typeShipId',
    voucherId: 'voucherId',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderProductScalarFieldEnum = (typeof OrderProductScalarFieldEnum)[keyof typeof OrderProductScalarFieldEnum]


  export const ProductSizeScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    size: 'size',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductSizeScalarFieldEnum = (typeof ProductSizeScalarFieldEnum)[keyof typeof ProductSizeScalarFieldEnum]


  export const ProductImageScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    image_url: 'image_url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductImageScalarFieldEnum = (typeof ProductImageScalarFieldEnum)[keyof typeof ProductImageScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contentHTML: 'contentHTML',
    contentMarkdown: 'contentMarkdown',
    status: 'status',
    categoryId: 'categoryId',
    view: 'view',
    material: 'material',
    brandId: 'brandId',
    originalPrice: 'originalPrice',
    discountPrice: 'discountPrice'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const RoomMessageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userOneId: 'userOneId',
    userTwoId: 'userTwoId'
  };

  export type RoomMessageScalarFieldEnum = (typeof RoomMessageScalarFieldEnum)[keyof typeof RoomMessageScalarFieldEnum]


  export const ShopCartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productSizeId: 'productSizeId',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShopCartScalarFieldEnum = (typeof ShopCartScalarFieldEnum)[keyof typeof ShopCartScalarFieldEnum]


  export const TypeShipScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TypeShipScalarFieldEnum = (typeof TypeShipScalarFieldEnum)[keyof typeof TypeShipScalarFieldEnum]


  export const TypeVoucherScalarFieldEnum: {
    id: 'id',
    typeVoucher: 'typeVoucher',
    value: 'value',
    maxValue: 'maxValue',
    minValue: 'minValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TypeVoucherScalarFieldEnum = (typeof TypeVoucherScalarFieldEnum)[keyof typeof TypeVoucherScalarFieldEnum]


  export const VoucherScalarFieldEnum: {
    id: 'id',
    fromDate: 'fromDate',
    toDate: 'toDate',
    typeVoucherId: 'typeVoucherId',
    amount: 'amount',
    codeVoucher: 'codeVoucher',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoucherScalarFieldEnum = (typeof VoucherScalarFieldEnum)[keyof typeof VoucherScalarFieldEnum]


  export const VoucherUsedScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    voucherId: 'voucherId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoucherUsedScalarFieldEnum = (typeof VoucherUsedScalarFieldEnum)[keyof typeof VoucherUsedScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phoneNumber: 'phoneNumber',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const ReceiptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    supplierId: 'supplierId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReceiptScalarFieldEnum = (typeof ReceiptScalarFieldEnum)[keyof typeof ReceiptScalarFieldEnum]


  export const ReceiptDetailScalarFieldEnum: {
    id: 'id',
    receiptId: 'receiptId',
    productDetailSizeId: 'productDetailSizeId',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReceiptDetailScalarFieldEnum = (typeof ReceiptDetailScalarFieldEnum)[keyof typeof ReceiptDetailScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    brandId: 'brandId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Subject'
   */
  export type EnumSubjectFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Subject'>
    


  /**
   * Reference to a field of type 'Subject[]'
   */
  export type ListEnumSubjectFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Subject[]'>
    


  /**
   * Reference to a field of type 'Size'
   */
  export type EnumSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Size'>
    


  /**
   * Reference to a field of type 'Size[]'
   */
  export type ListEnumSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Size[]'>
    


  /**
   * Reference to a field of type 'Discount'
   */
  export type EnumDiscountFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Discount'>
    


  /**
   * Reference to a field of type 'Discount[]'
   */
  export type ListEnumDiscountFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Discount[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    address?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    dob?: DateTimeNullableFilter<"User"> | Date | string | null
    isActiveEmail?: BoolNullableFilter<"User"> | boolean | null
    roleId?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumStatusNullableFilter<"User"> | $Enums.Status | null
    userToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    addressUser?: AddressUserListRelationFilter
    blog?: BlogListRelationFilter
    Comment?: CommentListRelationFilter
    Message?: MessageListRelationFilter
    ShopCart?: ShopCartListRelationFilter
    roomMessagesOne?: RoomMessageListRelationFilter
    roomMessagesTwo?: RoomMessageListRelationFilter
    Receipt?: ReceiptListRelationFilter
    VoucherUsed?: VoucherUsedListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    isActiveEmail?: SortOrderInput | SortOrder
    roleId?: SortOrder
    status?: SortOrderInput | SortOrder
    userToken?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    addressUser?: AddressUserOrderByRelationAggregateInput
    blog?: BlogOrderByRelationAggregateInput
    Comment?: CommentOrderByRelationAggregateInput
    Message?: MessageOrderByRelationAggregateInput
    ShopCart?: ShopCartOrderByRelationAggregateInput
    roomMessagesOne?: RoomMessageOrderByRelationAggregateInput
    roomMessagesTwo?: RoomMessageOrderByRelationAggregateInput
    Receipt?: ReceiptOrderByRelationAggregateInput
    VoucherUsed?: VoucherUsedOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    phoneNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    address?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    image?: StringNullableFilter<"User"> | string | null
    dob?: DateTimeNullableFilter<"User"> | Date | string | null
    isActiveEmail?: BoolNullableFilter<"User"> | boolean | null
    roleId?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumStatusNullableFilter<"User"> | $Enums.Status | null
    userToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    addressUser?: AddressUserListRelationFilter
    blog?: BlogListRelationFilter
    Comment?: CommentListRelationFilter
    Message?: MessageListRelationFilter
    ShopCart?: ShopCartListRelationFilter
    roomMessagesOne?: RoomMessageListRelationFilter
    roomMessagesTwo?: RoomMessageListRelationFilter
    Receipt?: ReceiptListRelationFilter
    VoucherUsed?: VoucherUsedListRelationFilter
  }, "id" | "email" | "phoneNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    isActiveEmail?: SortOrderInput | SortOrder
    roleId?: SortOrder
    status?: SortOrderInput | SortOrder
    userToken?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"User"> | $Enums.Gender | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    dob?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isActiveEmail?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    roleId?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    status?: EnumStatusNullableWithAggregatesFilter<"User"> | $Enums.Status | null
    userToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AddressUserWhereInput = {
    AND?: AddressUserWhereInput | AddressUserWhereInput[]
    OR?: AddressUserWhereInput[]
    NOT?: AddressUserWhereInput | AddressUserWhereInput[]
    id?: IntFilter<"AddressUser"> | number
    userId?: IntFilter<"AddressUser"> | number
    shipName?: StringNullableFilter<"AddressUser"> | string | null
    shipAdress?: StringNullableFilter<"AddressUser"> | string | null
    shipPhone?: StringNullableFilter<"AddressUser"> | string | null
    shipEmail?: StringNullableFilter<"AddressUser"> | string | null
    createdAt?: DateTimeNullableFilter<"AddressUser"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AddressUser"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    OrderProduct?: OrderProductListRelationFilter
  }

  export type AddressUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    shipName?: SortOrderInput | SortOrder
    shipAdress?: SortOrderInput | SortOrder
    shipPhone?: SortOrderInput | SortOrder
    shipEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    OrderProduct?: OrderProductOrderByRelationAggregateInput
  }

  export type AddressUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressUserWhereInput | AddressUserWhereInput[]
    OR?: AddressUserWhereInput[]
    NOT?: AddressUserWhereInput | AddressUserWhereInput[]
    userId?: IntFilter<"AddressUser"> | number
    shipName?: StringNullableFilter<"AddressUser"> | string | null
    shipAdress?: StringNullableFilter<"AddressUser"> | string | null
    shipPhone?: StringNullableFilter<"AddressUser"> | string | null
    shipEmail?: StringNullableFilter<"AddressUser"> | string | null
    createdAt?: DateTimeNullableFilter<"AddressUser"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AddressUser"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    OrderProduct?: OrderProductListRelationFilter
  }, "id">

  export type AddressUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    shipName?: SortOrderInput | SortOrder
    shipAdress?: SortOrderInput | SortOrder
    shipPhone?: SortOrderInput | SortOrder
    shipEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AddressUserCountOrderByAggregateInput
    _avg?: AddressUserAvgOrderByAggregateInput
    _max?: AddressUserMaxOrderByAggregateInput
    _min?: AddressUserMinOrderByAggregateInput
    _sum?: AddressUserSumOrderByAggregateInput
  }

  export type AddressUserScalarWhereWithAggregatesInput = {
    AND?: AddressUserScalarWhereWithAggregatesInput | AddressUserScalarWhereWithAggregatesInput[]
    OR?: AddressUserScalarWhereWithAggregatesInput[]
    NOT?: AddressUserScalarWhereWithAggregatesInput | AddressUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AddressUser"> | number
    userId?: IntWithAggregatesFilter<"AddressUser"> | number
    shipName?: StringNullableWithAggregatesFilter<"AddressUser"> | string | null
    shipAdress?: StringNullableWithAggregatesFilter<"AddressUser"> | string | null
    shipPhone?: StringNullableWithAggregatesFilter<"AddressUser"> | string | null
    shipEmail?: StringNullableWithAggregatesFilter<"AddressUser"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"AddressUser"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AddressUser"> | Date | string | null
  }

  export type BannerWhereInput = {
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    id?: IntFilter<"Banner"> | number
    description?: StringNullableFilter<"Banner"> | string | null
    name?: StringNullableFilter<"Banner"> | string | null
    status?: EnumStatusNullableFilter<"Banner"> | $Enums.Status | null
    image?: StringNullableFilter<"Banner"> | string | null
    createdAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
  }

  export type BannerOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type BannerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BannerWhereInput | BannerWhereInput[]
    OR?: BannerWhereInput[]
    NOT?: BannerWhereInput | BannerWhereInput[]
    description?: StringNullableFilter<"Banner"> | string | null
    name?: StringNullableFilter<"Banner"> | string | null
    status?: EnumStatusNullableFilter<"Banner"> | $Enums.Status | null
    image?: StringNullableFilter<"Banner"> | string | null
    createdAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Banner"> | Date | string | null
  }, "id">

  export type BannerOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BannerCountOrderByAggregateInput
    _avg?: BannerAvgOrderByAggregateInput
    _max?: BannerMaxOrderByAggregateInput
    _min?: BannerMinOrderByAggregateInput
    _sum?: BannerSumOrderByAggregateInput
  }

  export type BannerScalarWhereWithAggregatesInput = {
    AND?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    OR?: BannerScalarWhereWithAggregatesInput[]
    NOT?: BannerScalarWhereWithAggregatesInput | BannerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Banner"> | number
    description?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    name?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    status?: EnumStatusNullableWithAggregatesFilter<"Banner"> | $Enums.Status | null
    image?: StringNullableWithAggregatesFilter<"Banner"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Banner"> | Date | string | null
  }

  export type BlogWhereInput = {
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    id?: IntFilter<"Blog"> | number
    title?: StringNullableFilter<"Blog"> | string | null
    subject?: EnumSubjectNullableFilter<"Blog"> | $Enums.Subject | null
    status?: EnumStatusNullableFilter<"Blog"> | $Enums.Status | null
    image?: StringNullableFilter<"Blog"> | string | null
    contentMarkdown?: StringNullableFilter<"Blog"> | string | null
    contentHTML?: StringNullableFilter<"Blog"> | string | null
    userId?: IntNullableFilter<"Blog"> | number | null
    view?: IntNullableFilter<"Blog"> | number | null
    createdAt?: DateTimeNullableFilter<"Blog"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Blog"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    Comment?: CommentListRelationFilter
  }

  export type BlogOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    contentMarkdown?: SortOrderInput | SortOrder
    contentHTML?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    view?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    Comment?: CommentOrderByRelationAggregateInput
  }

  export type BlogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    title?: StringNullableFilter<"Blog"> | string | null
    subject?: EnumSubjectNullableFilter<"Blog"> | $Enums.Subject | null
    status?: EnumStatusNullableFilter<"Blog"> | $Enums.Status | null
    image?: StringNullableFilter<"Blog"> | string | null
    contentMarkdown?: StringNullableFilter<"Blog"> | string | null
    contentHTML?: StringNullableFilter<"Blog"> | string | null
    userId?: IntNullableFilter<"Blog"> | number | null
    view?: IntNullableFilter<"Blog"> | number | null
    createdAt?: DateTimeNullableFilter<"Blog"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Blog"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    Comment?: CommentListRelationFilter
  }, "id">

  export type BlogOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    contentMarkdown?: SortOrderInput | SortOrder
    contentHTML?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    view?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BlogCountOrderByAggregateInput
    _avg?: BlogAvgOrderByAggregateInput
    _max?: BlogMaxOrderByAggregateInput
    _min?: BlogMinOrderByAggregateInput
    _sum?: BlogSumOrderByAggregateInput
  }

  export type BlogScalarWhereWithAggregatesInput = {
    AND?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    OR?: BlogScalarWhereWithAggregatesInput[]
    NOT?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Blog"> | number
    title?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    subject?: EnumSubjectNullableWithAggregatesFilter<"Blog"> | $Enums.Subject | null
    status?: EnumStatusNullableWithAggregatesFilter<"Blog"> | $Enums.Status | null
    image?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    contentMarkdown?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    contentHTML?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    userId?: IntNullableWithAggregatesFilter<"Blog"> | number | null
    view?: IntNullableWithAggregatesFilter<"Blog"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Blog"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Blog"> | Date | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    content?: StringNullableFilter<"Comment"> | string | null
    image?: StringNullableFilter<"Comment"> | string | null
    parentId?: IntNullableFilter<"Comment"> | number | null
    productId?: IntNullableFilter<"Comment"> | number | null
    userId?: IntNullableFilter<"Comment"> | number | null
    blogId?: IntNullableFilter<"Comment"> | number | null
    star?: IntNullableFilter<"Comment"> | number | null
    createdAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    blog?: XOR<BlogNullableRelationFilter, BlogWhereInput> | null
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    blogId?: SortOrderInput | SortOrder
    star?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    blog?: BlogOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringNullableFilter<"Comment"> | string | null
    image?: StringNullableFilter<"Comment"> | string | null
    parentId?: IntNullableFilter<"Comment"> | number | null
    productId?: IntNullableFilter<"Comment"> | number | null
    userId?: IntNullableFilter<"Comment"> | number | null
    blogId?: IntNullableFilter<"Comment"> | number | null
    star?: IntNullableFilter<"Comment"> | number | null
    createdAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    blog?: XOR<BlogNullableRelationFilter, BlogWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    blogId?: SortOrderInput | SortOrder
    star?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    content?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    image?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    parentId?: IntNullableWithAggregatesFilter<"Comment"> | number | null
    productId?: IntNullableWithAggregatesFilter<"Comment"> | number | null
    userId?: IntNullableWithAggregatesFilter<"Comment"> | number | null
    blogId?: IntNullableWithAggregatesFilter<"Comment"> | number | null
    star?: IntNullableWithAggregatesFilter<"Comment"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Comment"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Comment"> | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter<"Message"> | number
    text?: StringNullableFilter<"Message"> | string | null
    userId?: IntNullableFilter<"Message"> | number | null
    roomId?: IntNullableFilter<"Message"> | number | null
    unRead?: BoolNullableFilter<"Message"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    room?: XOR<RoomMessageNullableRelationFilter, RoomMessageWhereInput> | null
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    unRead?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    room?: RoomMessageOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    text?: StringNullableFilter<"Message"> | string | null
    userId?: IntNullableFilter<"Message"> | number | null
    roomId?: IntNullableFilter<"Message"> | number | null
    unRead?: BoolNullableFilter<"Message"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    room?: XOR<RoomMessageNullableRelationFilter, RoomMessageWhereInput> | null
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    unRead?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Message"> | number
    text?: StringNullableWithAggregatesFilter<"Message"> | string | null
    userId?: IntNullableWithAggregatesFilter<"Message"> | number | null
    roomId?: IntNullableWithAggregatesFilter<"Message"> | number | null
    unRead?: BoolNullableWithAggregatesFilter<"Message"> | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
  }

  export type OrderDetaillWhereInput = {
    AND?: OrderDetaillWhereInput | OrderDetaillWhereInput[]
    OR?: OrderDetaillWhereInput[]
    NOT?: OrderDetaillWhereInput | OrderDetaillWhereInput[]
    id?: IntFilter<"OrderDetaill"> | number
    orderId?: IntNullableFilter<"OrderDetaill"> | number | null
    productId?: IntNullableFilter<"OrderDetaill"> | number | null
    quantity?: IntNullableFilter<"OrderDetaill"> | number | null
    realPrice?: IntNullableFilter<"OrderDetaill"> | number | null
    createdAt?: DateTimeNullableFilter<"OrderDetaill"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"OrderDetaill"> | Date | string | null
    order?: XOR<OrderProductNullableRelationFilter, OrderProductWhereInput> | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }

  export type OrderDetaillOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    realPrice?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    order?: OrderProductOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderDetaillWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderDetaillWhereInput | OrderDetaillWhereInput[]
    OR?: OrderDetaillWhereInput[]
    NOT?: OrderDetaillWhereInput | OrderDetaillWhereInput[]
    orderId?: IntNullableFilter<"OrderDetaill"> | number | null
    productId?: IntNullableFilter<"OrderDetaill"> | number | null
    quantity?: IntNullableFilter<"OrderDetaill"> | number | null
    realPrice?: IntNullableFilter<"OrderDetaill"> | number | null
    createdAt?: DateTimeNullableFilter<"OrderDetaill"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"OrderDetaill"> | Date | string | null
    order?: XOR<OrderProductNullableRelationFilter, OrderProductWhereInput> | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }, "id">

  export type OrderDetaillOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    realPrice?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: OrderDetaillCountOrderByAggregateInput
    _avg?: OrderDetaillAvgOrderByAggregateInput
    _max?: OrderDetaillMaxOrderByAggregateInput
    _min?: OrderDetaillMinOrderByAggregateInput
    _sum?: OrderDetaillSumOrderByAggregateInput
  }

  export type OrderDetaillScalarWhereWithAggregatesInput = {
    AND?: OrderDetaillScalarWhereWithAggregatesInput | OrderDetaillScalarWhereWithAggregatesInput[]
    OR?: OrderDetaillScalarWhereWithAggregatesInput[]
    NOT?: OrderDetaillScalarWhereWithAggregatesInput | OrderDetaillScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderDetaill"> | number
    orderId?: IntNullableWithAggregatesFilter<"OrderDetaill"> | number | null
    productId?: IntNullableWithAggregatesFilter<"OrderDetaill"> | number | null
    quantity?: IntNullableWithAggregatesFilter<"OrderDetaill"> | number | null
    realPrice?: IntNullableWithAggregatesFilter<"OrderDetaill"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"OrderDetaill"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"OrderDetaill"> | Date | string | null
  }

  export type OrderProductWhereInput = {
    AND?: OrderProductWhereInput | OrderProductWhereInput[]
    OR?: OrderProductWhereInput[]
    NOT?: OrderProductWhereInput | OrderProductWhereInput[]
    id?: IntFilter<"OrderProduct"> | number
    addressUserId?: IntNullableFilter<"OrderProduct"> | number | null
    status?: EnumStatusNullableFilter<"OrderProduct"> | $Enums.Status | null
    typeShipId?: IntNullableFilter<"OrderProduct"> | number | null
    voucherId?: IntNullableFilter<"OrderProduct"> | number | null
    image?: StringNullableFilter<"OrderProduct"> | string | null
    createdAt?: DateTimeNullableFilter<"OrderProduct"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"OrderProduct"> | Date | string | null
    addressUser?: XOR<AddressUserNullableRelationFilter, AddressUserWhereInput> | null
    typeShip?: XOR<TypeShipNullableRelationFilter, TypeShipWhereInput> | null
    voucher?: XOR<VoucherNullableRelationFilter, VoucherWhereInput> | null
    OrderDetaill?: OrderDetaillListRelationFilter
  }

  export type OrderProductOrderByWithRelationInput = {
    id?: SortOrder
    addressUserId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    typeShipId?: SortOrderInput | SortOrder
    voucherId?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    addressUser?: AddressUserOrderByWithRelationInput
    typeShip?: TypeShipOrderByWithRelationInput
    voucher?: VoucherOrderByWithRelationInput
    OrderDetaill?: OrderDetaillOrderByRelationAggregateInput
  }

  export type OrderProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderProductWhereInput | OrderProductWhereInput[]
    OR?: OrderProductWhereInput[]
    NOT?: OrderProductWhereInput | OrderProductWhereInput[]
    addressUserId?: IntNullableFilter<"OrderProduct"> | number | null
    status?: EnumStatusNullableFilter<"OrderProduct"> | $Enums.Status | null
    typeShipId?: IntNullableFilter<"OrderProduct"> | number | null
    voucherId?: IntNullableFilter<"OrderProduct"> | number | null
    image?: StringNullableFilter<"OrderProduct"> | string | null
    createdAt?: DateTimeNullableFilter<"OrderProduct"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"OrderProduct"> | Date | string | null
    addressUser?: XOR<AddressUserNullableRelationFilter, AddressUserWhereInput> | null
    typeShip?: XOR<TypeShipNullableRelationFilter, TypeShipWhereInput> | null
    voucher?: XOR<VoucherNullableRelationFilter, VoucherWhereInput> | null
    OrderDetaill?: OrderDetaillListRelationFilter
  }, "id">

  export type OrderProductOrderByWithAggregationInput = {
    id?: SortOrder
    addressUserId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    typeShipId?: SortOrderInput | SortOrder
    voucherId?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: OrderProductCountOrderByAggregateInput
    _avg?: OrderProductAvgOrderByAggregateInput
    _max?: OrderProductMaxOrderByAggregateInput
    _min?: OrderProductMinOrderByAggregateInput
    _sum?: OrderProductSumOrderByAggregateInput
  }

  export type OrderProductScalarWhereWithAggregatesInput = {
    AND?: OrderProductScalarWhereWithAggregatesInput | OrderProductScalarWhereWithAggregatesInput[]
    OR?: OrderProductScalarWhereWithAggregatesInput[]
    NOT?: OrderProductScalarWhereWithAggregatesInput | OrderProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderProduct"> | number
    addressUserId?: IntNullableWithAggregatesFilter<"OrderProduct"> | number | null
    status?: EnumStatusNullableWithAggregatesFilter<"OrderProduct"> | $Enums.Status | null
    typeShipId?: IntNullableWithAggregatesFilter<"OrderProduct"> | number | null
    voucherId?: IntNullableWithAggregatesFilter<"OrderProduct"> | number | null
    image?: StringNullableWithAggregatesFilter<"OrderProduct"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"OrderProduct"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"OrderProduct"> | Date | string | null
  }

  export type ProductSizeWhereInput = {
    AND?: ProductSizeWhereInput | ProductSizeWhereInput[]
    OR?: ProductSizeWhereInput[]
    NOT?: ProductSizeWhereInput | ProductSizeWhereInput[]
    id?: IntFilter<"ProductSize"> | number
    productId?: IntNullableFilter<"ProductSize"> | number | null
    size?: EnumSizeNullableFilter<"ProductSize"> | $Enums.Size | null
    quantity?: IntNullableFilter<"ProductSize"> | number | null
    createdAt?: DateTimeNullableFilter<"ProductSize"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ProductSize"> | Date | string | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    ShopCart?: ShopCartListRelationFilter
  }

  export type ProductSizeOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    ShopCart?: ShopCartOrderByRelationAggregateInput
  }

  export type ProductSizeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductSizeWhereInput | ProductSizeWhereInput[]
    OR?: ProductSizeWhereInput[]
    NOT?: ProductSizeWhereInput | ProductSizeWhereInput[]
    productId?: IntNullableFilter<"ProductSize"> | number | null
    size?: EnumSizeNullableFilter<"ProductSize"> | $Enums.Size | null
    quantity?: IntNullableFilter<"ProductSize"> | number | null
    createdAt?: DateTimeNullableFilter<"ProductSize"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ProductSize"> | Date | string | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    ShopCart?: ShopCartListRelationFilter
  }, "id">

  export type ProductSizeOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ProductSizeCountOrderByAggregateInput
    _avg?: ProductSizeAvgOrderByAggregateInput
    _max?: ProductSizeMaxOrderByAggregateInput
    _min?: ProductSizeMinOrderByAggregateInput
    _sum?: ProductSizeSumOrderByAggregateInput
  }

  export type ProductSizeScalarWhereWithAggregatesInput = {
    AND?: ProductSizeScalarWhereWithAggregatesInput | ProductSizeScalarWhereWithAggregatesInput[]
    OR?: ProductSizeScalarWhereWithAggregatesInput[]
    NOT?: ProductSizeScalarWhereWithAggregatesInput | ProductSizeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductSize"> | number
    productId?: IntNullableWithAggregatesFilter<"ProductSize"> | number | null
    size?: EnumSizeNullableWithAggregatesFilter<"ProductSize"> | $Enums.Size | null
    quantity?: IntNullableWithAggregatesFilter<"ProductSize"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"ProductSize"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ProductSize"> | Date | string | null
  }

  export type ProductImageWhereInput = {
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    id?: IntFilter<"ProductImage"> | number
    productId?: IntNullableFilter<"ProductImage"> | number | null
    image_url?: StringNullableFilter<"ProductImage"> | string | null
    createdAt?: DateTimeNullableFilter<"ProductImage"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ProductImage"> | Date | string | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }

  export type ProductImageOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    productId?: IntNullableFilter<"ProductImage"> | number | null
    image_url?: StringNullableFilter<"ProductImage"> | string | null
    createdAt?: DateTimeNullableFilter<"ProductImage"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ProductImage"> | Date | string | null
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
  }, "id">

  export type ProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ProductImageCountOrderByAggregateInput
    _avg?: ProductImageAvgOrderByAggregateInput
    _max?: ProductImageMaxOrderByAggregateInput
    _min?: ProductImageMinOrderByAggregateInput
    _sum?: ProductImageSumOrderByAggregateInput
  }

  export type ProductImageScalarWhereWithAggregatesInput = {
    AND?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    OR?: ProductImageScalarWhereWithAggregatesInput[]
    NOT?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductImage"> | number
    productId?: IntNullableWithAggregatesFilter<"ProductImage"> | number | null
    image_url?: StringNullableWithAggregatesFilter<"ProductImage"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"ProductImage"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ProductImage"> | Date | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringNullableFilter<"Product"> | string | null
    contentHTML?: StringNullableFilter<"Product"> | string | null
    contentMarkdown?: StringNullableFilter<"Product"> | string | null
    status?: EnumStatusNullableFilter<"Product"> | $Enums.Status | null
    categoryId?: IntNullableFilter<"Product"> | number | null
    view?: IntNullableFilter<"Product"> | number | null
    material?: StringNullableFilter<"Product"> | string | null
    brandId?: IntNullableFilter<"Product"> | number | null
    originalPrice?: IntNullableFilter<"Product"> | number | null
    discountPrice?: IntNullableFilter<"Product"> | number | null
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    brand?: XOR<BrandNullableRelationFilter, BrandWhereInput> | null
    Comment?: CommentListRelationFilter
    OrderDetaill?: OrderDetaillListRelationFilter
    ProductSize?: ProductSizeListRelationFilter
    ProductImage?: ProductImageListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    contentHTML?: SortOrderInput | SortOrder
    contentMarkdown?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    view?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    originalPrice?: SortOrderInput | SortOrder
    discountPrice?: SortOrderInput | SortOrder
    category?: CategoryOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    Comment?: CommentOrderByRelationAggregateInput
    OrderDetaill?: OrderDetaillOrderByRelationAggregateInput
    ProductSize?: ProductSizeOrderByRelationAggregateInput
    ProductImage?: ProductImageOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringNullableFilter<"Product"> | string | null
    contentHTML?: StringNullableFilter<"Product"> | string | null
    contentMarkdown?: StringNullableFilter<"Product"> | string | null
    status?: EnumStatusNullableFilter<"Product"> | $Enums.Status | null
    categoryId?: IntNullableFilter<"Product"> | number | null
    view?: IntNullableFilter<"Product"> | number | null
    material?: StringNullableFilter<"Product"> | string | null
    brandId?: IntNullableFilter<"Product"> | number | null
    originalPrice?: IntNullableFilter<"Product"> | number | null
    discountPrice?: IntNullableFilter<"Product"> | number | null
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    brand?: XOR<BrandNullableRelationFilter, BrandWhereInput> | null
    Comment?: CommentListRelationFilter
    OrderDetaill?: OrderDetaillListRelationFilter
    ProductSize?: ProductSizeListRelationFilter
    ProductImage?: ProductImageListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    contentHTML?: SortOrderInput | SortOrder
    contentMarkdown?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    view?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    originalPrice?: SortOrderInput | SortOrder
    discountPrice?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringNullableWithAggregatesFilter<"Product"> | string | null
    contentHTML?: StringNullableWithAggregatesFilter<"Product"> | string | null
    contentMarkdown?: StringNullableWithAggregatesFilter<"Product"> | string | null
    status?: EnumStatusNullableWithAggregatesFilter<"Product"> | $Enums.Status | null
    categoryId?: IntNullableWithAggregatesFilter<"Product"> | number | null
    view?: IntNullableWithAggregatesFilter<"Product"> | number | null
    material?: StringNullableWithAggregatesFilter<"Product"> | string | null
    brandId?: IntNullableWithAggregatesFilter<"Product"> | number | null
    originalPrice?: IntNullableWithAggregatesFilter<"Product"> | number | null
    discountPrice?: IntNullableWithAggregatesFilter<"Product"> | number | null
  }

  export type RoomMessageWhereInput = {
    AND?: RoomMessageWhereInput | RoomMessageWhereInput[]
    OR?: RoomMessageWhereInput[]
    NOT?: RoomMessageWhereInput | RoomMessageWhereInput[]
    id?: IntFilter<"RoomMessage"> | number
    createdAt?: DateTimeNullableFilter<"RoomMessage"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RoomMessage"> | Date | string | null
    userOneId?: IntNullableFilter<"RoomMessage"> | number | null
    userTwoId?: IntNullableFilter<"RoomMessage"> | number | null
    userOne?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    userTwo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    messages?: MessageListRelationFilter
  }

  export type RoomMessageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userOneId?: SortOrderInput | SortOrder
    userTwoId?: SortOrderInput | SortOrder
    userOne?: UserOrderByWithRelationInput
    userTwo?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type RoomMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomMessageWhereInput | RoomMessageWhereInput[]
    OR?: RoomMessageWhereInput[]
    NOT?: RoomMessageWhereInput | RoomMessageWhereInput[]
    createdAt?: DateTimeNullableFilter<"RoomMessage"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RoomMessage"> | Date | string | null
    userOneId?: IntNullableFilter<"RoomMessage"> | number | null
    userTwoId?: IntNullableFilter<"RoomMessage"> | number | null
    userOne?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    userTwo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    messages?: MessageListRelationFilter
  }, "id">

  export type RoomMessageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userOneId?: SortOrderInput | SortOrder
    userTwoId?: SortOrderInput | SortOrder
    _count?: RoomMessageCountOrderByAggregateInput
    _avg?: RoomMessageAvgOrderByAggregateInput
    _max?: RoomMessageMaxOrderByAggregateInput
    _min?: RoomMessageMinOrderByAggregateInput
    _sum?: RoomMessageSumOrderByAggregateInput
  }

  export type RoomMessageScalarWhereWithAggregatesInput = {
    AND?: RoomMessageScalarWhereWithAggregatesInput | RoomMessageScalarWhereWithAggregatesInput[]
    OR?: RoomMessageScalarWhereWithAggregatesInput[]
    NOT?: RoomMessageScalarWhereWithAggregatesInput | RoomMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoomMessage"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RoomMessage"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RoomMessage"> | Date | string | null
    userOneId?: IntNullableWithAggregatesFilter<"RoomMessage"> | number | null
    userTwoId?: IntNullableWithAggregatesFilter<"RoomMessage"> | number | null
  }

  export type ShopCartWhereInput = {
    AND?: ShopCartWhereInput | ShopCartWhereInput[]
    OR?: ShopCartWhereInput[]
    NOT?: ShopCartWhereInput | ShopCartWhereInput[]
    id?: IntFilter<"ShopCart"> | number
    userId?: IntNullableFilter<"ShopCart"> | number | null
    productSizeId?: IntNullableFilter<"ShopCart"> | number | null
    quantity?: IntNullableFilter<"ShopCart"> | number | null
    createdAt?: DateTimeNullableFilter<"ShopCart"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ShopCart"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    productSize?: XOR<ProductSizeNullableRelationFilter, ProductSizeWhereInput> | null
  }

  export type ShopCartOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    productSizeId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    productSize?: ProductSizeOrderByWithRelationInput
  }

  export type ShopCartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_productSizeId?: ShopCartUserIdProductSizeIdCompoundUniqueInput
    AND?: ShopCartWhereInput | ShopCartWhereInput[]
    OR?: ShopCartWhereInput[]
    NOT?: ShopCartWhereInput | ShopCartWhereInput[]
    userId?: IntNullableFilter<"ShopCart"> | number | null
    productSizeId?: IntNullableFilter<"ShopCart"> | number | null
    quantity?: IntNullableFilter<"ShopCart"> | number | null
    createdAt?: DateTimeNullableFilter<"ShopCart"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ShopCart"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    productSize?: XOR<ProductSizeNullableRelationFilter, ProductSizeWhereInput> | null
  }, "id" | "userId_productSizeId">

  export type ShopCartOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    productSizeId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ShopCartCountOrderByAggregateInput
    _avg?: ShopCartAvgOrderByAggregateInput
    _max?: ShopCartMaxOrderByAggregateInput
    _min?: ShopCartMinOrderByAggregateInput
    _sum?: ShopCartSumOrderByAggregateInput
  }

  export type ShopCartScalarWhereWithAggregatesInput = {
    AND?: ShopCartScalarWhereWithAggregatesInput | ShopCartScalarWhereWithAggregatesInput[]
    OR?: ShopCartScalarWhereWithAggregatesInput[]
    NOT?: ShopCartScalarWhereWithAggregatesInput | ShopCartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ShopCart"> | number
    userId?: IntNullableWithAggregatesFilter<"ShopCart"> | number | null
    productSizeId?: IntNullableWithAggregatesFilter<"ShopCart"> | number | null
    quantity?: IntNullableWithAggregatesFilter<"ShopCart"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"ShopCart"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ShopCart"> | Date | string | null
  }

  export type TypeShipWhereInput = {
    AND?: TypeShipWhereInput | TypeShipWhereInput[]
    OR?: TypeShipWhereInput[]
    NOT?: TypeShipWhereInput | TypeShipWhereInput[]
    id?: IntFilter<"TypeShip"> | number
    name?: StringFilter<"TypeShip"> | string
    price?: IntNullableFilter<"TypeShip"> | number | null
    createdAt?: DateTimeNullableFilter<"TypeShip"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"TypeShip"> | Date | string | null
    OrderProduct?: OrderProductListRelationFilter
  }

  export type TypeShipOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    OrderProduct?: OrderProductOrderByRelationAggregateInput
  }

  export type TypeShipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TypeShipWhereInput | TypeShipWhereInput[]
    OR?: TypeShipWhereInput[]
    NOT?: TypeShipWhereInput | TypeShipWhereInput[]
    price?: IntNullableFilter<"TypeShip"> | number | null
    createdAt?: DateTimeNullableFilter<"TypeShip"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"TypeShip"> | Date | string | null
    OrderProduct?: OrderProductListRelationFilter
  }, "id" | "name">

  export type TypeShipOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: TypeShipCountOrderByAggregateInput
    _avg?: TypeShipAvgOrderByAggregateInput
    _max?: TypeShipMaxOrderByAggregateInput
    _min?: TypeShipMinOrderByAggregateInput
    _sum?: TypeShipSumOrderByAggregateInput
  }

  export type TypeShipScalarWhereWithAggregatesInput = {
    AND?: TypeShipScalarWhereWithAggregatesInput | TypeShipScalarWhereWithAggregatesInput[]
    OR?: TypeShipScalarWhereWithAggregatesInput[]
    NOT?: TypeShipScalarWhereWithAggregatesInput | TypeShipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TypeShip"> | number
    name?: StringWithAggregatesFilter<"TypeShip"> | string
    price?: IntNullableWithAggregatesFilter<"TypeShip"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"TypeShip"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"TypeShip"> | Date | string | null
  }

  export type TypeVoucherWhereInput = {
    AND?: TypeVoucherWhereInput | TypeVoucherWhereInput[]
    OR?: TypeVoucherWhereInput[]
    NOT?: TypeVoucherWhereInput | TypeVoucherWhereInput[]
    id?: IntFilter<"TypeVoucher"> | number
    typeVoucher?: EnumDiscountNullableFilter<"TypeVoucher"> | $Enums.Discount | null
    value?: IntNullableFilter<"TypeVoucher"> | number | null
    maxValue?: IntNullableFilter<"TypeVoucher"> | number | null
    minValue?: IntNullableFilter<"TypeVoucher"> | number | null
    createdAt?: DateTimeNullableFilter<"TypeVoucher"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"TypeVoucher"> | Date | string | null
    Voucher?: VoucherListRelationFilter
  }

  export type TypeVoucherOrderByWithRelationInput = {
    id?: SortOrder
    typeVoucher?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    maxValue?: SortOrderInput | SortOrder
    minValue?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Voucher?: VoucherOrderByRelationAggregateInput
  }

  export type TypeVoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TypeVoucherWhereInput | TypeVoucherWhereInput[]
    OR?: TypeVoucherWhereInput[]
    NOT?: TypeVoucherWhereInput | TypeVoucherWhereInput[]
    typeVoucher?: EnumDiscountNullableFilter<"TypeVoucher"> | $Enums.Discount | null
    value?: IntNullableFilter<"TypeVoucher"> | number | null
    maxValue?: IntNullableFilter<"TypeVoucher"> | number | null
    minValue?: IntNullableFilter<"TypeVoucher"> | number | null
    createdAt?: DateTimeNullableFilter<"TypeVoucher"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"TypeVoucher"> | Date | string | null
    Voucher?: VoucherListRelationFilter
  }, "id">

  export type TypeVoucherOrderByWithAggregationInput = {
    id?: SortOrder
    typeVoucher?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    maxValue?: SortOrderInput | SortOrder
    minValue?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: TypeVoucherCountOrderByAggregateInput
    _avg?: TypeVoucherAvgOrderByAggregateInput
    _max?: TypeVoucherMaxOrderByAggregateInput
    _min?: TypeVoucherMinOrderByAggregateInput
    _sum?: TypeVoucherSumOrderByAggregateInput
  }

  export type TypeVoucherScalarWhereWithAggregatesInput = {
    AND?: TypeVoucherScalarWhereWithAggregatesInput | TypeVoucherScalarWhereWithAggregatesInput[]
    OR?: TypeVoucherScalarWhereWithAggregatesInput[]
    NOT?: TypeVoucherScalarWhereWithAggregatesInput | TypeVoucherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TypeVoucher"> | number
    typeVoucher?: EnumDiscountNullableWithAggregatesFilter<"TypeVoucher"> | $Enums.Discount | null
    value?: IntNullableWithAggregatesFilter<"TypeVoucher"> | number | null
    maxValue?: IntNullableWithAggregatesFilter<"TypeVoucher"> | number | null
    minValue?: IntNullableWithAggregatesFilter<"TypeVoucher"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"TypeVoucher"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"TypeVoucher"> | Date | string | null
  }

  export type VoucherWhereInput = {
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    id?: IntFilter<"Voucher"> | number
    fromDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    toDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    typeVoucherId?: IntNullableFilter<"Voucher"> | number | null
    amount?: IntNullableFilter<"Voucher"> | number | null
    codeVoucher?: StringNullableFilter<"Voucher"> | string | null
    createdAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    typeVoucher?: XOR<TypeVoucherNullableRelationFilter, TypeVoucherWhereInput> | null
    OrderProduct?: OrderProductListRelationFilter
    VoucherUsed?: VoucherUsedListRelationFilter
  }

  export type VoucherOrderByWithRelationInput = {
    id?: SortOrder
    fromDate?: SortOrderInput | SortOrder
    toDate?: SortOrderInput | SortOrder
    typeVoucherId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    codeVoucher?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    typeVoucher?: TypeVoucherOrderByWithRelationInput
    OrderProduct?: OrderProductOrderByRelationAggregateInput
    VoucherUsed?: VoucherUsedOrderByRelationAggregateInput
  }

  export type VoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    fromDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    toDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    typeVoucherId?: IntNullableFilter<"Voucher"> | number | null
    amount?: IntNullableFilter<"Voucher"> | number | null
    codeVoucher?: StringNullableFilter<"Voucher"> | string | null
    createdAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    typeVoucher?: XOR<TypeVoucherNullableRelationFilter, TypeVoucherWhereInput> | null
    OrderProduct?: OrderProductListRelationFilter
    VoucherUsed?: VoucherUsedListRelationFilter
  }, "id">

  export type VoucherOrderByWithAggregationInput = {
    id?: SortOrder
    fromDate?: SortOrderInput | SortOrder
    toDate?: SortOrderInput | SortOrder
    typeVoucherId?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    codeVoucher?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VoucherCountOrderByAggregateInput
    _avg?: VoucherAvgOrderByAggregateInput
    _max?: VoucherMaxOrderByAggregateInput
    _min?: VoucherMinOrderByAggregateInput
    _sum?: VoucherSumOrderByAggregateInput
  }

  export type VoucherScalarWhereWithAggregatesInput = {
    AND?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    OR?: VoucherScalarWhereWithAggregatesInput[]
    NOT?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Voucher"> | number
    fromDate?: DateTimeNullableWithAggregatesFilter<"Voucher"> | Date | string | null
    toDate?: DateTimeNullableWithAggregatesFilter<"Voucher"> | Date | string | null
    typeVoucherId?: IntNullableWithAggregatesFilter<"Voucher"> | number | null
    amount?: IntNullableWithAggregatesFilter<"Voucher"> | number | null
    codeVoucher?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Voucher"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Voucher"> | Date | string | null
  }

  export type VoucherUsedWhereInput = {
    AND?: VoucherUsedWhereInput | VoucherUsedWhereInput[]
    OR?: VoucherUsedWhereInput[]
    NOT?: VoucherUsedWhereInput | VoucherUsedWhereInput[]
    id?: IntFilter<"VoucherUsed"> | number
    userId?: IntNullableFilter<"VoucherUsed"> | number | null
    voucherId?: IntNullableFilter<"VoucherUsed"> | number | null
    createdAt?: DateTimeNullableFilter<"VoucherUsed"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"VoucherUsed"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    voucher?: XOR<VoucherNullableRelationFilter, VoucherWhereInput> | null
  }

  export type VoucherUsedOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    voucherId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    voucher?: VoucherOrderByWithRelationInput
  }

  export type VoucherUsedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VoucherUsedWhereInput | VoucherUsedWhereInput[]
    OR?: VoucherUsedWhereInput[]
    NOT?: VoucherUsedWhereInput | VoucherUsedWhereInput[]
    userId?: IntNullableFilter<"VoucherUsed"> | number | null
    voucherId?: IntNullableFilter<"VoucherUsed"> | number | null
    createdAt?: DateTimeNullableFilter<"VoucherUsed"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"VoucherUsed"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    voucher?: XOR<VoucherNullableRelationFilter, VoucherWhereInput> | null
  }, "id">

  export type VoucherUsedOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    voucherId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VoucherUsedCountOrderByAggregateInput
    _avg?: VoucherUsedAvgOrderByAggregateInput
    _max?: VoucherUsedMaxOrderByAggregateInput
    _min?: VoucherUsedMinOrderByAggregateInput
    _sum?: VoucherUsedSumOrderByAggregateInput
  }

  export type VoucherUsedScalarWhereWithAggregatesInput = {
    AND?: VoucherUsedScalarWhereWithAggregatesInput | VoucherUsedScalarWhereWithAggregatesInput[]
    OR?: VoucherUsedScalarWhereWithAggregatesInput[]
    NOT?: VoucherUsedScalarWhereWithAggregatesInput | VoucherUsedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VoucherUsed"> | number
    userId?: IntNullableWithAggregatesFilter<"VoucherUsed"> | number | null
    voucherId?: IntNullableWithAggregatesFilter<"VoucherUsed"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"VoucherUsed"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"VoucherUsed"> | Date | string | null
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: IntFilter<"Supplier"> | number
    name?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    phoneNumber?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeNullableFilter<"Supplier"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Supplier"> | Date | string | null
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    phoneNumber?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeNullableFilter<"Supplier"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Supplier"> | Date | string | null
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Supplier"> | number
    name?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Supplier"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Supplier"> | Date | string | null
  }

  export type ReceiptWhereInput = {
    AND?: ReceiptWhereInput | ReceiptWhereInput[]
    OR?: ReceiptWhereInput[]
    NOT?: ReceiptWhereInput | ReceiptWhereInput[]
    id?: IntFilter<"Receipt"> | number
    userId?: IntNullableFilter<"Receipt"> | number | null
    supplierId?: IntNullableFilter<"Receipt"> | number | null
    createdAt?: DateTimeNullableFilter<"Receipt"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Receipt"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ReceiptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReceiptWhereInput | ReceiptWhereInput[]
    OR?: ReceiptWhereInput[]
    NOT?: ReceiptWhereInput | ReceiptWhereInput[]
    userId?: IntNullableFilter<"Receipt"> | number | null
    supplierId?: IntNullableFilter<"Receipt"> | number | null
    createdAt?: DateTimeNullableFilter<"Receipt"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Receipt"> | Date | string | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    supplierId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ReceiptCountOrderByAggregateInput
    _avg?: ReceiptAvgOrderByAggregateInput
    _max?: ReceiptMaxOrderByAggregateInput
    _min?: ReceiptMinOrderByAggregateInput
    _sum?: ReceiptSumOrderByAggregateInput
  }

  export type ReceiptScalarWhereWithAggregatesInput = {
    AND?: ReceiptScalarWhereWithAggregatesInput | ReceiptScalarWhereWithAggregatesInput[]
    OR?: ReceiptScalarWhereWithAggregatesInput[]
    NOT?: ReceiptScalarWhereWithAggregatesInput | ReceiptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Receipt"> | number
    userId?: IntNullableWithAggregatesFilter<"Receipt"> | number | null
    supplierId?: IntNullableWithAggregatesFilter<"Receipt"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Receipt"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Receipt"> | Date | string | null
  }

  export type ReceiptDetailWhereInput = {
    AND?: ReceiptDetailWhereInput | ReceiptDetailWhereInput[]
    OR?: ReceiptDetailWhereInput[]
    NOT?: ReceiptDetailWhereInput | ReceiptDetailWhereInput[]
    id?: IntFilter<"ReceiptDetail"> | number
    receiptId?: IntNullableFilter<"ReceiptDetail"> | number | null
    productDetailSizeId?: IntNullableFilter<"ReceiptDetail"> | number | null
    quantity?: IntNullableFilter<"ReceiptDetail"> | number | null
    price?: IntNullableFilter<"ReceiptDetail"> | number | null
    createdAt?: DateTimeNullableFilter<"ReceiptDetail"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ReceiptDetail"> | Date | string | null
  }

  export type ReceiptDetailOrderByWithRelationInput = {
    id?: SortOrder
    receiptId?: SortOrderInput | SortOrder
    productDetailSizeId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type ReceiptDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReceiptDetailWhereInput | ReceiptDetailWhereInput[]
    OR?: ReceiptDetailWhereInput[]
    NOT?: ReceiptDetailWhereInput | ReceiptDetailWhereInput[]
    receiptId?: IntNullableFilter<"ReceiptDetail"> | number | null
    productDetailSizeId?: IntNullableFilter<"ReceiptDetail"> | number | null
    quantity?: IntNullableFilter<"ReceiptDetail"> | number | null
    price?: IntNullableFilter<"ReceiptDetail"> | number | null
    createdAt?: DateTimeNullableFilter<"ReceiptDetail"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ReceiptDetail"> | Date | string | null
  }, "id">

  export type ReceiptDetailOrderByWithAggregationInput = {
    id?: SortOrder
    receiptId?: SortOrderInput | SortOrder
    productDetailSizeId?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: ReceiptDetailCountOrderByAggregateInput
    _avg?: ReceiptDetailAvgOrderByAggregateInput
    _max?: ReceiptDetailMaxOrderByAggregateInput
    _min?: ReceiptDetailMinOrderByAggregateInput
    _sum?: ReceiptDetailSumOrderByAggregateInput
  }

  export type ReceiptDetailScalarWhereWithAggregatesInput = {
    AND?: ReceiptDetailScalarWhereWithAggregatesInput | ReceiptDetailScalarWhereWithAggregatesInput[]
    OR?: ReceiptDetailScalarWhereWithAggregatesInput[]
    NOT?: ReceiptDetailScalarWhereWithAggregatesInput | ReceiptDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReceiptDetail"> | number
    receiptId?: IntNullableWithAggregatesFilter<"ReceiptDetail"> | number | null
    productDetailSizeId?: IntNullableWithAggregatesFilter<"ReceiptDetail"> | number | null
    quantity?: IntNullableWithAggregatesFilter<"ReceiptDetail"> | number | null
    price?: IntNullableWithAggregatesFilter<"ReceiptDetail"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"ReceiptDetail"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ReceiptDetail"> | Date | string | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    brandId?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    brand?: XOR<BrandNullableRelationFilter, BrandWhereInput> | null
    Product?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    brand?: BrandOrderByWithRelationInput
    Product?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_brandId?: CategoryNameBrandIdCompoundUniqueInput
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    brandId?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    brand?: XOR<BrandNullableRelationFilter, BrandWhereInput> | null
    Product?: ProductListRelationFilter
  }, "id" | "name_brandId">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    brandId?: IntNullableWithAggregatesFilter<"Category"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: IntFilter<"Brand"> | number
    name?: StringFilter<"Brand"> | string
    createdAt?: DateTimeNullableFilter<"Brand"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Brand"> | Date | string | null
    Product?: ProductListRelationFilter
    Category?: CategoryListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Product?: ProductOrderByRelationAggregateInput
    Category?: CategoryOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    createdAt?: DateTimeNullableFilter<"Brand"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Brand"> | Date | string | null
    Product?: ProductListRelationFilter
    Category?: CategoryListRelationFilter
  }, "id" | "name">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: BrandCountOrderByAggregateInput
    _avg?: BrandAvgOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
    _sum?: BrandSumOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Brand"> | number
    name?: StringWithAggregatesFilter<"Brand"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Brand"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Brand"> | Date | string | null
  }

  export type UserCreateInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedManyWithoutUserInput
    blog?: BlogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserUncheckedCreateNestedManyWithoutUserInput
    blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartUncheckedCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageUncheckedCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageUncheckedCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateManyWithoutUserNestedInput
    blog?: BlogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUncheckedUpdateManyWithoutUserNestedInput
    blog?: BlogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUncheckedUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUncheckedUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUncheckedUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressUserCreateInput = {
    shipName?: string | null
    shipAdress?: string | null
    shipPhone?: string | null
    shipEmail?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAddressUserInput
    OrderProduct?: OrderProductCreateNestedManyWithoutAddressUserInput
  }

  export type AddressUserUncheckedCreateInput = {
    id?: number
    userId: number
    shipName?: string | null
    shipAdress?: string | null
    shipPhone?: string | null
    shipEmail?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutAddressUserInput
  }

  export type AddressUserUpdateInput = {
    shipName?: NullableStringFieldUpdateOperationsInput | string | null
    shipAdress?: NullableStringFieldUpdateOperationsInput | string | null
    shipPhone?: NullableStringFieldUpdateOperationsInput | string | null
    shipEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAddressUserNestedInput
    OrderProduct?: OrderProductUpdateManyWithoutAddressUserNestedInput
  }

  export type AddressUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    shipName?: NullableStringFieldUpdateOperationsInput | string | null
    shipAdress?: NullableStringFieldUpdateOperationsInput | string | null
    shipPhone?: NullableStringFieldUpdateOperationsInput | string | null
    shipEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutAddressUserNestedInput
  }

  export type AddressUserCreateManyInput = {
    id?: number
    userId: number
    shipName?: string | null
    shipAdress?: string | null
    shipPhone?: string | null
    shipEmail?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AddressUserUpdateManyMutationInput = {
    shipName?: NullableStringFieldUpdateOperationsInput | string | null
    shipAdress?: NullableStringFieldUpdateOperationsInput | string | null
    shipPhone?: NullableStringFieldUpdateOperationsInput | string | null
    shipEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    shipName?: NullableStringFieldUpdateOperationsInput | string | null
    shipAdress?: NullableStringFieldUpdateOperationsInput | string | null
    shipPhone?: NullableStringFieldUpdateOperationsInput | string | null
    shipEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerCreateInput = {
    description?: string | null
    name?: string | null
    status?: $Enums.Status | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BannerUncheckedCreateInput = {
    id?: number
    description?: string | null
    name?: string | null
    status?: $Enums.Status | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BannerUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerCreateManyInput = {
    id?: number
    description?: string | null
    name?: string | null
    status?: $Enums.Status | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BannerUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlogCreateInput = {
    title?: string | null
    subject?: $Enums.Subject | null
    status?: $Enums.Status | null
    image?: string | null
    contentMarkdown?: string | null
    contentHTML?: string | null
    view?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutBlogInput
    Comment?: CommentCreateNestedManyWithoutBlogInput
  }

  export type BlogUncheckedCreateInput = {
    id?: number
    title?: string | null
    subject?: $Enums.Subject | null
    status?: $Enums.Status | null
    image?: string | null
    contentMarkdown?: string | null
    contentHTML?: string | null
    userId?: number | null
    view?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Comment?: CommentUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableEnumSubjectFieldUpdateOperationsInput | $Enums.Subject | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutBlogNestedInput
    Comment?: CommentUpdateManyWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableEnumSubjectFieldUpdateOperationsInput | $Enums.Subject | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Comment?: CommentUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type BlogCreateManyInput = {
    id?: number
    title?: string | null
    subject?: $Enums.Subject | null
    status?: $Enums.Status | null
    image?: string | null
    contentMarkdown?: string | null
    contentHTML?: string | null
    userId?: number | null
    view?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BlogUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableEnumSubjectFieldUpdateOperationsInput | $Enums.Subject | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableEnumSubjectFieldUpdateOperationsInput | $Enums.Subject | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateInput = {
    content?: string | null
    image?: string | null
    parentId?: number | null
    star?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    product?: ProductCreateNestedOneWithoutCommentInput
    user?: UserCreateNestedOneWithoutCommentInput
    blog?: BlogCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    content?: string | null
    image?: string | null
    parentId?: number | null
    productId?: number | null
    userId?: number | null
    blogId?: number | null
    star?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CommentUpdateInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneWithoutCommentNestedInput
    user?: UserUpdateOneWithoutCommentNestedInput
    blog?: BlogUpdateOneWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    blogId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateManyInput = {
    id?: number
    content?: string | null
    image?: string | null
    parentId?: number | null
    productId?: number | null
    userId?: number | null
    blogId?: number | null
    star?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CommentUpdateManyMutationInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    blogId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    text?: string | null
    unRead?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutMessageInput
    room?: RoomMessageCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    text?: string | null
    userId?: number | null
    roomId?: number | null
    unRead?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MessageUpdateInput = {
    text?: NullableStringFieldUpdateOperationsInput | string | null
    unRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutMessageNestedInput
    room?: RoomMessageUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    unRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateManyInput = {
    id?: number
    text?: string | null
    userId?: number | null
    roomId?: number | null
    unRead?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MessageUpdateManyMutationInput = {
    text?: NullableStringFieldUpdateOperationsInput | string | null
    unRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    unRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderDetaillCreateInput = {
    quantity?: number | null
    realPrice?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    order?: OrderProductCreateNestedOneWithoutOrderDetaillInput
    product?: ProductCreateNestedOneWithoutOrderDetaillInput
  }

  export type OrderDetaillUncheckedCreateInput = {
    id?: number
    orderId?: number | null
    productId?: number | null
    quantity?: number | null
    realPrice?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderDetaillUpdateInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    realPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderProductUpdateOneWithoutOrderDetaillNestedInput
    product?: ProductUpdateOneWithoutOrderDetaillNestedInput
  }

  export type OrderDetaillUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    realPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderDetaillCreateManyInput = {
    id?: number
    orderId?: number | null
    productId?: number | null
    quantity?: number | null
    realPrice?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderDetaillUpdateManyMutationInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    realPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderDetaillUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    realPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderProductCreateInput = {
    status?: $Enums.Status | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedOneWithoutOrderProductInput
    typeShip?: TypeShipCreateNestedOneWithoutOrderProductInput
    voucher?: VoucherCreateNestedOneWithoutOrderProductInput
    OrderDetaill?: OrderDetaillCreateNestedManyWithoutOrderInput
  }

  export type OrderProductUncheckedCreateInput = {
    id?: number
    addressUserId?: number | null
    status?: $Enums.Status | null
    typeShipId?: number | null
    voucherId?: number | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderDetaill?: OrderDetaillUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderProductUpdateInput = {
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateOneWithoutOrderProductNestedInput
    typeShip?: TypeShipUpdateOneWithoutOrderProductNestedInput
    voucher?: VoucherUpdateOneWithoutOrderProductNestedInput
    OrderDetaill?: OrderDetaillUpdateManyWithoutOrderNestedInput
  }

  export type OrderProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    typeShipId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderDetaill?: OrderDetaillUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderProductCreateManyInput = {
    id?: number
    addressUserId?: number | null
    status?: $Enums.Status | null
    typeShipId?: number | null
    voucherId?: number | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderProductUpdateManyMutationInput = {
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    typeShipId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductSizeCreateInput = {
    size?: $Enums.Size | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    product?: ProductCreateNestedOneWithoutProductSizeInput
    ShopCart?: ShopCartCreateNestedManyWithoutProductSizeInput
  }

  export type ProductSizeUncheckedCreateInput = {
    id?: number
    productId?: number | null
    size?: $Enums.Size | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ShopCart?: ShopCartUncheckedCreateNestedManyWithoutProductSizeInput
  }

  export type ProductSizeUpdateInput = {
    size?: NullableEnumSizeFieldUpdateOperationsInput | $Enums.Size | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneWithoutProductSizeNestedInput
    ShopCart?: ShopCartUpdateManyWithoutProductSizeNestedInput
  }

  export type ProductSizeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableEnumSizeFieldUpdateOperationsInput | $Enums.Size | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShopCart?: ShopCartUncheckedUpdateManyWithoutProductSizeNestedInput
  }

  export type ProductSizeCreateManyInput = {
    id?: number
    productId?: number | null
    size?: $Enums.Size | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductSizeUpdateManyMutationInput = {
    size?: NullableEnumSizeFieldUpdateOperationsInput | $Enums.Size | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductSizeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableEnumSizeFieldUpdateOperationsInput | $Enums.Size | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductImageCreateInput = {
    image_url?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    product?: ProductCreateNestedOneWithoutProductImageInput
  }

  export type ProductImageUncheckedCreateInput = {
    id?: number
    productId?: number | null
    image_url?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductImageUpdateInput = {
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneWithoutProductImageNestedInput
  }

  export type ProductImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductImageCreateManyInput = {
    id?: number
    productId?: number | null
    image_url?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductImageUpdateManyMutationInput = {
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateInput = {
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    view?: number | null
    material?: string | null
    originalPrice?: number | null
    discountPrice?: number | null
    category?: CategoryCreateNestedOneWithoutProductInput
    brand?: BrandCreateNestedOneWithoutProductInput
    Comment?: CommentCreateNestedManyWithoutProductInput
    OrderDetaill?: OrderDetaillCreateNestedManyWithoutProductInput
    ProductSize?: ProductSizeCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    categoryId?: number | null
    view?: number | null
    material?: string | null
    brandId?: number | null
    originalPrice?: number | null
    discountPrice?: number | null
    Comment?: CommentUncheckedCreateNestedManyWithoutProductInput
    OrderDetaill?: OrderDetaillUncheckedCreateNestedManyWithoutProductInput
    ProductSize?: ProductSizeUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    category?: CategoryUpdateOneWithoutProductNestedInput
    brand?: BrandUpdateOneWithoutProductNestedInput
    Comment?: CommentUpdateManyWithoutProductNestedInput
    OrderDetaill?: OrderDetaillUpdateManyWithoutProductNestedInput
    ProductSize?: ProductSizeUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    Comment?: CommentUncheckedUpdateManyWithoutProductNestedInput
    OrderDetaill?: OrderDetaillUncheckedUpdateManyWithoutProductNestedInput
    ProductSize?: ProductSizeUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    categoryId?: number | null
    view?: number | null
    material?: string | null
    brandId?: number | null
    originalPrice?: number | null
    discountPrice?: number | null
  }

  export type ProductUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomMessageCreateInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userOne?: UserCreateNestedOneWithoutRoomMessagesOneInput
    userTwo?: UserCreateNestedOneWithoutRoomMessagesTwoInput
    messages?: MessageCreateNestedManyWithoutRoomInput
  }

  export type RoomMessageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userOneId?: number | null
    userTwoId?: number | null
    messages?: MessageUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomMessageUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userOne?: UserUpdateOneWithoutRoomMessagesOneNestedInput
    userTwo?: UserUpdateOneWithoutRoomMessagesTwoNestedInput
    messages?: MessageUpdateManyWithoutRoomNestedInput
  }

  export type RoomMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userOneId?: NullableIntFieldUpdateOperationsInput | number | null
    userTwoId?: NullableIntFieldUpdateOperationsInput | number | null
    messages?: MessageUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomMessageCreateManyInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userOneId?: number | null
    userTwoId?: number | null
  }

  export type RoomMessageUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoomMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userOneId?: NullableIntFieldUpdateOperationsInput | number | null
    userTwoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ShopCartCreateInput = {
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutShopCartInput
    productSize?: ProductSizeCreateNestedOneWithoutShopCartInput
  }

  export type ShopCartUncheckedCreateInput = {
    id?: number
    userId?: number | null
    productSizeId?: number | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ShopCartUpdateInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutShopCartNestedInput
    productSize?: ProductSizeUpdateOneWithoutShopCartNestedInput
  }

  export type ShopCartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    productSizeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShopCartCreateManyInput = {
    id?: number
    userId?: number | null
    productSizeId?: number | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ShopCartUpdateManyMutationInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShopCartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    productSizeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypeShipCreateInput = {
    name: string
    price?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderProduct?: OrderProductCreateNestedManyWithoutTypeShipInput
  }

  export type TypeShipUncheckedCreateInput = {
    id?: number
    name: string
    price?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutTypeShipInput
  }

  export type TypeShipUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderProduct?: OrderProductUpdateManyWithoutTypeShipNestedInput
  }

  export type TypeShipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutTypeShipNestedInput
  }

  export type TypeShipCreateManyInput = {
    id?: number
    name: string
    price?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TypeShipUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypeShipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypeVoucherCreateInput = {
    typeVoucher?: $Enums.Discount | null
    value?: number | null
    maxValue?: number | null
    minValue?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Voucher?: VoucherCreateNestedManyWithoutTypeVoucherInput
  }

  export type TypeVoucherUncheckedCreateInput = {
    id?: number
    typeVoucher?: $Enums.Discount | null
    value?: number | null
    maxValue?: number | null
    minValue?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Voucher?: VoucherUncheckedCreateNestedManyWithoutTypeVoucherInput
  }

  export type TypeVoucherUpdateInput = {
    typeVoucher?: NullableEnumDiscountFieldUpdateOperationsInput | $Enums.Discount | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Voucher?: VoucherUpdateManyWithoutTypeVoucherNestedInput
  }

  export type TypeVoucherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeVoucher?: NullableEnumDiscountFieldUpdateOperationsInput | $Enums.Discount | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Voucher?: VoucherUncheckedUpdateManyWithoutTypeVoucherNestedInput
  }

  export type TypeVoucherCreateManyInput = {
    id?: number
    typeVoucher?: $Enums.Discount | null
    value?: number | null
    maxValue?: number | null
    minValue?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TypeVoucherUpdateManyMutationInput = {
    typeVoucher?: NullableEnumDiscountFieldUpdateOperationsInput | $Enums.Discount | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypeVoucherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeVoucher?: NullableEnumDiscountFieldUpdateOperationsInput | $Enums.Discount | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherCreateInput = {
    fromDate?: Date | string | null
    toDate?: Date | string | null
    amount?: number | null
    codeVoucher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    typeVoucher?: TypeVoucherCreateNestedOneWithoutVoucherInput
    OrderProduct?: OrderProductCreateNestedManyWithoutVoucherInput
    VoucherUsed?: VoucherUsedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateInput = {
    id?: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    typeVoucherId?: number | null
    amount?: number | null
    codeVoucher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutVoucherInput
    VoucherUsed?: VoucherUsedUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUpdateInput = {
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    codeVoucher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typeVoucher?: TypeVoucherUpdateOneWithoutVoucherNestedInput
    OrderProduct?: OrderProductUpdateManyWithoutVoucherNestedInput
    VoucherUsed?: VoucherUsedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    codeVoucher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutVoucherNestedInput
    VoucherUsed?: VoucherUsedUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherCreateManyInput = {
    id?: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    typeVoucherId?: number | null
    amount?: number | null
    codeVoucher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VoucherUpdateManyMutationInput = {
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    codeVoucher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    codeVoucher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUsedCreateInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutVoucherUsedInput
    voucher?: VoucherCreateNestedOneWithoutVoucherUsedInput
  }

  export type VoucherUsedUncheckedCreateInput = {
    id?: number
    userId?: number | null
    voucherId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VoucherUsedUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutVoucherUsedNestedInput
    voucher?: VoucherUpdateOneWithoutVoucherUsedNestedInput
  }

  export type VoucherUsedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUsedCreateManyInput = {
    id?: number
    userId?: number | null
    voucherId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VoucherUsedUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUsedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupplierCreateInput = {
    name?: string | null
    address?: string | null
    phoneNumber?: string | null
    email?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SupplierUncheckedCreateInput = {
    id?: number
    name?: string | null
    address?: string | null
    phoneNumber?: string | null
    email?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SupplierUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupplierCreateManyInput = {
    id?: number
    name?: string | null
    address?: string | null
    phoneNumber?: string | null
    email?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SupplierUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiptCreateInput = {
    supplierId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutReceiptInput
  }

  export type ReceiptUncheckedCreateInput = {
    id?: number
    userId?: number | null
    supplierId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiptUpdateInput = {
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutReceiptNestedInput
  }

  export type ReceiptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiptCreateManyInput = {
    id?: number
    userId?: number | null
    supplierId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiptUpdateManyMutationInput = {
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiptDetailCreateInput = {
    receiptId?: number | null
    productDetailSizeId?: number | null
    quantity?: number | null
    price?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiptDetailUncheckedCreateInput = {
    id?: number
    receiptId?: number | null
    productDetailSizeId?: number | null
    quantity?: number | null
    price?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiptDetailUpdateInput = {
    receiptId?: NullableIntFieldUpdateOperationsInput | number | null
    productDetailSizeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiptDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptId?: NullableIntFieldUpdateOperationsInput | number | null
    productDetailSizeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiptDetailCreateManyInput = {
    id?: number
    receiptId?: number | null
    productDetailSizeId?: number | null
    quantity?: number | null
    price?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiptDetailUpdateManyMutationInput = {
    receiptId?: NullableIntFieldUpdateOperationsInput | number | null
    productDetailSizeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiptDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiptId?: NullableIntFieldUpdateOperationsInput | number | null
    productDetailSizeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryCreateInput = {
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    brand?: BrandCreateNestedOneWithoutCategoryInput
    Product?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    brandId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Product?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: BrandUpdateOneWithoutCategoryNestedInput
    Product?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Product?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    brandId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BrandCreateInput = {
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Product?: ProductCreateNestedManyWithoutBrandInput
    Category?: CategoryCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Product?: ProductUncheckedCreateNestedManyWithoutBrandInput
    Category?: CategoryUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Product?: ProductUpdateManyWithoutBrandNestedInput
    Category?: CategoryUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Product?: ProductUncheckedUpdateManyWithoutBrandNestedInput
    Category?: CategoryUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BrandUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusNullableFilter<$PrismaModel> | $Enums.Status | null
  }

  export type AddressUserListRelationFilter = {
    every?: AddressUserWhereInput
    some?: AddressUserWhereInput
    none?: AddressUserWhereInput
  }

  export type BlogListRelationFilter = {
    every?: BlogWhereInput
    some?: BlogWhereInput
    none?: BlogWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ShopCartListRelationFilter = {
    every?: ShopCartWhereInput
    some?: ShopCartWhereInput
    none?: ShopCartWhereInput
  }

  export type RoomMessageListRelationFilter = {
    every?: RoomMessageWhereInput
    some?: RoomMessageWhereInput
    none?: RoomMessageWhereInput
  }

  export type ReceiptListRelationFilter = {
    every?: ReceiptWhereInput
    some?: ReceiptWhereInput
    none?: ReceiptWhereInput
  }

  export type VoucherUsedListRelationFilter = {
    every?: VoucherUsedWhereInput
    some?: VoucherUsedWhereInput
    none?: VoucherUsedWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AddressUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopCartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoucherUsedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    phoneNumber?: SortOrder
    image?: SortOrder
    dob?: SortOrder
    isActiveEmail?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    userToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    phoneNumber?: SortOrder
    image?: SortOrder
    dob?: SortOrder
    isActiveEmail?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    userToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    phoneNumber?: SortOrder
    image?: SortOrder
    dob?: SortOrder
    isActiveEmail?: SortOrder
    roleId?: SortOrder
    status?: SortOrder
    userToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.Status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumStatusNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OrderProductListRelationFilter = {
    every?: OrderProductWhereInput
    some?: OrderProductWhereInput
    none?: OrderProductWhereInput
  }

  export type OrderProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    shipName?: SortOrder
    shipAdress?: SortOrder
    shipPhone?: SortOrder
    shipEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressUserAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AddressUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    shipName?: SortOrder
    shipAdress?: SortOrder
    shipPhone?: SortOrder
    shipEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    shipName?: SortOrder
    shipAdress?: SortOrder
    shipPhone?: SortOrder
    shipEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressUserSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BannerCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    name?: SortOrder
    status?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BannerMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    name?: SortOrder
    status?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    name?: SortOrder
    status?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumSubjectNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Subject | EnumSubjectFieldRefInput<$PrismaModel> | null
    in?: $Enums.Subject[] | ListEnumSubjectFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Subject[] | ListEnumSubjectFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubjectNullableFilter<$PrismaModel> | $Enums.Subject | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BlogCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    image?: SortOrder
    contentMarkdown?: SortOrder
    contentHTML?: SortOrder
    userId?: SortOrder
    view?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    view?: SortOrder
  }

  export type BlogMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    image?: SortOrder
    contentMarkdown?: SortOrder
    contentHTML?: SortOrder
    userId?: SortOrder
    view?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    image?: SortOrder
    contentMarkdown?: SortOrder
    contentHTML?: SortOrder
    userId?: SortOrder
    view?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    view?: SortOrder
  }

  export type EnumSubjectNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Subject | EnumSubjectFieldRefInput<$PrismaModel> | null
    in?: $Enums.Subject[] | ListEnumSubjectFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Subject[] | ListEnumSubjectFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubjectNullableWithAggregatesFilter<$PrismaModel> | $Enums.Subject | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubjectNullableFilter<$PrismaModel>
    _max?: NestedEnumSubjectNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProductNullableRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type BlogNullableRelationFilter = {
    is?: BlogWhereInput | null
    isNot?: BlogWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    image?: SortOrder
    parentId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    blogId?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    blogId?: SortOrder
    star?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    image?: SortOrder
    parentId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    blogId?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    image?: SortOrder
    parentId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    blogId?: SortOrder
    star?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    blogId?: SortOrder
    star?: SortOrder
  }

  export type RoomMessageNullableRelationFilter = {
    is?: RoomMessageWhereInput | null
    isNot?: RoomMessageWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    unRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    unRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
    unRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
  }

  export type OrderProductNullableRelationFilter = {
    is?: OrderProductWhereInput | null
    isNot?: OrderProductWhereInput | null
  }

  export type OrderDetaillCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    realPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderDetaillAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    realPrice?: SortOrder
  }

  export type OrderDetaillMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    realPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderDetaillMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    realPrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderDetaillSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    realPrice?: SortOrder
  }

  export type AddressUserNullableRelationFilter = {
    is?: AddressUserWhereInput | null
    isNot?: AddressUserWhereInput | null
  }

  export type TypeShipNullableRelationFilter = {
    is?: TypeShipWhereInput | null
    isNot?: TypeShipWhereInput | null
  }

  export type VoucherNullableRelationFilter = {
    is?: VoucherWhereInput | null
    isNot?: VoucherWhereInput | null
  }

  export type OrderDetaillListRelationFilter = {
    every?: OrderDetaillWhereInput
    some?: OrderDetaillWhereInput
    none?: OrderDetaillWhereInput
  }

  export type OrderDetaillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderProductCountOrderByAggregateInput = {
    id?: SortOrder
    addressUserId?: SortOrder
    status?: SortOrder
    typeShipId?: SortOrder
    voucherId?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderProductAvgOrderByAggregateInput = {
    id?: SortOrder
    addressUserId?: SortOrder
    typeShipId?: SortOrder
    voucherId?: SortOrder
  }

  export type OrderProductMaxOrderByAggregateInput = {
    id?: SortOrder
    addressUserId?: SortOrder
    status?: SortOrder
    typeShipId?: SortOrder
    voucherId?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderProductMinOrderByAggregateInput = {
    id?: SortOrder
    addressUserId?: SortOrder
    status?: SortOrder
    typeShipId?: SortOrder
    voucherId?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderProductSumOrderByAggregateInput = {
    id?: SortOrder
    addressUserId?: SortOrder
    typeShipId?: SortOrder
    voucherId?: SortOrder
  }

  export type EnumSizeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSizeNullableFilter<$PrismaModel> | $Enums.Size | null
  }

  export type ProductSizeCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    size?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSizeAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductSizeMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    size?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSizeMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    size?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSizeSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type EnumSizeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSizeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Size | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSizeNullableFilter<$PrismaModel>
    _max?: NestedEnumSizeNullableFilter<$PrismaModel>
  }

  export type ProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    image_url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type ProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    image_url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    image_url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type BrandNullableRelationFilter = {
    is?: BrandWhereInput | null
    isNot?: BrandWhereInput | null
  }

  export type ProductSizeListRelationFilter = {
    every?: ProductSizeWhereInput
    some?: ProductSizeWhereInput
    none?: ProductSizeWhereInput
  }

  export type ProductImageListRelationFilter = {
    every?: ProductImageWhereInput
    some?: ProductImageWhereInput
    none?: ProductImageWhereInput
  }

  export type ProductSizeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contentHTML?: SortOrder
    contentMarkdown?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    view?: SortOrder
    material?: SortOrder
    brandId?: SortOrder
    originalPrice?: SortOrder
    discountPrice?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    view?: SortOrder
    brandId?: SortOrder
    originalPrice?: SortOrder
    discountPrice?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contentHTML?: SortOrder
    contentMarkdown?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    view?: SortOrder
    material?: SortOrder
    brandId?: SortOrder
    originalPrice?: SortOrder
    discountPrice?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contentHTML?: SortOrder
    contentMarkdown?: SortOrder
    status?: SortOrder
    categoryId?: SortOrder
    view?: SortOrder
    material?: SortOrder
    brandId?: SortOrder
    originalPrice?: SortOrder
    discountPrice?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    view?: SortOrder
    brandId?: SortOrder
    originalPrice?: SortOrder
    discountPrice?: SortOrder
  }

  export type RoomMessageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userOneId?: SortOrder
    userTwoId?: SortOrder
  }

  export type RoomMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    userOneId?: SortOrder
    userTwoId?: SortOrder
  }

  export type RoomMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userOneId?: SortOrder
    userTwoId?: SortOrder
  }

  export type RoomMessageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userOneId?: SortOrder
    userTwoId?: SortOrder
  }

  export type RoomMessageSumOrderByAggregateInput = {
    id?: SortOrder
    userOneId?: SortOrder
    userTwoId?: SortOrder
  }

  export type ProductSizeNullableRelationFilter = {
    is?: ProductSizeWhereInput | null
    isNot?: ProductSizeWhereInput | null
  }

  export type ShopCartUserIdProductSizeIdCompoundUniqueInput = {
    userId: number
    productSizeId: number
  }

  export type ShopCartCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productSizeId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopCartAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productSizeId?: SortOrder
    quantity?: SortOrder
  }

  export type ShopCartMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productSizeId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopCartMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productSizeId?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShopCartSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productSizeId?: SortOrder
    quantity?: SortOrder
  }

  export type TypeShipCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeShipAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type TypeShipMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeShipMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeShipSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type EnumDiscountNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Discount | EnumDiscountFieldRefInput<$PrismaModel> | null
    in?: $Enums.Discount[] | ListEnumDiscountFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Discount[] | ListEnumDiscountFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDiscountNullableFilter<$PrismaModel> | $Enums.Discount | null
  }

  export type VoucherListRelationFilter = {
    every?: VoucherWhereInput
    some?: VoucherWhereInput
    none?: VoucherWhereInput
  }

  export type VoucherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TypeVoucherCountOrderByAggregateInput = {
    id?: SortOrder
    typeVoucher?: SortOrder
    value?: SortOrder
    maxValue?: SortOrder
    minValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeVoucherAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    maxValue?: SortOrder
    minValue?: SortOrder
  }

  export type TypeVoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    typeVoucher?: SortOrder
    value?: SortOrder
    maxValue?: SortOrder
    minValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeVoucherMinOrderByAggregateInput = {
    id?: SortOrder
    typeVoucher?: SortOrder
    value?: SortOrder
    maxValue?: SortOrder
    minValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeVoucherSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    maxValue?: SortOrder
    minValue?: SortOrder
  }

  export type EnumDiscountNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Discount | EnumDiscountFieldRefInput<$PrismaModel> | null
    in?: $Enums.Discount[] | ListEnumDiscountFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Discount[] | ListEnumDiscountFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDiscountNullableWithAggregatesFilter<$PrismaModel> | $Enums.Discount | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDiscountNullableFilter<$PrismaModel>
    _max?: NestedEnumDiscountNullableFilter<$PrismaModel>
  }

  export type TypeVoucherNullableRelationFilter = {
    is?: TypeVoucherWhereInput | null
    isNot?: TypeVoucherWhereInput | null
  }

  export type VoucherCountOrderByAggregateInput = {
    id?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    typeVoucherId?: SortOrder
    amount?: SortOrder
    codeVoucher?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherAvgOrderByAggregateInput = {
    id?: SortOrder
    typeVoucherId?: SortOrder
    amount?: SortOrder
  }

  export type VoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    typeVoucherId?: SortOrder
    amount?: SortOrder
    codeVoucher?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherMinOrderByAggregateInput = {
    id?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    typeVoucherId?: SortOrder
    amount?: SortOrder
    codeVoucher?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherSumOrderByAggregateInput = {
    id?: SortOrder
    typeVoucherId?: SortOrder
    amount?: SortOrder
  }

  export type VoucherUsedCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    voucherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherUsedAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    voucherId?: SortOrder
  }

  export type VoucherUsedMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    voucherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherUsedMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    voucherId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherUsedSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    voucherId?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    supplierId?: SortOrder
  }

  export type ReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    supplierId?: SortOrder
  }

  export type ReceiptDetailCountOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    productDetailSizeId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    productDetailSizeId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ReceiptDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    productDetailSizeId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptDetailMinOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    productDetailSizeId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiptDetailSumOrderByAggregateInput = {
    id?: SortOrder
    receiptId?: SortOrder
    productDetailSizeId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryNameBrandIdCompoundUniqueInput = {
    name: string
    brandId: number
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AddressUserCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressUserCreateWithoutUserInput, AddressUserUncheckedCreateWithoutUserInput> | AddressUserCreateWithoutUserInput[] | AddressUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressUserCreateOrConnectWithoutUserInput | AddressUserCreateOrConnectWithoutUserInput[]
    createMany?: AddressUserCreateManyUserInputEnvelope
    connect?: AddressUserWhereUniqueInput | AddressUserWhereUniqueInput[]
  }

  export type BlogCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput> | BlogCreateWithoutUserInput[] | BlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutUserInput | BlogCreateOrConnectWithoutUserInput[]
    createMany?: BlogCreateManyUserInputEnvelope
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ShopCartCreateNestedManyWithoutUserInput = {
    create?: XOR<ShopCartCreateWithoutUserInput, ShopCartUncheckedCreateWithoutUserInput> | ShopCartCreateWithoutUserInput[] | ShopCartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopCartCreateOrConnectWithoutUserInput | ShopCartCreateOrConnectWithoutUserInput[]
    createMany?: ShopCartCreateManyUserInputEnvelope
    connect?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
  }

  export type RoomMessageCreateNestedManyWithoutUserOneInput = {
    create?: XOR<RoomMessageCreateWithoutUserOneInput, RoomMessageUncheckedCreateWithoutUserOneInput> | RoomMessageCreateWithoutUserOneInput[] | RoomMessageUncheckedCreateWithoutUserOneInput[]
    connectOrCreate?: RoomMessageCreateOrConnectWithoutUserOneInput | RoomMessageCreateOrConnectWithoutUserOneInput[]
    createMany?: RoomMessageCreateManyUserOneInputEnvelope
    connect?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
  }

  export type RoomMessageCreateNestedManyWithoutUserTwoInput = {
    create?: XOR<RoomMessageCreateWithoutUserTwoInput, RoomMessageUncheckedCreateWithoutUserTwoInput> | RoomMessageCreateWithoutUserTwoInput[] | RoomMessageUncheckedCreateWithoutUserTwoInput[]
    connectOrCreate?: RoomMessageCreateOrConnectWithoutUserTwoInput | RoomMessageCreateOrConnectWithoutUserTwoInput[]
    createMany?: RoomMessageCreateManyUserTwoInputEnvelope
    connect?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
  }

  export type ReceiptCreateNestedManyWithoutUserInput = {
    create?: XOR<ReceiptCreateWithoutUserInput, ReceiptUncheckedCreateWithoutUserInput> | ReceiptCreateWithoutUserInput[] | ReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutUserInput | ReceiptCreateOrConnectWithoutUserInput[]
    createMany?: ReceiptCreateManyUserInputEnvelope
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
  }

  export type VoucherUsedCreateNestedManyWithoutUserInput = {
    create?: XOR<VoucherUsedCreateWithoutUserInput, VoucherUsedUncheckedCreateWithoutUserInput> | VoucherUsedCreateWithoutUserInput[] | VoucherUsedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsedCreateOrConnectWithoutUserInput | VoucherUsedCreateOrConnectWithoutUserInput[]
    createMany?: VoucherUsedCreateManyUserInputEnvelope
    connect?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
  }

  export type AddressUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressUserCreateWithoutUserInput, AddressUserUncheckedCreateWithoutUserInput> | AddressUserCreateWithoutUserInput[] | AddressUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressUserCreateOrConnectWithoutUserInput | AddressUserCreateOrConnectWithoutUserInput[]
    createMany?: AddressUserCreateManyUserInputEnvelope
    connect?: AddressUserWhereUniqueInput | AddressUserWhereUniqueInput[]
  }

  export type BlogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput> | BlogCreateWithoutUserInput[] | BlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutUserInput | BlogCreateOrConnectWithoutUserInput[]
    createMany?: BlogCreateManyUserInputEnvelope
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ShopCartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShopCartCreateWithoutUserInput, ShopCartUncheckedCreateWithoutUserInput> | ShopCartCreateWithoutUserInput[] | ShopCartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopCartCreateOrConnectWithoutUserInput | ShopCartCreateOrConnectWithoutUserInput[]
    createMany?: ShopCartCreateManyUserInputEnvelope
    connect?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
  }

  export type RoomMessageUncheckedCreateNestedManyWithoutUserOneInput = {
    create?: XOR<RoomMessageCreateWithoutUserOneInput, RoomMessageUncheckedCreateWithoutUserOneInput> | RoomMessageCreateWithoutUserOneInput[] | RoomMessageUncheckedCreateWithoutUserOneInput[]
    connectOrCreate?: RoomMessageCreateOrConnectWithoutUserOneInput | RoomMessageCreateOrConnectWithoutUserOneInput[]
    createMany?: RoomMessageCreateManyUserOneInputEnvelope
    connect?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
  }

  export type RoomMessageUncheckedCreateNestedManyWithoutUserTwoInput = {
    create?: XOR<RoomMessageCreateWithoutUserTwoInput, RoomMessageUncheckedCreateWithoutUserTwoInput> | RoomMessageCreateWithoutUserTwoInput[] | RoomMessageUncheckedCreateWithoutUserTwoInput[]
    connectOrCreate?: RoomMessageCreateOrConnectWithoutUserTwoInput | RoomMessageCreateOrConnectWithoutUserTwoInput[]
    createMany?: RoomMessageCreateManyUserTwoInputEnvelope
    connect?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
  }

  export type ReceiptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReceiptCreateWithoutUserInput, ReceiptUncheckedCreateWithoutUserInput> | ReceiptCreateWithoutUserInput[] | ReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutUserInput | ReceiptCreateOrConnectWithoutUserInput[]
    createMany?: ReceiptCreateManyUserInputEnvelope
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
  }

  export type VoucherUsedUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VoucherUsedCreateWithoutUserInput, VoucherUsedUncheckedCreateWithoutUserInput> | VoucherUsedCreateWithoutUserInput[] | VoucherUsedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsedCreateOrConnectWithoutUserInput | VoucherUsedCreateOrConnectWithoutUserInput[]
    createMany?: VoucherUsedCreateManyUserInputEnvelope
    connect?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableEnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status | null
  }

  export type AddressUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressUserCreateWithoutUserInput, AddressUserUncheckedCreateWithoutUserInput> | AddressUserCreateWithoutUserInput[] | AddressUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressUserCreateOrConnectWithoutUserInput | AddressUserCreateOrConnectWithoutUserInput[]
    upsert?: AddressUserUpsertWithWhereUniqueWithoutUserInput | AddressUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressUserCreateManyUserInputEnvelope
    set?: AddressUserWhereUniqueInput | AddressUserWhereUniqueInput[]
    disconnect?: AddressUserWhereUniqueInput | AddressUserWhereUniqueInput[]
    delete?: AddressUserWhereUniqueInput | AddressUserWhereUniqueInput[]
    connect?: AddressUserWhereUniqueInput | AddressUserWhereUniqueInput[]
    update?: AddressUserUpdateWithWhereUniqueWithoutUserInput | AddressUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUserUpdateManyWithWhereWithoutUserInput | AddressUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressUserScalarWhereInput | AddressUserScalarWhereInput[]
  }

  export type BlogUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput> | BlogCreateWithoutUserInput[] | BlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutUserInput | BlogCreateOrConnectWithoutUserInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutUserInput | BlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogCreateManyUserInputEnvelope
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutUserInput | BlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutUserInput | BlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ShopCartUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShopCartCreateWithoutUserInput, ShopCartUncheckedCreateWithoutUserInput> | ShopCartCreateWithoutUserInput[] | ShopCartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopCartCreateOrConnectWithoutUserInput | ShopCartCreateOrConnectWithoutUserInput[]
    upsert?: ShopCartUpsertWithWhereUniqueWithoutUserInput | ShopCartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShopCartCreateManyUserInputEnvelope
    set?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    disconnect?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    delete?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    connect?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    update?: ShopCartUpdateWithWhereUniqueWithoutUserInput | ShopCartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShopCartUpdateManyWithWhereWithoutUserInput | ShopCartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShopCartScalarWhereInput | ShopCartScalarWhereInput[]
  }

  export type RoomMessageUpdateManyWithoutUserOneNestedInput = {
    create?: XOR<RoomMessageCreateWithoutUserOneInput, RoomMessageUncheckedCreateWithoutUserOneInput> | RoomMessageCreateWithoutUserOneInput[] | RoomMessageUncheckedCreateWithoutUserOneInput[]
    connectOrCreate?: RoomMessageCreateOrConnectWithoutUserOneInput | RoomMessageCreateOrConnectWithoutUserOneInput[]
    upsert?: RoomMessageUpsertWithWhereUniqueWithoutUserOneInput | RoomMessageUpsertWithWhereUniqueWithoutUserOneInput[]
    createMany?: RoomMessageCreateManyUserOneInputEnvelope
    set?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    disconnect?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    delete?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    connect?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    update?: RoomMessageUpdateWithWhereUniqueWithoutUserOneInput | RoomMessageUpdateWithWhereUniqueWithoutUserOneInput[]
    updateMany?: RoomMessageUpdateManyWithWhereWithoutUserOneInput | RoomMessageUpdateManyWithWhereWithoutUserOneInput[]
    deleteMany?: RoomMessageScalarWhereInput | RoomMessageScalarWhereInput[]
  }

  export type RoomMessageUpdateManyWithoutUserTwoNestedInput = {
    create?: XOR<RoomMessageCreateWithoutUserTwoInput, RoomMessageUncheckedCreateWithoutUserTwoInput> | RoomMessageCreateWithoutUserTwoInput[] | RoomMessageUncheckedCreateWithoutUserTwoInput[]
    connectOrCreate?: RoomMessageCreateOrConnectWithoutUserTwoInput | RoomMessageCreateOrConnectWithoutUserTwoInput[]
    upsert?: RoomMessageUpsertWithWhereUniqueWithoutUserTwoInput | RoomMessageUpsertWithWhereUniqueWithoutUserTwoInput[]
    createMany?: RoomMessageCreateManyUserTwoInputEnvelope
    set?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    disconnect?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    delete?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    connect?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    update?: RoomMessageUpdateWithWhereUniqueWithoutUserTwoInput | RoomMessageUpdateWithWhereUniqueWithoutUserTwoInput[]
    updateMany?: RoomMessageUpdateManyWithWhereWithoutUserTwoInput | RoomMessageUpdateManyWithWhereWithoutUserTwoInput[]
    deleteMany?: RoomMessageScalarWhereInput | RoomMessageScalarWhereInput[]
  }

  export type ReceiptUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReceiptCreateWithoutUserInput, ReceiptUncheckedCreateWithoutUserInput> | ReceiptCreateWithoutUserInput[] | ReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutUserInput | ReceiptCreateOrConnectWithoutUserInput[]
    upsert?: ReceiptUpsertWithWhereUniqueWithoutUserInput | ReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReceiptCreateManyUserInputEnvelope
    set?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    disconnect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    delete?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    update?: ReceiptUpdateWithWhereUniqueWithoutUserInput | ReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReceiptUpdateManyWithWhereWithoutUserInput | ReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
  }

  export type VoucherUsedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoucherUsedCreateWithoutUserInput, VoucherUsedUncheckedCreateWithoutUserInput> | VoucherUsedCreateWithoutUserInput[] | VoucherUsedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsedCreateOrConnectWithoutUserInput | VoucherUsedCreateOrConnectWithoutUserInput[]
    upsert?: VoucherUsedUpsertWithWhereUniqueWithoutUserInput | VoucherUsedUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoucherUsedCreateManyUserInputEnvelope
    set?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    disconnect?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    delete?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    connect?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    update?: VoucherUsedUpdateWithWhereUniqueWithoutUserInput | VoucherUsedUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoucherUsedUpdateManyWithWhereWithoutUserInput | VoucherUsedUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoucherUsedScalarWhereInput | VoucherUsedScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AddressUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressUserCreateWithoutUserInput, AddressUserUncheckedCreateWithoutUserInput> | AddressUserCreateWithoutUserInput[] | AddressUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressUserCreateOrConnectWithoutUserInput | AddressUserCreateOrConnectWithoutUserInput[]
    upsert?: AddressUserUpsertWithWhereUniqueWithoutUserInput | AddressUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressUserCreateManyUserInputEnvelope
    set?: AddressUserWhereUniqueInput | AddressUserWhereUniqueInput[]
    disconnect?: AddressUserWhereUniqueInput | AddressUserWhereUniqueInput[]
    delete?: AddressUserWhereUniqueInput | AddressUserWhereUniqueInput[]
    connect?: AddressUserWhereUniqueInput | AddressUserWhereUniqueInput[]
    update?: AddressUserUpdateWithWhereUniqueWithoutUserInput | AddressUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUserUpdateManyWithWhereWithoutUserInput | AddressUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressUserScalarWhereInput | AddressUserScalarWhereInput[]
  }

  export type BlogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput> | BlogCreateWithoutUserInput[] | BlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BlogCreateOrConnectWithoutUserInput | BlogCreateOrConnectWithoutUserInput[]
    upsert?: BlogUpsertWithWhereUniqueWithoutUserInput | BlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BlogCreateManyUserInputEnvelope
    set?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    disconnect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    delete?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    connect?: BlogWhereUniqueInput | BlogWhereUniqueInput[]
    update?: BlogUpdateWithWhereUniqueWithoutUserInput | BlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BlogUpdateManyWithWhereWithoutUserInput | BlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BlogScalarWhereInput | BlogScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ShopCartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShopCartCreateWithoutUserInput, ShopCartUncheckedCreateWithoutUserInput> | ShopCartCreateWithoutUserInput[] | ShopCartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShopCartCreateOrConnectWithoutUserInput | ShopCartCreateOrConnectWithoutUserInput[]
    upsert?: ShopCartUpsertWithWhereUniqueWithoutUserInput | ShopCartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShopCartCreateManyUserInputEnvelope
    set?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    disconnect?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    delete?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    connect?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    update?: ShopCartUpdateWithWhereUniqueWithoutUserInput | ShopCartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShopCartUpdateManyWithWhereWithoutUserInput | ShopCartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShopCartScalarWhereInput | ShopCartScalarWhereInput[]
  }

  export type RoomMessageUncheckedUpdateManyWithoutUserOneNestedInput = {
    create?: XOR<RoomMessageCreateWithoutUserOneInput, RoomMessageUncheckedCreateWithoutUserOneInput> | RoomMessageCreateWithoutUserOneInput[] | RoomMessageUncheckedCreateWithoutUserOneInput[]
    connectOrCreate?: RoomMessageCreateOrConnectWithoutUserOneInput | RoomMessageCreateOrConnectWithoutUserOneInput[]
    upsert?: RoomMessageUpsertWithWhereUniqueWithoutUserOneInput | RoomMessageUpsertWithWhereUniqueWithoutUserOneInput[]
    createMany?: RoomMessageCreateManyUserOneInputEnvelope
    set?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    disconnect?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    delete?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    connect?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    update?: RoomMessageUpdateWithWhereUniqueWithoutUserOneInput | RoomMessageUpdateWithWhereUniqueWithoutUserOneInput[]
    updateMany?: RoomMessageUpdateManyWithWhereWithoutUserOneInput | RoomMessageUpdateManyWithWhereWithoutUserOneInput[]
    deleteMany?: RoomMessageScalarWhereInput | RoomMessageScalarWhereInput[]
  }

  export type RoomMessageUncheckedUpdateManyWithoutUserTwoNestedInput = {
    create?: XOR<RoomMessageCreateWithoutUserTwoInput, RoomMessageUncheckedCreateWithoutUserTwoInput> | RoomMessageCreateWithoutUserTwoInput[] | RoomMessageUncheckedCreateWithoutUserTwoInput[]
    connectOrCreate?: RoomMessageCreateOrConnectWithoutUserTwoInput | RoomMessageCreateOrConnectWithoutUserTwoInput[]
    upsert?: RoomMessageUpsertWithWhereUniqueWithoutUserTwoInput | RoomMessageUpsertWithWhereUniqueWithoutUserTwoInput[]
    createMany?: RoomMessageCreateManyUserTwoInputEnvelope
    set?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    disconnect?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    delete?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    connect?: RoomMessageWhereUniqueInput | RoomMessageWhereUniqueInput[]
    update?: RoomMessageUpdateWithWhereUniqueWithoutUserTwoInput | RoomMessageUpdateWithWhereUniqueWithoutUserTwoInput[]
    updateMany?: RoomMessageUpdateManyWithWhereWithoutUserTwoInput | RoomMessageUpdateManyWithWhereWithoutUserTwoInput[]
    deleteMany?: RoomMessageScalarWhereInput | RoomMessageScalarWhereInput[]
  }

  export type ReceiptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReceiptCreateWithoutUserInput, ReceiptUncheckedCreateWithoutUserInput> | ReceiptCreateWithoutUserInput[] | ReceiptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReceiptCreateOrConnectWithoutUserInput | ReceiptCreateOrConnectWithoutUserInput[]
    upsert?: ReceiptUpsertWithWhereUniqueWithoutUserInput | ReceiptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReceiptCreateManyUserInputEnvelope
    set?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    disconnect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    delete?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    connect?: ReceiptWhereUniqueInput | ReceiptWhereUniqueInput[]
    update?: ReceiptUpdateWithWhereUniqueWithoutUserInput | ReceiptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReceiptUpdateManyWithWhereWithoutUserInput | ReceiptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
  }

  export type VoucherUsedUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoucherUsedCreateWithoutUserInput, VoucherUsedUncheckedCreateWithoutUserInput> | VoucherUsedCreateWithoutUserInput[] | VoucherUsedUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsedCreateOrConnectWithoutUserInput | VoucherUsedCreateOrConnectWithoutUserInput[]
    upsert?: VoucherUsedUpsertWithWhereUniqueWithoutUserInput | VoucherUsedUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoucherUsedCreateManyUserInputEnvelope
    set?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    disconnect?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    delete?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    connect?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    update?: VoucherUsedUpdateWithWhereUniqueWithoutUserInput | VoucherUsedUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoucherUsedUpdateManyWithWhereWithoutUserInput | VoucherUsedUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoucherUsedScalarWhereInput | VoucherUsedScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAddressUserInput = {
    create?: XOR<UserCreateWithoutAddressUserInput, UserUncheckedCreateWithoutAddressUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressUserInput
    connect?: UserWhereUniqueInput
  }

  export type OrderProductCreateNestedManyWithoutAddressUserInput = {
    create?: XOR<OrderProductCreateWithoutAddressUserInput, OrderProductUncheckedCreateWithoutAddressUserInput> | OrderProductCreateWithoutAddressUserInput[] | OrderProductUncheckedCreateWithoutAddressUserInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutAddressUserInput | OrderProductCreateOrConnectWithoutAddressUserInput[]
    createMany?: OrderProductCreateManyAddressUserInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type OrderProductUncheckedCreateNestedManyWithoutAddressUserInput = {
    create?: XOR<OrderProductCreateWithoutAddressUserInput, OrderProductUncheckedCreateWithoutAddressUserInput> | OrderProductCreateWithoutAddressUserInput[] | OrderProductUncheckedCreateWithoutAddressUserInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutAddressUserInput | OrderProductCreateOrConnectWithoutAddressUserInput[]
    createMany?: OrderProductCreateManyAddressUserInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAddressUserNestedInput = {
    create?: XOR<UserCreateWithoutAddressUserInput, UserUncheckedCreateWithoutAddressUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressUserInput
    upsert?: UserUpsertWithoutAddressUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressUserInput, UserUpdateWithoutAddressUserInput>, UserUncheckedUpdateWithoutAddressUserInput>
  }

  export type OrderProductUpdateManyWithoutAddressUserNestedInput = {
    create?: XOR<OrderProductCreateWithoutAddressUserInput, OrderProductUncheckedCreateWithoutAddressUserInput> | OrderProductCreateWithoutAddressUserInput[] | OrderProductUncheckedCreateWithoutAddressUserInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutAddressUserInput | OrderProductCreateOrConnectWithoutAddressUserInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutAddressUserInput | OrderProductUpsertWithWhereUniqueWithoutAddressUserInput[]
    createMany?: OrderProductCreateManyAddressUserInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutAddressUserInput | OrderProductUpdateWithWhereUniqueWithoutAddressUserInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutAddressUserInput | OrderProductUpdateManyWithWhereWithoutAddressUserInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type OrderProductUncheckedUpdateManyWithoutAddressUserNestedInput = {
    create?: XOR<OrderProductCreateWithoutAddressUserInput, OrderProductUncheckedCreateWithoutAddressUserInput> | OrderProductCreateWithoutAddressUserInput[] | OrderProductUncheckedCreateWithoutAddressUserInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutAddressUserInput | OrderProductCreateOrConnectWithoutAddressUserInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutAddressUserInput | OrderProductUpsertWithWhereUniqueWithoutAddressUserInput[]
    createMany?: OrderProductCreateManyAddressUserInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutAddressUserInput | OrderProductUpdateWithWhereUniqueWithoutAddressUserInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutAddressUserInput | OrderProductUpdateManyWithWhereWithoutAddressUserInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBlogInput = {
    create?: XOR<UserCreateWithoutBlogInput, UserUncheckedCreateWithoutBlogInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutBlogInput = {
    create?: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput> | CommentCreateWithoutBlogInput[] | CommentUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBlogInput | CommentCreateOrConnectWithoutBlogInput[]
    createMany?: CommentCreateManyBlogInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutBlogInput = {
    create?: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput> | CommentCreateWithoutBlogInput[] | CommentUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBlogInput | CommentCreateOrConnectWithoutBlogInput[]
    createMany?: CommentCreateManyBlogInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NullableEnumSubjectFieldUpdateOperationsInput = {
    set?: $Enums.Subject | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutBlogNestedInput = {
    create?: XOR<UserCreateWithoutBlogInput, UserUncheckedCreateWithoutBlogInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlogInput
    upsert?: UserUpsertWithoutBlogInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlogInput, UserUpdateWithoutBlogInput>, UserUncheckedUpdateWithoutBlogInput>
  }

  export type CommentUpdateManyWithoutBlogNestedInput = {
    create?: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput> | CommentCreateWithoutBlogInput[] | CommentUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBlogInput | CommentCreateOrConnectWithoutBlogInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutBlogInput | CommentUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: CommentCreateManyBlogInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutBlogInput | CommentUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutBlogInput | CommentUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutBlogNestedInput = {
    create?: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput> | CommentCreateWithoutBlogInput[] | CommentUncheckedCreateWithoutBlogInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutBlogInput | CommentCreateOrConnectWithoutBlogInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutBlogInput | CommentUpsertWithWhereUniqueWithoutBlogInput[]
    createMany?: CommentCreateManyBlogInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutBlogInput | CommentUpdateWithWhereUniqueWithoutBlogInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutBlogInput | CommentUpdateManyWithWhereWithoutBlogInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutCommentInput = {
    create?: XOR<ProductCreateWithoutCommentInput, ProductUncheckedCreateWithoutCommentInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCommentInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    connect?: UserWhereUniqueInput
  }

  export type BlogCreateNestedOneWithoutCommentInput = {
    create?: XOR<BlogCreateWithoutCommentInput, BlogUncheckedCreateWithoutCommentInput>
    connectOrCreate?: BlogCreateOrConnectWithoutCommentInput
    connect?: BlogWhereUniqueInput
  }

  export type ProductUpdateOneWithoutCommentNestedInput = {
    create?: XOR<ProductCreateWithoutCommentInput, ProductUncheckedCreateWithoutCommentInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCommentInput
    upsert?: ProductUpsertWithoutCommentInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCommentInput, ProductUpdateWithoutCommentInput>, ProductUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateOneWithoutCommentNestedInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    upsert?: UserUpsertWithoutCommentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentInput, UserUpdateWithoutCommentInput>, UserUncheckedUpdateWithoutCommentInput>
  }

  export type BlogUpdateOneWithoutCommentNestedInput = {
    create?: XOR<BlogCreateWithoutCommentInput, BlogUncheckedCreateWithoutCommentInput>
    connectOrCreate?: BlogCreateOrConnectWithoutCommentInput
    upsert?: BlogUpsertWithoutCommentInput
    disconnect?: BlogWhereInput | boolean
    delete?: BlogWhereInput | boolean
    connect?: BlogWhereUniqueInput
    update?: XOR<XOR<BlogUpdateToOneWithWhereWithoutCommentInput, BlogUpdateWithoutCommentInput>, BlogUncheckedUpdateWithoutCommentInput>
  }

  export type UserCreateNestedOneWithoutMessageInput = {
    create?: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageInput
    connect?: UserWhereUniqueInput
  }

  export type RoomMessageCreateNestedOneWithoutMessagesInput = {
    create?: XOR<RoomMessageCreateWithoutMessagesInput, RoomMessageUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: RoomMessageCreateOrConnectWithoutMessagesInput
    connect?: RoomMessageWhereUniqueInput
  }

  export type UserUpdateOneWithoutMessageNestedInput = {
    create?: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageInput
    upsert?: UserUpsertWithoutMessageInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageInput, UserUpdateWithoutMessageInput>, UserUncheckedUpdateWithoutMessageInput>
  }

  export type RoomMessageUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<RoomMessageCreateWithoutMessagesInput, RoomMessageUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: RoomMessageCreateOrConnectWithoutMessagesInput
    upsert?: RoomMessageUpsertWithoutMessagesInput
    disconnect?: RoomMessageWhereInput | boolean
    delete?: RoomMessageWhereInput | boolean
    connect?: RoomMessageWhereUniqueInput
    update?: XOR<XOR<RoomMessageUpdateToOneWithWhereWithoutMessagesInput, RoomMessageUpdateWithoutMessagesInput>, RoomMessageUncheckedUpdateWithoutMessagesInput>
  }

  export type OrderProductCreateNestedOneWithoutOrderDetaillInput = {
    create?: XOR<OrderProductCreateWithoutOrderDetaillInput, OrderProductUncheckedCreateWithoutOrderDetaillInput>
    connectOrCreate?: OrderProductCreateOrConnectWithoutOrderDetaillInput
    connect?: OrderProductWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderDetaillInput = {
    create?: XOR<ProductCreateWithoutOrderDetaillInput, ProductUncheckedCreateWithoutOrderDetaillInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderDetaillInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderProductUpdateOneWithoutOrderDetaillNestedInput = {
    create?: XOR<OrderProductCreateWithoutOrderDetaillInput, OrderProductUncheckedCreateWithoutOrderDetaillInput>
    connectOrCreate?: OrderProductCreateOrConnectWithoutOrderDetaillInput
    upsert?: OrderProductUpsertWithoutOrderDetaillInput
    disconnect?: OrderProductWhereInput | boolean
    delete?: OrderProductWhereInput | boolean
    connect?: OrderProductWhereUniqueInput
    update?: XOR<XOR<OrderProductUpdateToOneWithWhereWithoutOrderDetaillInput, OrderProductUpdateWithoutOrderDetaillInput>, OrderProductUncheckedUpdateWithoutOrderDetaillInput>
  }

  export type ProductUpdateOneWithoutOrderDetaillNestedInput = {
    create?: XOR<ProductCreateWithoutOrderDetaillInput, ProductUncheckedCreateWithoutOrderDetaillInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderDetaillInput
    upsert?: ProductUpsertWithoutOrderDetaillInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderDetaillInput, ProductUpdateWithoutOrderDetaillInput>, ProductUncheckedUpdateWithoutOrderDetaillInput>
  }

  export type AddressUserCreateNestedOneWithoutOrderProductInput = {
    create?: XOR<AddressUserCreateWithoutOrderProductInput, AddressUserUncheckedCreateWithoutOrderProductInput>
    connectOrCreate?: AddressUserCreateOrConnectWithoutOrderProductInput
    connect?: AddressUserWhereUniqueInput
  }

  export type TypeShipCreateNestedOneWithoutOrderProductInput = {
    create?: XOR<TypeShipCreateWithoutOrderProductInput, TypeShipUncheckedCreateWithoutOrderProductInput>
    connectOrCreate?: TypeShipCreateOrConnectWithoutOrderProductInput
    connect?: TypeShipWhereUniqueInput
  }

  export type VoucherCreateNestedOneWithoutOrderProductInput = {
    create?: XOR<VoucherCreateWithoutOrderProductInput, VoucherUncheckedCreateWithoutOrderProductInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutOrderProductInput
    connect?: VoucherWhereUniqueInput
  }

  export type OrderDetaillCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderDetaillCreateWithoutOrderInput, OrderDetaillUncheckedCreateWithoutOrderInput> | OrderDetaillCreateWithoutOrderInput[] | OrderDetaillUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderDetaillCreateOrConnectWithoutOrderInput | OrderDetaillCreateOrConnectWithoutOrderInput[]
    createMany?: OrderDetaillCreateManyOrderInputEnvelope
    connect?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
  }

  export type OrderDetaillUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderDetaillCreateWithoutOrderInput, OrderDetaillUncheckedCreateWithoutOrderInput> | OrderDetaillCreateWithoutOrderInput[] | OrderDetaillUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderDetaillCreateOrConnectWithoutOrderInput | OrderDetaillCreateOrConnectWithoutOrderInput[]
    createMany?: OrderDetaillCreateManyOrderInputEnvelope
    connect?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
  }

  export type AddressUserUpdateOneWithoutOrderProductNestedInput = {
    create?: XOR<AddressUserCreateWithoutOrderProductInput, AddressUserUncheckedCreateWithoutOrderProductInput>
    connectOrCreate?: AddressUserCreateOrConnectWithoutOrderProductInput
    upsert?: AddressUserUpsertWithoutOrderProductInput
    disconnect?: AddressUserWhereInput | boolean
    delete?: AddressUserWhereInput | boolean
    connect?: AddressUserWhereUniqueInput
    update?: XOR<XOR<AddressUserUpdateToOneWithWhereWithoutOrderProductInput, AddressUserUpdateWithoutOrderProductInput>, AddressUserUncheckedUpdateWithoutOrderProductInput>
  }

  export type TypeShipUpdateOneWithoutOrderProductNestedInput = {
    create?: XOR<TypeShipCreateWithoutOrderProductInput, TypeShipUncheckedCreateWithoutOrderProductInput>
    connectOrCreate?: TypeShipCreateOrConnectWithoutOrderProductInput
    upsert?: TypeShipUpsertWithoutOrderProductInput
    disconnect?: TypeShipWhereInput | boolean
    delete?: TypeShipWhereInput | boolean
    connect?: TypeShipWhereUniqueInput
    update?: XOR<XOR<TypeShipUpdateToOneWithWhereWithoutOrderProductInput, TypeShipUpdateWithoutOrderProductInput>, TypeShipUncheckedUpdateWithoutOrderProductInput>
  }

  export type VoucherUpdateOneWithoutOrderProductNestedInput = {
    create?: XOR<VoucherCreateWithoutOrderProductInput, VoucherUncheckedCreateWithoutOrderProductInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutOrderProductInput
    upsert?: VoucherUpsertWithoutOrderProductInput
    disconnect?: VoucherWhereInput | boolean
    delete?: VoucherWhereInput | boolean
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutOrderProductInput, VoucherUpdateWithoutOrderProductInput>, VoucherUncheckedUpdateWithoutOrderProductInput>
  }

  export type OrderDetaillUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderDetaillCreateWithoutOrderInput, OrderDetaillUncheckedCreateWithoutOrderInput> | OrderDetaillCreateWithoutOrderInput[] | OrderDetaillUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderDetaillCreateOrConnectWithoutOrderInput | OrderDetaillCreateOrConnectWithoutOrderInput[]
    upsert?: OrderDetaillUpsertWithWhereUniqueWithoutOrderInput | OrderDetaillUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderDetaillCreateManyOrderInputEnvelope
    set?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    disconnect?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    delete?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    connect?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    update?: OrderDetaillUpdateWithWhereUniqueWithoutOrderInput | OrderDetaillUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderDetaillUpdateManyWithWhereWithoutOrderInput | OrderDetaillUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderDetaillScalarWhereInput | OrderDetaillScalarWhereInput[]
  }

  export type OrderDetaillUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderDetaillCreateWithoutOrderInput, OrderDetaillUncheckedCreateWithoutOrderInput> | OrderDetaillCreateWithoutOrderInput[] | OrderDetaillUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderDetaillCreateOrConnectWithoutOrderInput | OrderDetaillCreateOrConnectWithoutOrderInput[]
    upsert?: OrderDetaillUpsertWithWhereUniqueWithoutOrderInput | OrderDetaillUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderDetaillCreateManyOrderInputEnvelope
    set?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    disconnect?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    delete?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    connect?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    update?: OrderDetaillUpdateWithWhereUniqueWithoutOrderInput | OrderDetaillUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderDetaillUpdateManyWithWhereWithoutOrderInput | OrderDetaillUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderDetaillScalarWhereInput | OrderDetaillScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductSizeInput = {
    create?: XOR<ProductCreateWithoutProductSizeInput, ProductUncheckedCreateWithoutProductSizeInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductSizeInput
    connect?: ProductWhereUniqueInput
  }

  export type ShopCartCreateNestedManyWithoutProductSizeInput = {
    create?: XOR<ShopCartCreateWithoutProductSizeInput, ShopCartUncheckedCreateWithoutProductSizeInput> | ShopCartCreateWithoutProductSizeInput[] | ShopCartUncheckedCreateWithoutProductSizeInput[]
    connectOrCreate?: ShopCartCreateOrConnectWithoutProductSizeInput | ShopCartCreateOrConnectWithoutProductSizeInput[]
    createMany?: ShopCartCreateManyProductSizeInputEnvelope
    connect?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
  }

  export type ShopCartUncheckedCreateNestedManyWithoutProductSizeInput = {
    create?: XOR<ShopCartCreateWithoutProductSizeInput, ShopCartUncheckedCreateWithoutProductSizeInput> | ShopCartCreateWithoutProductSizeInput[] | ShopCartUncheckedCreateWithoutProductSizeInput[]
    connectOrCreate?: ShopCartCreateOrConnectWithoutProductSizeInput | ShopCartCreateOrConnectWithoutProductSizeInput[]
    createMany?: ShopCartCreateManyProductSizeInputEnvelope
    connect?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
  }

  export type NullableEnumSizeFieldUpdateOperationsInput = {
    set?: $Enums.Size | null
  }

  export type ProductUpdateOneWithoutProductSizeNestedInput = {
    create?: XOR<ProductCreateWithoutProductSizeInput, ProductUncheckedCreateWithoutProductSizeInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductSizeInput
    upsert?: ProductUpsertWithoutProductSizeInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductSizeInput, ProductUpdateWithoutProductSizeInput>, ProductUncheckedUpdateWithoutProductSizeInput>
  }

  export type ShopCartUpdateManyWithoutProductSizeNestedInput = {
    create?: XOR<ShopCartCreateWithoutProductSizeInput, ShopCartUncheckedCreateWithoutProductSizeInput> | ShopCartCreateWithoutProductSizeInput[] | ShopCartUncheckedCreateWithoutProductSizeInput[]
    connectOrCreate?: ShopCartCreateOrConnectWithoutProductSizeInput | ShopCartCreateOrConnectWithoutProductSizeInput[]
    upsert?: ShopCartUpsertWithWhereUniqueWithoutProductSizeInput | ShopCartUpsertWithWhereUniqueWithoutProductSizeInput[]
    createMany?: ShopCartCreateManyProductSizeInputEnvelope
    set?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    disconnect?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    delete?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    connect?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    update?: ShopCartUpdateWithWhereUniqueWithoutProductSizeInput | ShopCartUpdateWithWhereUniqueWithoutProductSizeInput[]
    updateMany?: ShopCartUpdateManyWithWhereWithoutProductSizeInput | ShopCartUpdateManyWithWhereWithoutProductSizeInput[]
    deleteMany?: ShopCartScalarWhereInput | ShopCartScalarWhereInput[]
  }

  export type ShopCartUncheckedUpdateManyWithoutProductSizeNestedInput = {
    create?: XOR<ShopCartCreateWithoutProductSizeInput, ShopCartUncheckedCreateWithoutProductSizeInput> | ShopCartCreateWithoutProductSizeInput[] | ShopCartUncheckedCreateWithoutProductSizeInput[]
    connectOrCreate?: ShopCartCreateOrConnectWithoutProductSizeInput | ShopCartCreateOrConnectWithoutProductSizeInput[]
    upsert?: ShopCartUpsertWithWhereUniqueWithoutProductSizeInput | ShopCartUpsertWithWhereUniqueWithoutProductSizeInput[]
    createMany?: ShopCartCreateManyProductSizeInputEnvelope
    set?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    disconnect?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    delete?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    connect?: ShopCartWhereUniqueInput | ShopCartWhereUniqueInput[]
    update?: ShopCartUpdateWithWhereUniqueWithoutProductSizeInput | ShopCartUpdateWithWhereUniqueWithoutProductSizeInput[]
    updateMany?: ShopCartUpdateManyWithWhereWithoutProductSizeInput | ShopCartUpdateManyWithWhereWithoutProductSizeInput[]
    deleteMany?: ShopCartScalarWhereInput | ShopCartScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutProductImageInput = {
    create?: XOR<ProductCreateWithoutProductImageInput, ProductUncheckedCreateWithoutProductImageInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductImageInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneWithoutProductImageNestedInput = {
    create?: XOR<ProductCreateWithoutProductImageInput, ProductUncheckedCreateWithoutProductImageInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductImageInput
    upsert?: ProductUpsertWithoutProductImageInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductImageInput, ProductUpdateWithoutProductImageInput>, ProductUncheckedUpdateWithoutProductImageInput>
  }

  export type CategoryCreateNestedOneWithoutProductInput = {
    create?: XOR<CategoryCreateWithoutProductInput, CategoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductInput
    connect?: CategoryWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutProductInput = {
    create?: XOR<BrandCreateWithoutProductInput, BrandUncheckedCreateWithoutProductInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductInput
    connect?: BrandWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutProductInput = {
    create?: XOR<CommentCreateWithoutProductInput, CommentUncheckedCreateWithoutProductInput> | CommentCreateWithoutProductInput[] | CommentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProductInput | CommentCreateOrConnectWithoutProductInput[]
    createMany?: CommentCreateManyProductInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type OrderDetaillCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderDetaillCreateWithoutProductInput, OrderDetaillUncheckedCreateWithoutProductInput> | OrderDetaillCreateWithoutProductInput[] | OrderDetaillUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderDetaillCreateOrConnectWithoutProductInput | OrderDetaillCreateOrConnectWithoutProductInput[]
    createMany?: OrderDetaillCreateManyProductInputEnvelope
    connect?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
  }

  export type ProductSizeCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput> | ProductSizeCreateWithoutProductInput[] | ProductSizeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductSizeCreateOrConnectWithoutProductInput | ProductSizeCreateOrConnectWithoutProductInput[]
    createMany?: ProductSizeCreateManyProductInputEnvelope
    connect?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
  }

  export type ProductImageCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CommentCreateWithoutProductInput, CommentUncheckedCreateWithoutProductInput> | CommentCreateWithoutProductInput[] | CommentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProductInput | CommentCreateOrConnectWithoutProductInput[]
    createMany?: CommentCreateManyProductInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type OrderDetaillUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderDetaillCreateWithoutProductInput, OrderDetaillUncheckedCreateWithoutProductInput> | OrderDetaillCreateWithoutProductInput[] | OrderDetaillUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderDetaillCreateOrConnectWithoutProductInput | OrderDetaillCreateOrConnectWithoutProductInput[]
    createMany?: OrderDetaillCreateManyProductInputEnvelope
    connect?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
  }

  export type ProductSizeUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput> | ProductSizeCreateWithoutProductInput[] | ProductSizeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductSizeCreateOrConnectWithoutProductInput | ProductSizeCreateOrConnectWithoutProductInput[]
    createMany?: ProductSizeCreateManyProductInputEnvelope
    connect?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
  }

  export type ProductImageUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type CategoryUpdateOneWithoutProductNestedInput = {
    create?: XOR<CategoryCreateWithoutProductInput, CategoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductInput
    upsert?: CategoryUpsertWithoutProductInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductInput, CategoryUpdateWithoutProductInput>, CategoryUncheckedUpdateWithoutProductInput>
  }

  export type BrandUpdateOneWithoutProductNestedInput = {
    create?: XOR<BrandCreateWithoutProductInput, BrandUncheckedCreateWithoutProductInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductInput
    upsert?: BrandUpsertWithoutProductInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutProductInput, BrandUpdateWithoutProductInput>, BrandUncheckedUpdateWithoutProductInput>
  }

  export type CommentUpdateManyWithoutProductNestedInput = {
    create?: XOR<CommentCreateWithoutProductInput, CommentUncheckedCreateWithoutProductInput> | CommentCreateWithoutProductInput[] | CommentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProductInput | CommentCreateOrConnectWithoutProductInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutProductInput | CommentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CommentCreateManyProductInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutProductInput | CommentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutProductInput | CommentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type OrderDetaillUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderDetaillCreateWithoutProductInput, OrderDetaillUncheckedCreateWithoutProductInput> | OrderDetaillCreateWithoutProductInput[] | OrderDetaillUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderDetaillCreateOrConnectWithoutProductInput | OrderDetaillCreateOrConnectWithoutProductInput[]
    upsert?: OrderDetaillUpsertWithWhereUniqueWithoutProductInput | OrderDetaillUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderDetaillCreateManyProductInputEnvelope
    set?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    disconnect?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    delete?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    connect?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    update?: OrderDetaillUpdateWithWhereUniqueWithoutProductInput | OrderDetaillUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderDetaillUpdateManyWithWhereWithoutProductInput | OrderDetaillUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderDetaillScalarWhereInput | OrderDetaillScalarWhereInput[]
  }

  export type ProductSizeUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput> | ProductSizeCreateWithoutProductInput[] | ProductSizeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductSizeCreateOrConnectWithoutProductInput | ProductSizeCreateOrConnectWithoutProductInput[]
    upsert?: ProductSizeUpsertWithWhereUniqueWithoutProductInput | ProductSizeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductSizeCreateManyProductInputEnvelope
    set?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    disconnect?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    delete?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    connect?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    update?: ProductSizeUpdateWithWhereUniqueWithoutProductInput | ProductSizeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductSizeUpdateManyWithWhereWithoutProductInput | ProductSizeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductSizeScalarWhereInput | ProductSizeScalarWhereInput[]
  }

  export type ProductImageUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CommentCreateWithoutProductInput, CommentUncheckedCreateWithoutProductInput> | CommentCreateWithoutProductInput[] | CommentUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutProductInput | CommentCreateOrConnectWithoutProductInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutProductInput | CommentUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CommentCreateManyProductInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutProductInput | CommentUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutProductInput | CommentUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type OrderDetaillUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderDetaillCreateWithoutProductInput, OrderDetaillUncheckedCreateWithoutProductInput> | OrderDetaillCreateWithoutProductInput[] | OrderDetaillUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderDetaillCreateOrConnectWithoutProductInput | OrderDetaillCreateOrConnectWithoutProductInput[]
    upsert?: OrderDetaillUpsertWithWhereUniqueWithoutProductInput | OrderDetaillUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderDetaillCreateManyProductInputEnvelope
    set?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    disconnect?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    delete?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    connect?: OrderDetaillWhereUniqueInput | OrderDetaillWhereUniqueInput[]
    update?: OrderDetaillUpdateWithWhereUniqueWithoutProductInput | OrderDetaillUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderDetaillUpdateManyWithWhereWithoutProductInput | OrderDetaillUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderDetaillScalarWhereInput | OrderDetaillScalarWhereInput[]
  }

  export type ProductSizeUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput> | ProductSizeCreateWithoutProductInput[] | ProductSizeUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductSizeCreateOrConnectWithoutProductInput | ProductSizeCreateOrConnectWithoutProductInput[]
    upsert?: ProductSizeUpsertWithWhereUniqueWithoutProductInput | ProductSizeUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductSizeCreateManyProductInputEnvelope
    set?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    disconnect?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    delete?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    connect?: ProductSizeWhereUniqueInput | ProductSizeWhereUniqueInput[]
    update?: ProductSizeUpdateWithWhereUniqueWithoutProductInput | ProductSizeUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductSizeUpdateManyWithWhereWithoutProductInput | ProductSizeUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductSizeScalarWhereInput | ProductSizeScalarWhereInput[]
  }

  export type ProductImageUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRoomMessagesOneInput = {
    create?: XOR<UserCreateWithoutRoomMessagesOneInput, UserUncheckedCreateWithoutRoomMessagesOneInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomMessagesOneInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRoomMessagesTwoInput = {
    create?: XOR<UserCreateWithoutRoomMessagesTwoInput, UserUncheckedCreateWithoutRoomMessagesTwoInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomMessagesTwoInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutRoomInput = {
    create?: XOR<MessageCreateWithoutRoomInput, MessageUncheckedCreateWithoutRoomInput> | MessageCreateWithoutRoomInput[] | MessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRoomInput | MessageCreateOrConnectWithoutRoomInput[]
    createMany?: MessageCreateManyRoomInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<MessageCreateWithoutRoomInput, MessageUncheckedCreateWithoutRoomInput> | MessageCreateWithoutRoomInput[] | MessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRoomInput | MessageCreateOrConnectWithoutRoomInput[]
    createMany?: MessageCreateManyRoomInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutRoomMessagesOneNestedInput = {
    create?: XOR<UserCreateWithoutRoomMessagesOneInput, UserUncheckedCreateWithoutRoomMessagesOneInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomMessagesOneInput
    upsert?: UserUpsertWithoutRoomMessagesOneInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoomMessagesOneInput, UserUpdateWithoutRoomMessagesOneInput>, UserUncheckedUpdateWithoutRoomMessagesOneInput>
  }

  export type UserUpdateOneWithoutRoomMessagesTwoNestedInput = {
    create?: XOR<UserCreateWithoutRoomMessagesTwoInput, UserUncheckedCreateWithoutRoomMessagesTwoInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomMessagesTwoInput
    upsert?: UserUpsertWithoutRoomMessagesTwoInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoomMessagesTwoInput, UserUpdateWithoutRoomMessagesTwoInput>, UserUncheckedUpdateWithoutRoomMessagesTwoInput>
  }

  export type MessageUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MessageCreateWithoutRoomInput, MessageUncheckedCreateWithoutRoomInput> | MessageCreateWithoutRoomInput[] | MessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRoomInput | MessageCreateOrConnectWithoutRoomInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRoomInput | MessageUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MessageCreateManyRoomInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRoomInput | MessageUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRoomInput | MessageUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MessageCreateWithoutRoomInput, MessageUncheckedCreateWithoutRoomInput> | MessageCreateWithoutRoomInput[] | MessageUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRoomInput | MessageCreateOrConnectWithoutRoomInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRoomInput | MessageUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MessageCreateManyRoomInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRoomInput | MessageUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRoomInput | MessageUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutShopCartInput = {
    create?: XOR<UserCreateWithoutShopCartInput, UserUncheckedCreateWithoutShopCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutShopCartInput
    connect?: UserWhereUniqueInput
  }

  export type ProductSizeCreateNestedOneWithoutShopCartInput = {
    create?: XOR<ProductSizeCreateWithoutShopCartInput, ProductSizeUncheckedCreateWithoutShopCartInput>
    connectOrCreate?: ProductSizeCreateOrConnectWithoutShopCartInput
    connect?: ProductSizeWhereUniqueInput
  }

  export type UserUpdateOneWithoutShopCartNestedInput = {
    create?: XOR<UserCreateWithoutShopCartInput, UserUncheckedCreateWithoutShopCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutShopCartInput
    upsert?: UserUpsertWithoutShopCartInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShopCartInput, UserUpdateWithoutShopCartInput>, UserUncheckedUpdateWithoutShopCartInput>
  }

  export type ProductSizeUpdateOneWithoutShopCartNestedInput = {
    create?: XOR<ProductSizeCreateWithoutShopCartInput, ProductSizeUncheckedCreateWithoutShopCartInput>
    connectOrCreate?: ProductSizeCreateOrConnectWithoutShopCartInput
    upsert?: ProductSizeUpsertWithoutShopCartInput
    disconnect?: ProductSizeWhereInput | boolean
    delete?: ProductSizeWhereInput | boolean
    connect?: ProductSizeWhereUniqueInput
    update?: XOR<XOR<ProductSizeUpdateToOneWithWhereWithoutShopCartInput, ProductSizeUpdateWithoutShopCartInput>, ProductSizeUncheckedUpdateWithoutShopCartInput>
  }

  export type OrderProductCreateNestedManyWithoutTypeShipInput = {
    create?: XOR<OrderProductCreateWithoutTypeShipInput, OrderProductUncheckedCreateWithoutTypeShipInput> | OrderProductCreateWithoutTypeShipInput[] | OrderProductUncheckedCreateWithoutTypeShipInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutTypeShipInput | OrderProductCreateOrConnectWithoutTypeShipInput[]
    createMany?: OrderProductCreateManyTypeShipInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type OrderProductUncheckedCreateNestedManyWithoutTypeShipInput = {
    create?: XOR<OrderProductCreateWithoutTypeShipInput, OrderProductUncheckedCreateWithoutTypeShipInput> | OrderProductCreateWithoutTypeShipInput[] | OrderProductUncheckedCreateWithoutTypeShipInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutTypeShipInput | OrderProductCreateOrConnectWithoutTypeShipInput[]
    createMany?: OrderProductCreateManyTypeShipInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type OrderProductUpdateManyWithoutTypeShipNestedInput = {
    create?: XOR<OrderProductCreateWithoutTypeShipInput, OrderProductUncheckedCreateWithoutTypeShipInput> | OrderProductCreateWithoutTypeShipInput[] | OrderProductUncheckedCreateWithoutTypeShipInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutTypeShipInput | OrderProductCreateOrConnectWithoutTypeShipInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutTypeShipInput | OrderProductUpsertWithWhereUniqueWithoutTypeShipInput[]
    createMany?: OrderProductCreateManyTypeShipInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutTypeShipInput | OrderProductUpdateWithWhereUniqueWithoutTypeShipInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutTypeShipInput | OrderProductUpdateManyWithWhereWithoutTypeShipInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type OrderProductUncheckedUpdateManyWithoutTypeShipNestedInput = {
    create?: XOR<OrderProductCreateWithoutTypeShipInput, OrderProductUncheckedCreateWithoutTypeShipInput> | OrderProductCreateWithoutTypeShipInput[] | OrderProductUncheckedCreateWithoutTypeShipInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutTypeShipInput | OrderProductCreateOrConnectWithoutTypeShipInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutTypeShipInput | OrderProductUpsertWithWhereUniqueWithoutTypeShipInput[]
    createMany?: OrderProductCreateManyTypeShipInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutTypeShipInput | OrderProductUpdateWithWhereUniqueWithoutTypeShipInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutTypeShipInput | OrderProductUpdateManyWithWhereWithoutTypeShipInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type VoucherCreateNestedManyWithoutTypeVoucherInput = {
    create?: XOR<VoucherCreateWithoutTypeVoucherInput, VoucherUncheckedCreateWithoutTypeVoucherInput> | VoucherCreateWithoutTypeVoucherInput[] | VoucherUncheckedCreateWithoutTypeVoucherInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutTypeVoucherInput | VoucherCreateOrConnectWithoutTypeVoucherInput[]
    createMany?: VoucherCreateManyTypeVoucherInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type VoucherUncheckedCreateNestedManyWithoutTypeVoucherInput = {
    create?: XOR<VoucherCreateWithoutTypeVoucherInput, VoucherUncheckedCreateWithoutTypeVoucherInput> | VoucherCreateWithoutTypeVoucherInput[] | VoucherUncheckedCreateWithoutTypeVoucherInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutTypeVoucherInput | VoucherCreateOrConnectWithoutTypeVoucherInput[]
    createMany?: VoucherCreateManyTypeVoucherInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type NullableEnumDiscountFieldUpdateOperationsInput = {
    set?: $Enums.Discount | null
  }

  export type VoucherUpdateManyWithoutTypeVoucherNestedInput = {
    create?: XOR<VoucherCreateWithoutTypeVoucherInput, VoucherUncheckedCreateWithoutTypeVoucherInput> | VoucherCreateWithoutTypeVoucherInput[] | VoucherUncheckedCreateWithoutTypeVoucherInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutTypeVoucherInput | VoucherCreateOrConnectWithoutTypeVoucherInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutTypeVoucherInput | VoucherUpsertWithWhereUniqueWithoutTypeVoucherInput[]
    createMany?: VoucherCreateManyTypeVoucherInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutTypeVoucherInput | VoucherUpdateWithWhereUniqueWithoutTypeVoucherInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutTypeVoucherInput | VoucherUpdateManyWithWhereWithoutTypeVoucherInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type VoucherUncheckedUpdateManyWithoutTypeVoucherNestedInput = {
    create?: XOR<VoucherCreateWithoutTypeVoucherInput, VoucherUncheckedCreateWithoutTypeVoucherInput> | VoucherCreateWithoutTypeVoucherInput[] | VoucherUncheckedCreateWithoutTypeVoucherInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutTypeVoucherInput | VoucherCreateOrConnectWithoutTypeVoucherInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutTypeVoucherInput | VoucherUpsertWithWhereUniqueWithoutTypeVoucherInput[]
    createMany?: VoucherCreateManyTypeVoucherInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutTypeVoucherInput | VoucherUpdateWithWhereUniqueWithoutTypeVoucherInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutTypeVoucherInput | VoucherUpdateManyWithWhereWithoutTypeVoucherInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type TypeVoucherCreateNestedOneWithoutVoucherInput = {
    create?: XOR<TypeVoucherCreateWithoutVoucherInput, TypeVoucherUncheckedCreateWithoutVoucherInput>
    connectOrCreate?: TypeVoucherCreateOrConnectWithoutVoucherInput
    connect?: TypeVoucherWhereUniqueInput
  }

  export type OrderProductCreateNestedManyWithoutVoucherInput = {
    create?: XOR<OrderProductCreateWithoutVoucherInput, OrderProductUncheckedCreateWithoutVoucherInput> | OrderProductCreateWithoutVoucherInput[] | OrderProductUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutVoucherInput | OrderProductCreateOrConnectWithoutVoucherInput[]
    createMany?: OrderProductCreateManyVoucherInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type VoucherUsedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherUsedCreateWithoutVoucherInput, VoucherUsedUncheckedCreateWithoutVoucherInput> | VoucherUsedCreateWithoutVoucherInput[] | VoucherUsedUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsedCreateOrConnectWithoutVoucherInput | VoucherUsedCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherUsedCreateManyVoucherInputEnvelope
    connect?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
  }

  export type OrderProductUncheckedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<OrderProductCreateWithoutVoucherInput, OrderProductUncheckedCreateWithoutVoucherInput> | OrderProductCreateWithoutVoucherInput[] | OrderProductUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutVoucherInput | OrderProductCreateOrConnectWithoutVoucherInput[]
    createMany?: OrderProductCreateManyVoucherInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type VoucherUsedUncheckedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherUsedCreateWithoutVoucherInput, VoucherUsedUncheckedCreateWithoutVoucherInput> | VoucherUsedCreateWithoutVoucherInput[] | VoucherUsedUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsedCreateOrConnectWithoutVoucherInput | VoucherUsedCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherUsedCreateManyVoucherInputEnvelope
    connect?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
  }

  export type TypeVoucherUpdateOneWithoutVoucherNestedInput = {
    create?: XOR<TypeVoucherCreateWithoutVoucherInput, TypeVoucherUncheckedCreateWithoutVoucherInput>
    connectOrCreate?: TypeVoucherCreateOrConnectWithoutVoucherInput
    upsert?: TypeVoucherUpsertWithoutVoucherInput
    disconnect?: TypeVoucherWhereInput | boolean
    delete?: TypeVoucherWhereInput | boolean
    connect?: TypeVoucherWhereUniqueInput
    update?: XOR<XOR<TypeVoucherUpdateToOneWithWhereWithoutVoucherInput, TypeVoucherUpdateWithoutVoucherInput>, TypeVoucherUncheckedUpdateWithoutVoucherInput>
  }

  export type OrderProductUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<OrderProductCreateWithoutVoucherInput, OrderProductUncheckedCreateWithoutVoucherInput> | OrderProductCreateWithoutVoucherInput[] | OrderProductUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutVoucherInput | OrderProductCreateOrConnectWithoutVoucherInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutVoucherInput | OrderProductUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: OrderProductCreateManyVoucherInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutVoucherInput | OrderProductUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutVoucherInput | OrderProductUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type VoucherUsedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherUsedCreateWithoutVoucherInput, VoucherUsedUncheckedCreateWithoutVoucherInput> | VoucherUsedCreateWithoutVoucherInput[] | VoucherUsedUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsedCreateOrConnectWithoutVoucherInput | VoucherUsedCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherUsedUpsertWithWhereUniqueWithoutVoucherInput | VoucherUsedUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherUsedCreateManyVoucherInputEnvelope
    set?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    disconnect?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    delete?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    connect?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    update?: VoucherUsedUpdateWithWhereUniqueWithoutVoucherInput | VoucherUsedUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherUsedUpdateManyWithWhereWithoutVoucherInput | VoucherUsedUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherUsedScalarWhereInput | VoucherUsedScalarWhereInput[]
  }

  export type OrderProductUncheckedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<OrderProductCreateWithoutVoucherInput, OrderProductUncheckedCreateWithoutVoucherInput> | OrderProductCreateWithoutVoucherInput[] | OrderProductUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutVoucherInput | OrderProductCreateOrConnectWithoutVoucherInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutVoucherInput | OrderProductUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: OrderProductCreateManyVoucherInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutVoucherInput | OrderProductUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutVoucherInput | OrderProductUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type VoucherUsedUncheckedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherUsedCreateWithoutVoucherInput, VoucherUsedUncheckedCreateWithoutVoucherInput> | VoucherUsedCreateWithoutVoucherInput[] | VoucherUsedUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsedCreateOrConnectWithoutVoucherInput | VoucherUsedCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherUsedUpsertWithWhereUniqueWithoutVoucherInput | VoucherUsedUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherUsedCreateManyVoucherInputEnvelope
    set?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    disconnect?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    delete?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    connect?: VoucherUsedWhereUniqueInput | VoucherUsedWhereUniqueInput[]
    update?: VoucherUsedUpdateWithWhereUniqueWithoutVoucherInput | VoucherUsedUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherUsedUpdateManyWithWhereWithoutVoucherInput | VoucherUsedUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherUsedScalarWhereInput | VoucherUsedScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutVoucherUsedInput = {
    create?: XOR<UserCreateWithoutVoucherUsedInput, UserUncheckedCreateWithoutVoucherUsedInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoucherUsedInput
    connect?: UserWhereUniqueInput
  }

  export type VoucherCreateNestedOneWithoutVoucherUsedInput = {
    create?: XOR<VoucherCreateWithoutVoucherUsedInput, VoucherUncheckedCreateWithoutVoucherUsedInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutVoucherUsedInput
    connect?: VoucherWhereUniqueInput
  }

  export type UserUpdateOneWithoutVoucherUsedNestedInput = {
    create?: XOR<UserCreateWithoutVoucherUsedInput, UserUncheckedCreateWithoutVoucherUsedInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoucherUsedInput
    upsert?: UserUpsertWithoutVoucherUsedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVoucherUsedInput, UserUpdateWithoutVoucherUsedInput>, UserUncheckedUpdateWithoutVoucherUsedInput>
  }

  export type VoucherUpdateOneWithoutVoucherUsedNestedInput = {
    create?: XOR<VoucherCreateWithoutVoucherUsedInput, VoucherUncheckedCreateWithoutVoucherUsedInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutVoucherUsedInput
    upsert?: VoucherUpsertWithoutVoucherUsedInput
    disconnect?: VoucherWhereInput | boolean
    delete?: VoucherWhereInput | boolean
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutVoucherUsedInput, VoucherUpdateWithoutVoucherUsedInput>, VoucherUncheckedUpdateWithoutVoucherUsedInput>
  }

  export type UserCreateNestedOneWithoutReceiptInput = {
    create?: XOR<UserCreateWithoutReceiptInput, UserUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceiptInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutReceiptNestedInput = {
    create?: XOR<UserCreateWithoutReceiptInput, UserUncheckedCreateWithoutReceiptInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceiptInput
    upsert?: UserUpsertWithoutReceiptInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceiptInput, UserUpdateWithoutReceiptInput>, UserUncheckedUpdateWithoutReceiptInput>
  }

  export type BrandCreateNestedOneWithoutCategoryInput = {
    create?: XOR<BrandCreateWithoutCategoryInput, BrandUncheckedCreateWithoutCategoryInput>
    connectOrCreate?: BrandCreateOrConnectWithoutCategoryInput
    connect?: BrandWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type BrandUpdateOneWithoutCategoryNestedInput = {
    create?: XOR<BrandCreateWithoutCategoryInput, BrandUncheckedCreateWithoutCategoryInput>
    connectOrCreate?: BrandCreateOrConnectWithoutCategoryInput
    upsert?: BrandUpsertWithoutCategoryInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutCategoryInput, BrandUpdateWithoutCategoryInput>, BrandUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutBrandInput = {
    create?: XOR<CategoryCreateWithoutBrandInput, CategoryUncheckedCreateWithoutBrandInput> | CategoryCreateWithoutBrandInput[] | CategoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBrandInput | CategoryCreateOrConnectWithoutBrandInput[]
    createMany?: CategoryCreateManyBrandInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<CategoryCreateWithoutBrandInput, CategoryUncheckedCreateWithoutBrandInput> | CategoryCreateWithoutBrandInput[] | CategoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBrandInput | CategoryCreateOrConnectWithoutBrandInput[]
    createMany?: CategoryCreateManyBrandInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutBrandNestedInput = {
    create?: XOR<CategoryCreateWithoutBrandInput, CategoryUncheckedCreateWithoutBrandInput> | CategoryCreateWithoutBrandInput[] | CategoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBrandInput | CategoryCreateOrConnectWithoutBrandInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutBrandInput | CategoryUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: CategoryCreateManyBrandInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutBrandInput | CategoryUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutBrandInput | CategoryUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<CategoryCreateWithoutBrandInput, CategoryUncheckedCreateWithoutBrandInput> | CategoryCreateWithoutBrandInput[] | CategoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBrandInput | CategoryCreateOrConnectWithoutBrandInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutBrandInput | CategoryUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: CategoryCreateManyBrandInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutBrandInput | CategoryUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutBrandInput | CategoryUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusNullableFilter<$PrismaModel> | $Enums.Status | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.Status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubjectNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Subject | EnumSubjectFieldRefInput<$PrismaModel> | null
    in?: $Enums.Subject[] | ListEnumSubjectFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Subject[] | ListEnumSubjectFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubjectNullableFilter<$PrismaModel> | $Enums.Subject | null
  }

  export type NestedEnumSubjectNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Subject | EnumSubjectFieldRefInput<$PrismaModel> | null
    in?: $Enums.Subject[] | ListEnumSubjectFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Subject[] | ListEnumSubjectFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSubjectNullableWithAggregatesFilter<$PrismaModel> | $Enums.Subject | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSubjectNullableFilter<$PrismaModel>
    _max?: NestedEnumSubjectNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSizeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSizeNullableFilter<$PrismaModel> | $Enums.Size | null
  }

  export type NestedEnumSizeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Size | EnumSizeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Size[] | ListEnumSizeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSizeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Size | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSizeNullableFilter<$PrismaModel>
    _max?: NestedEnumSizeNullableFilter<$PrismaModel>
  }

  export type NestedEnumDiscountNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Discount | EnumDiscountFieldRefInput<$PrismaModel> | null
    in?: $Enums.Discount[] | ListEnumDiscountFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Discount[] | ListEnumDiscountFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDiscountNullableFilter<$PrismaModel> | $Enums.Discount | null
  }

  export type NestedEnumDiscountNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Discount | EnumDiscountFieldRefInput<$PrismaModel> | null
    in?: $Enums.Discount[] | ListEnumDiscountFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Discount[] | ListEnumDiscountFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDiscountNullableWithAggregatesFilter<$PrismaModel> | $Enums.Discount | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDiscountNullableFilter<$PrismaModel>
    _max?: NestedEnumDiscountNullableFilter<$PrismaModel>
  }

  export type AddressUserCreateWithoutUserInput = {
    shipName?: string | null
    shipAdress?: string | null
    shipPhone?: string | null
    shipEmail?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderProduct?: OrderProductCreateNestedManyWithoutAddressUserInput
  }

  export type AddressUserUncheckedCreateWithoutUserInput = {
    id?: number
    shipName?: string | null
    shipAdress?: string | null
    shipPhone?: string | null
    shipEmail?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutAddressUserInput
  }

  export type AddressUserCreateOrConnectWithoutUserInput = {
    where: AddressUserWhereUniqueInput
    create: XOR<AddressUserCreateWithoutUserInput, AddressUserUncheckedCreateWithoutUserInput>
  }

  export type AddressUserCreateManyUserInputEnvelope = {
    data: AddressUserCreateManyUserInput | AddressUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlogCreateWithoutUserInput = {
    title?: string | null
    subject?: $Enums.Subject | null
    status?: $Enums.Status | null
    image?: string | null
    contentMarkdown?: string | null
    contentHTML?: string | null
    view?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Comment?: CommentCreateNestedManyWithoutBlogInput
  }

  export type BlogUncheckedCreateWithoutUserInput = {
    id?: number
    title?: string | null
    subject?: $Enums.Subject | null
    status?: $Enums.Status | null
    image?: string | null
    contentMarkdown?: string | null
    contentHTML?: string | null
    view?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Comment?: CommentUncheckedCreateNestedManyWithoutBlogInput
  }

  export type BlogCreateOrConnectWithoutUserInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput>
  }

  export type BlogCreateManyUserInputEnvelope = {
    data: BlogCreateManyUserInput | BlogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    content?: string | null
    image?: string | null
    parentId?: number | null
    star?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    product?: ProductCreateNestedOneWithoutCommentInput
    blog?: BlogCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: number
    content?: string | null
    image?: string | null
    parentId?: number | null
    productId?: number | null
    blogId?: number | null
    star?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUserInput = {
    text?: string | null
    unRead?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    room?: RoomMessageCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutUserInput = {
    id?: number
    text?: string | null
    roomId?: number | null
    unRead?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MessageCreateOrConnectWithoutUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateManyUserInputEnvelope = {
    data: MessageCreateManyUserInput | MessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShopCartCreateWithoutUserInput = {
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    productSize?: ProductSizeCreateNestedOneWithoutShopCartInput
  }

  export type ShopCartUncheckedCreateWithoutUserInput = {
    id?: number
    productSizeId?: number | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ShopCartCreateOrConnectWithoutUserInput = {
    where: ShopCartWhereUniqueInput
    create: XOR<ShopCartCreateWithoutUserInput, ShopCartUncheckedCreateWithoutUserInput>
  }

  export type ShopCartCreateManyUserInputEnvelope = {
    data: ShopCartCreateManyUserInput | ShopCartCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoomMessageCreateWithoutUserOneInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userTwo?: UserCreateNestedOneWithoutRoomMessagesTwoInput
    messages?: MessageCreateNestedManyWithoutRoomInput
  }

  export type RoomMessageUncheckedCreateWithoutUserOneInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userTwoId?: number | null
    messages?: MessageUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomMessageCreateOrConnectWithoutUserOneInput = {
    where: RoomMessageWhereUniqueInput
    create: XOR<RoomMessageCreateWithoutUserOneInput, RoomMessageUncheckedCreateWithoutUserOneInput>
  }

  export type RoomMessageCreateManyUserOneInputEnvelope = {
    data: RoomMessageCreateManyUserOneInput | RoomMessageCreateManyUserOneInput[]
    skipDuplicates?: boolean
  }

  export type RoomMessageCreateWithoutUserTwoInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userOne?: UserCreateNestedOneWithoutRoomMessagesOneInput
    messages?: MessageCreateNestedManyWithoutRoomInput
  }

  export type RoomMessageUncheckedCreateWithoutUserTwoInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userOneId?: number | null
    messages?: MessageUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomMessageCreateOrConnectWithoutUserTwoInput = {
    where: RoomMessageWhereUniqueInput
    create: XOR<RoomMessageCreateWithoutUserTwoInput, RoomMessageUncheckedCreateWithoutUserTwoInput>
  }

  export type RoomMessageCreateManyUserTwoInputEnvelope = {
    data: RoomMessageCreateManyUserTwoInput | RoomMessageCreateManyUserTwoInput[]
    skipDuplicates?: boolean
  }

  export type ReceiptCreateWithoutUserInput = {
    supplierId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiptUncheckedCreateWithoutUserInput = {
    id?: number
    supplierId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiptCreateOrConnectWithoutUserInput = {
    where: ReceiptWhereUniqueInput
    create: XOR<ReceiptCreateWithoutUserInput, ReceiptUncheckedCreateWithoutUserInput>
  }

  export type ReceiptCreateManyUserInputEnvelope = {
    data: ReceiptCreateManyUserInput | ReceiptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VoucherUsedCreateWithoutUserInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    voucher?: VoucherCreateNestedOneWithoutVoucherUsedInput
  }

  export type VoucherUsedUncheckedCreateWithoutUserInput = {
    id?: number
    voucherId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VoucherUsedCreateOrConnectWithoutUserInput = {
    where: VoucherUsedWhereUniqueInput
    create: XOR<VoucherUsedCreateWithoutUserInput, VoucherUsedUncheckedCreateWithoutUserInput>
  }

  export type VoucherUsedCreateManyUserInputEnvelope = {
    data: VoucherUsedCreateManyUserInput | VoucherUsedCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AddressUserUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressUserWhereUniqueInput
    update: XOR<AddressUserUpdateWithoutUserInput, AddressUserUncheckedUpdateWithoutUserInput>
    create: XOR<AddressUserCreateWithoutUserInput, AddressUserUncheckedCreateWithoutUserInput>
  }

  export type AddressUserUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressUserWhereUniqueInput
    data: XOR<AddressUserUpdateWithoutUserInput, AddressUserUncheckedUpdateWithoutUserInput>
  }

  export type AddressUserUpdateManyWithWhereWithoutUserInput = {
    where: AddressUserScalarWhereInput
    data: XOR<AddressUserUpdateManyMutationInput, AddressUserUncheckedUpdateManyWithoutUserInput>
  }

  export type AddressUserScalarWhereInput = {
    AND?: AddressUserScalarWhereInput | AddressUserScalarWhereInput[]
    OR?: AddressUserScalarWhereInput[]
    NOT?: AddressUserScalarWhereInput | AddressUserScalarWhereInput[]
    id?: IntFilter<"AddressUser"> | number
    userId?: IntFilter<"AddressUser"> | number
    shipName?: StringNullableFilter<"AddressUser"> | string | null
    shipAdress?: StringNullableFilter<"AddressUser"> | string | null
    shipPhone?: StringNullableFilter<"AddressUser"> | string | null
    shipEmail?: StringNullableFilter<"AddressUser"> | string | null
    createdAt?: DateTimeNullableFilter<"AddressUser"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"AddressUser"> | Date | string | null
  }

  export type BlogUpsertWithWhereUniqueWithoutUserInput = {
    where: BlogWhereUniqueInput
    update: XOR<BlogUpdateWithoutUserInput, BlogUncheckedUpdateWithoutUserInput>
    create: XOR<BlogCreateWithoutUserInput, BlogUncheckedCreateWithoutUserInput>
  }

  export type BlogUpdateWithWhereUniqueWithoutUserInput = {
    where: BlogWhereUniqueInput
    data: XOR<BlogUpdateWithoutUserInput, BlogUncheckedUpdateWithoutUserInput>
  }

  export type BlogUpdateManyWithWhereWithoutUserInput = {
    where: BlogScalarWhereInput
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyWithoutUserInput>
  }

  export type BlogScalarWhereInput = {
    AND?: BlogScalarWhereInput | BlogScalarWhereInput[]
    OR?: BlogScalarWhereInput[]
    NOT?: BlogScalarWhereInput | BlogScalarWhereInput[]
    id?: IntFilter<"Blog"> | number
    title?: StringNullableFilter<"Blog"> | string | null
    subject?: EnumSubjectNullableFilter<"Blog"> | $Enums.Subject | null
    status?: EnumStatusNullableFilter<"Blog"> | $Enums.Status | null
    image?: StringNullableFilter<"Blog"> | string | null
    contentMarkdown?: StringNullableFilter<"Blog"> | string | null
    contentHTML?: StringNullableFilter<"Blog"> | string | null
    userId?: IntNullableFilter<"Blog"> | number | null
    view?: IntNullableFilter<"Blog"> | number | null
    createdAt?: DateTimeNullableFilter<"Blog"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Blog"> | Date | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    content?: StringNullableFilter<"Comment"> | string | null
    image?: StringNullableFilter<"Comment"> | string | null
    parentId?: IntNullableFilter<"Comment"> | number | null
    productId?: IntNullableFilter<"Comment"> | number | null
    userId?: IntNullableFilter<"Comment"> | number | null
    blogId?: IntNullableFilter<"Comment"> | number | null
    star?: IntNullableFilter<"Comment"> | number | null
    createdAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: IntFilter<"Message"> | number
    text?: StringNullableFilter<"Message"> | string | null
    userId?: IntNullableFilter<"Message"> | number | null
    roomId?: IntNullableFilter<"Message"> | number | null
    unRead?: BoolNullableFilter<"Message"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
  }

  export type ShopCartUpsertWithWhereUniqueWithoutUserInput = {
    where: ShopCartWhereUniqueInput
    update: XOR<ShopCartUpdateWithoutUserInput, ShopCartUncheckedUpdateWithoutUserInput>
    create: XOR<ShopCartCreateWithoutUserInput, ShopCartUncheckedCreateWithoutUserInput>
  }

  export type ShopCartUpdateWithWhereUniqueWithoutUserInput = {
    where: ShopCartWhereUniqueInput
    data: XOR<ShopCartUpdateWithoutUserInput, ShopCartUncheckedUpdateWithoutUserInput>
  }

  export type ShopCartUpdateManyWithWhereWithoutUserInput = {
    where: ShopCartScalarWhereInput
    data: XOR<ShopCartUpdateManyMutationInput, ShopCartUncheckedUpdateManyWithoutUserInput>
  }

  export type ShopCartScalarWhereInput = {
    AND?: ShopCartScalarWhereInput | ShopCartScalarWhereInput[]
    OR?: ShopCartScalarWhereInput[]
    NOT?: ShopCartScalarWhereInput | ShopCartScalarWhereInput[]
    id?: IntFilter<"ShopCart"> | number
    userId?: IntNullableFilter<"ShopCart"> | number | null
    productSizeId?: IntNullableFilter<"ShopCart"> | number | null
    quantity?: IntNullableFilter<"ShopCart"> | number | null
    createdAt?: DateTimeNullableFilter<"ShopCart"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ShopCart"> | Date | string | null
  }

  export type RoomMessageUpsertWithWhereUniqueWithoutUserOneInput = {
    where: RoomMessageWhereUniqueInput
    update: XOR<RoomMessageUpdateWithoutUserOneInput, RoomMessageUncheckedUpdateWithoutUserOneInput>
    create: XOR<RoomMessageCreateWithoutUserOneInput, RoomMessageUncheckedCreateWithoutUserOneInput>
  }

  export type RoomMessageUpdateWithWhereUniqueWithoutUserOneInput = {
    where: RoomMessageWhereUniqueInput
    data: XOR<RoomMessageUpdateWithoutUserOneInput, RoomMessageUncheckedUpdateWithoutUserOneInput>
  }

  export type RoomMessageUpdateManyWithWhereWithoutUserOneInput = {
    where: RoomMessageScalarWhereInput
    data: XOR<RoomMessageUpdateManyMutationInput, RoomMessageUncheckedUpdateManyWithoutUserOneInput>
  }

  export type RoomMessageScalarWhereInput = {
    AND?: RoomMessageScalarWhereInput | RoomMessageScalarWhereInput[]
    OR?: RoomMessageScalarWhereInput[]
    NOT?: RoomMessageScalarWhereInput | RoomMessageScalarWhereInput[]
    id?: IntFilter<"RoomMessage"> | number
    createdAt?: DateTimeNullableFilter<"RoomMessage"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RoomMessage"> | Date | string | null
    userOneId?: IntNullableFilter<"RoomMessage"> | number | null
    userTwoId?: IntNullableFilter<"RoomMessage"> | number | null
  }

  export type RoomMessageUpsertWithWhereUniqueWithoutUserTwoInput = {
    where: RoomMessageWhereUniqueInput
    update: XOR<RoomMessageUpdateWithoutUserTwoInput, RoomMessageUncheckedUpdateWithoutUserTwoInput>
    create: XOR<RoomMessageCreateWithoutUserTwoInput, RoomMessageUncheckedCreateWithoutUserTwoInput>
  }

  export type RoomMessageUpdateWithWhereUniqueWithoutUserTwoInput = {
    where: RoomMessageWhereUniqueInput
    data: XOR<RoomMessageUpdateWithoutUserTwoInput, RoomMessageUncheckedUpdateWithoutUserTwoInput>
  }

  export type RoomMessageUpdateManyWithWhereWithoutUserTwoInput = {
    where: RoomMessageScalarWhereInput
    data: XOR<RoomMessageUpdateManyMutationInput, RoomMessageUncheckedUpdateManyWithoutUserTwoInput>
  }

  export type ReceiptUpsertWithWhereUniqueWithoutUserInput = {
    where: ReceiptWhereUniqueInput
    update: XOR<ReceiptUpdateWithoutUserInput, ReceiptUncheckedUpdateWithoutUserInput>
    create: XOR<ReceiptCreateWithoutUserInput, ReceiptUncheckedCreateWithoutUserInput>
  }

  export type ReceiptUpdateWithWhereUniqueWithoutUserInput = {
    where: ReceiptWhereUniqueInput
    data: XOR<ReceiptUpdateWithoutUserInput, ReceiptUncheckedUpdateWithoutUserInput>
  }

  export type ReceiptUpdateManyWithWhereWithoutUserInput = {
    where: ReceiptScalarWhereInput
    data: XOR<ReceiptUpdateManyMutationInput, ReceiptUncheckedUpdateManyWithoutUserInput>
  }

  export type ReceiptScalarWhereInput = {
    AND?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
    OR?: ReceiptScalarWhereInput[]
    NOT?: ReceiptScalarWhereInput | ReceiptScalarWhereInput[]
    id?: IntFilter<"Receipt"> | number
    userId?: IntNullableFilter<"Receipt"> | number | null
    supplierId?: IntNullableFilter<"Receipt"> | number | null
    createdAt?: DateTimeNullableFilter<"Receipt"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Receipt"> | Date | string | null
  }

  export type VoucherUsedUpsertWithWhereUniqueWithoutUserInput = {
    where: VoucherUsedWhereUniqueInput
    update: XOR<VoucherUsedUpdateWithoutUserInput, VoucherUsedUncheckedUpdateWithoutUserInput>
    create: XOR<VoucherUsedCreateWithoutUserInput, VoucherUsedUncheckedCreateWithoutUserInput>
  }

  export type VoucherUsedUpdateWithWhereUniqueWithoutUserInput = {
    where: VoucherUsedWhereUniqueInput
    data: XOR<VoucherUsedUpdateWithoutUserInput, VoucherUsedUncheckedUpdateWithoutUserInput>
  }

  export type VoucherUsedUpdateManyWithWhereWithoutUserInput = {
    where: VoucherUsedScalarWhereInput
    data: XOR<VoucherUsedUpdateManyMutationInput, VoucherUsedUncheckedUpdateManyWithoutUserInput>
  }

  export type VoucherUsedScalarWhereInput = {
    AND?: VoucherUsedScalarWhereInput | VoucherUsedScalarWhereInput[]
    OR?: VoucherUsedScalarWhereInput[]
    NOT?: VoucherUsedScalarWhereInput | VoucherUsedScalarWhereInput[]
    id?: IntFilter<"VoucherUsed"> | number
    userId?: IntNullableFilter<"VoucherUsed"> | number | null
    voucherId?: IntNullableFilter<"VoucherUsed"> | number | null
    createdAt?: DateTimeNullableFilter<"VoucherUsed"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"VoucherUsed"> | Date | string | null
  }

  export type UserCreateWithoutAddressUserInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    blog?: BlogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressUserInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartUncheckedCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageUncheckedCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageUncheckedCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressUserInput, UserUncheckedCreateWithoutAddressUserInput>
  }

  export type OrderProductCreateWithoutAddressUserInput = {
    status?: $Enums.Status | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    typeShip?: TypeShipCreateNestedOneWithoutOrderProductInput
    voucher?: VoucherCreateNestedOneWithoutOrderProductInput
    OrderDetaill?: OrderDetaillCreateNestedManyWithoutOrderInput
  }

  export type OrderProductUncheckedCreateWithoutAddressUserInput = {
    id?: number
    status?: $Enums.Status | null
    typeShipId?: number | null
    voucherId?: number | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderDetaill?: OrderDetaillUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderProductCreateOrConnectWithoutAddressUserInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutAddressUserInput, OrderProductUncheckedCreateWithoutAddressUserInput>
  }

  export type OrderProductCreateManyAddressUserInputEnvelope = {
    data: OrderProductCreateManyAddressUserInput | OrderProductCreateManyAddressUserInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAddressUserInput = {
    update: XOR<UserUpdateWithoutAddressUserInput, UserUncheckedUpdateWithoutAddressUserInput>
    create: XOR<UserCreateWithoutAddressUserInput, UserUncheckedCreateWithoutAddressUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressUserInput, UserUncheckedUpdateWithoutAddressUserInput>
  }

  export type UserUpdateWithoutAddressUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blog?: BlogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    blog?: BlogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUncheckedUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUncheckedUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUncheckedUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderProductUpsertWithWhereUniqueWithoutAddressUserInput = {
    where: OrderProductWhereUniqueInput
    update: XOR<OrderProductUpdateWithoutAddressUserInput, OrderProductUncheckedUpdateWithoutAddressUserInput>
    create: XOR<OrderProductCreateWithoutAddressUserInput, OrderProductUncheckedCreateWithoutAddressUserInput>
  }

  export type OrderProductUpdateWithWhereUniqueWithoutAddressUserInput = {
    where: OrderProductWhereUniqueInput
    data: XOR<OrderProductUpdateWithoutAddressUserInput, OrderProductUncheckedUpdateWithoutAddressUserInput>
  }

  export type OrderProductUpdateManyWithWhereWithoutAddressUserInput = {
    where: OrderProductScalarWhereInput
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyWithoutAddressUserInput>
  }

  export type OrderProductScalarWhereInput = {
    AND?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
    OR?: OrderProductScalarWhereInput[]
    NOT?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
    id?: IntFilter<"OrderProduct"> | number
    addressUserId?: IntNullableFilter<"OrderProduct"> | number | null
    status?: EnumStatusNullableFilter<"OrderProduct"> | $Enums.Status | null
    typeShipId?: IntNullableFilter<"OrderProduct"> | number | null
    voucherId?: IntNullableFilter<"OrderProduct"> | number | null
    image?: StringNullableFilter<"OrderProduct"> | string | null
    createdAt?: DateTimeNullableFilter<"OrderProduct"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"OrderProduct"> | Date | string | null
  }

  export type UserCreateWithoutBlogInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlogInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartUncheckedCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageUncheckedCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageUncheckedCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlogInput, UserUncheckedCreateWithoutBlogInput>
  }

  export type CommentCreateWithoutBlogInput = {
    content?: string | null
    image?: string | null
    parentId?: number | null
    star?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    product?: ProductCreateNestedOneWithoutCommentInput
    user?: UserCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutBlogInput = {
    id?: number
    content?: string | null
    image?: string | null
    parentId?: number | null
    productId?: number | null
    userId?: number | null
    star?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CommentCreateOrConnectWithoutBlogInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput>
  }

  export type CommentCreateManyBlogInputEnvelope = {
    data: CommentCreateManyBlogInput | CommentCreateManyBlogInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBlogInput = {
    update: XOR<UserUpdateWithoutBlogInput, UserUncheckedUpdateWithoutBlogInput>
    create: XOR<UserCreateWithoutBlogInput, UserUncheckedCreateWithoutBlogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlogInput, UserUncheckedUpdateWithoutBlogInput>
  }

  export type UserUpdateWithoutBlogInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlogInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUncheckedUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUncheckedUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUncheckedUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutBlogInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutBlogInput, CommentUncheckedUpdateWithoutBlogInput>
    create: XOR<CommentCreateWithoutBlogInput, CommentUncheckedCreateWithoutBlogInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutBlogInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutBlogInput, CommentUncheckedUpdateWithoutBlogInput>
  }

  export type CommentUpdateManyWithWhereWithoutBlogInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutBlogInput>
  }

  export type ProductCreateWithoutCommentInput = {
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    view?: number | null
    material?: string | null
    originalPrice?: number | null
    discountPrice?: number | null
    category?: CategoryCreateNestedOneWithoutProductInput
    brand?: BrandCreateNestedOneWithoutProductInput
    OrderDetaill?: OrderDetaillCreateNestedManyWithoutProductInput
    ProductSize?: ProductSizeCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCommentInput = {
    id?: number
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    categoryId?: number | null
    view?: number | null
    material?: string | null
    brandId?: number | null
    originalPrice?: number | null
    discountPrice?: number | null
    OrderDetaill?: OrderDetaillUncheckedCreateNestedManyWithoutProductInput
    ProductSize?: ProductSizeUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCommentInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCommentInput, ProductUncheckedCreateWithoutCommentInput>
  }

  export type UserCreateWithoutCommentInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedManyWithoutUserInput
    blog?: BlogCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserUncheckedCreateNestedManyWithoutUserInput
    blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartUncheckedCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageUncheckedCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageUncheckedCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
  }

  export type BlogCreateWithoutCommentInput = {
    title?: string | null
    subject?: $Enums.Subject | null
    status?: $Enums.Status | null
    image?: string | null
    contentMarkdown?: string | null
    contentHTML?: string | null
    view?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutBlogInput
  }

  export type BlogUncheckedCreateWithoutCommentInput = {
    id?: number
    title?: string | null
    subject?: $Enums.Subject | null
    status?: $Enums.Status | null
    image?: string | null
    contentMarkdown?: string | null
    contentHTML?: string | null
    userId?: number | null
    view?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BlogCreateOrConnectWithoutCommentInput = {
    where: BlogWhereUniqueInput
    create: XOR<BlogCreateWithoutCommentInput, BlogUncheckedCreateWithoutCommentInput>
  }

  export type ProductUpsertWithoutCommentInput = {
    update: XOR<ProductUpdateWithoutCommentInput, ProductUncheckedUpdateWithoutCommentInput>
    create: XOR<ProductCreateWithoutCommentInput, ProductUncheckedCreateWithoutCommentInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCommentInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCommentInput, ProductUncheckedUpdateWithoutCommentInput>
  }

  export type ProductUpdateWithoutCommentInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    category?: CategoryUpdateOneWithoutProductNestedInput
    brand?: BrandUpdateOneWithoutProductNestedInput
    OrderDetaill?: OrderDetaillUpdateManyWithoutProductNestedInput
    ProductSize?: ProductSizeUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    OrderDetaill?: OrderDetaillUncheckedUpdateManyWithoutProductNestedInput
    ProductSize?: ProductSizeUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserUpsertWithoutCommentInput = {
    update: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateWithoutCommentInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateManyWithoutUserNestedInput
    blog?: BlogUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUncheckedUpdateManyWithoutUserNestedInput
    blog?: BlogUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUncheckedUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUncheckedUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUncheckedUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BlogUpsertWithoutCommentInput = {
    update: XOR<BlogUpdateWithoutCommentInput, BlogUncheckedUpdateWithoutCommentInput>
    create: XOR<BlogCreateWithoutCommentInput, BlogUncheckedCreateWithoutCommentInput>
    where?: BlogWhereInput
  }

  export type BlogUpdateToOneWithWhereWithoutCommentInput = {
    where?: BlogWhereInput
    data: XOR<BlogUpdateWithoutCommentInput, BlogUncheckedUpdateWithoutCommentInput>
  }

  export type BlogUpdateWithoutCommentInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableEnumSubjectFieldUpdateOperationsInput | $Enums.Subject | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableEnumSubjectFieldUpdateOperationsInput | $Enums.Subject | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutMessageInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedManyWithoutUserInput
    blog?: BlogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessageInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserUncheckedCreateNestedManyWithoutUserInput
    blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartUncheckedCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageUncheckedCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageUncheckedCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
  }

  export type RoomMessageCreateWithoutMessagesInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userOne?: UserCreateNestedOneWithoutRoomMessagesOneInput
    userTwo?: UserCreateNestedOneWithoutRoomMessagesTwoInput
  }

  export type RoomMessageUncheckedCreateWithoutMessagesInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userOneId?: number | null
    userTwoId?: number | null
  }

  export type RoomMessageCreateOrConnectWithoutMessagesInput = {
    where: RoomMessageWhereUniqueInput
    create: XOR<RoomMessageCreateWithoutMessagesInput, RoomMessageUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutMessageInput = {
    update: XOR<UserUpdateWithoutMessageInput, UserUncheckedUpdateWithoutMessageInput>
    create: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageInput, UserUncheckedUpdateWithoutMessageInput>
  }

  export type UserUpdateWithoutMessageInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateManyWithoutUserNestedInput
    blog?: BlogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUncheckedUpdateManyWithoutUserNestedInput
    blog?: BlogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUncheckedUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUncheckedUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUncheckedUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoomMessageUpsertWithoutMessagesInput = {
    update: XOR<RoomMessageUpdateWithoutMessagesInput, RoomMessageUncheckedUpdateWithoutMessagesInput>
    create: XOR<RoomMessageCreateWithoutMessagesInput, RoomMessageUncheckedCreateWithoutMessagesInput>
    where?: RoomMessageWhereInput
  }

  export type RoomMessageUpdateToOneWithWhereWithoutMessagesInput = {
    where?: RoomMessageWhereInput
    data: XOR<RoomMessageUpdateWithoutMessagesInput, RoomMessageUncheckedUpdateWithoutMessagesInput>
  }

  export type RoomMessageUpdateWithoutMessagesInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userOne?: UserUpdateOneWithoutRoomMessagesOneNestedInput
    userTwo?: UserUpdateOneWithoutRoomMessagesTwoNestedInput
  }

  export type RoomMessageUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userOneId?: NullableIntFieldUpdateOperationsInput | number | null
    userTwoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderProductCreateWithoutOrderDetaillInput = {
    status?: $Enums.Status | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedOneWithoutOrderProductInput
    typeShip?: TypeShipCreateNestedOneWithoutOrderProductInput
    voucher?: VoucherCreateNestedOneWithoutOrderProductInput
  }

  export type OrderProductUncheckedCreateWithoutOrderDetaillInput = {
    id?: number
    addressUserId?: number | null
    status?: $Enums.Status | null
    typeShipId?: number | null
    voucherId?: number | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderProductCreateOrConnectWithoutOrderDetaillInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutOrderDetaillInput, OrderProductUncheckedCreateWithoutOrderDetaillInput>
  }

  export type ProductCreateWithoutOrderDetaillInput = {
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    view?: number | null
    material?: string | null
    originalPrice?: number | null
    discountPrice?: number | null
    category?: CategoryCreateNestedOneWithoutProductInput
    brand?: BrandCreateNestedOneWithoutProductInput
    Comment?: CommentCreateNestedManyWithoutProductInput
    ProductSize?: ProductSizeCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderDetaillInput = {
    id?: number
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    categoryId?: number | null
    view?: number | null
    material?: string | null
    brandId?: number | null
    originalPrice?: number | null
    discountPrice?: number | null
    Comment?: CommentUncheckedCreateNestedManyWithoutProductInput
    ProductSize?: ProductSizeUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderDetaillInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderDetaillInput, ProductUncheckedCreateWithoutOrderDetaillInput>
  }

  export type OrderProductUpsertWithoutOrderDetaillInput = {
    update: XOR<OrderProductUpdateWithoutOrderDetaillInput, OrderProductUncheckedUpdateWithoutOrderDetaillInput>
    create: XOR<OrderProductCreateWithoutOrderDetaillInput, OrderProductUncheckedCreateWithoutOrderDetaillInput>
    where?: OrderProductWhereInput
  }

  export type OrderProductUpdateToOneWithWhereWithoutOrderDetaillInput = {
    where?: OrderProductWhereInput
    data: XOR<OrderProductUpdateWithoutOrderDetaillInput, OrderProductUncheckedUpdateWithoutOrderDetaillInput>
  }

  export type OrderProductUpdateWithoutOrderDetaillInput = {
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateOneWithoutOrderProductNestedInput
    typeShip?: TypeShipUpdateOneWithoutOrderProductNestedInput
    voucher?: VoucherUpdateOneWithoutOrderProductNestedInput
  }

  export type OrderProductUncheckedUpdateWithoutOrderDetaillInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    typeShipId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUpsertWithoutOrderDetaillInput = {
    update: XOR<ProductUpdateWithoutOrderDetaillInput, ProductUncheckedUpdateWithoutOrderDetaillInput>
    create: XOR<ProductCreateWithoutOrderDetaillInput, ProductUncheckedCreateWithoutOrderDetaillInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderDetaillInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderDetaillInput, ProductUncheckedUpdateWithoutOrderDetaillInput>
  }

  export type ProductUpdateWithoutOrderDetaillInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    category?: CategoryUpdateOneWithoutProductNestedInput
    brand?: BrandUpdateOneWithoutProductNestedInput
    Comment?: CommentUpdateManyWithoutProductNestedInput
    ProductSize?: ProductSizeUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderDetaillInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    Comment?: CommentUncheckedUpdateManyWithoutProductNestedInput
    ProductSize?: ProductSizeUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type AddressUserCreateWithoutOrderProductInput = {
    shipName?: string | null
    shipAdress?: string | null
    shipPhone?: string | null
    shipEmail?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAddressUserInput
  }

  export type AddressUserUncheckedCreateWithoutOrderProductInput = {
    id?: number
    userId: number
    shipName?: string | null
    shipAdress?: string | null
    shipPhone?: string | null
    shipEmail?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AddressUserCreateOrConnectWithoutOrderProductInput = {
    where: AddressUserWhereUniqueInput
    create: XOR<AddressUserCreateWithoutOrderProductInput, AddressUserUncheckedCreateWithoutOrderProductInput>
  }

  export type TypeShipCreateWithoutOrderProductInput = {
    name: string
    price?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TypeShipUncheckedCreateWithoutOrderProductInput = {
    id?: number
    name: string
    price?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TypeShipCreateOrConnectWithoutOrderProductInput = {
    where: TypeShipWhereUniqueInput
    create: XOR<TypeShipCreateWithoutOrderProductInput, TypeShipUncheckedCreateWithoutOrderProductInput>
  }

  export type VoucherCreateWithoutOrderProductInput = {
    fromDate?: Date | string | null
    toDate?: Date | string | null
    amount?: number | null
    codeVoucher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    typeVoucher?: TypeVoucherCreateNestedOneWithoutVoucherInput
    VoucherUsed?: VoucherUsedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutOrderProductInput = {
    id?: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    typeVoucherId?: number | null
    amount?: number | null
    codeVoucher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    VoucherUsed?: VoucherUsedUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutOrderProductInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutOrderProductInput, VoucherUncheckedCreateWithoutOrderProductInput>
  }

  export type OrderDetaillCreateWithoutOrderInput = {
    quantity?: number | null
    realPrice?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    product?: ProductCreateNestedOneWithoutOrderDetaillInput
  }

  export type OrderDetaillUncheckedCreateWithoutOrderInput = {
    id?: number
    productId?: number | null
    quantity?: number | null
    realPrice?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderDetaillCreateOrConnectWithoutOrderInput = {
    where: OrderDetaillWhereUniqueInput
    create: XOR<OrderDetaillCreateWithoutOrderInput, OrderDetaillUncheckedCreateWithoutOrderInput>
  }

  export type OrderDetaillCreateManyOrderInputEnvelope = {
    data: OrderDetaillCreateManyOrderInput | OrderDetaillCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type AddressUserUpsertWithoutOrderProductInput = {
    update: XOR<AddressUserUpdateWithoutOrderProductInput, AddressUserUncheckedUpdateWithoutOrderProductInput>
    create: XOR<AddressUserCreateWithoutOrderProductInput, AddressUserUncheckedCreateWithoutOrderProductInput>
    where?: AddressUserWhereInput
  }

  export type AddressUserUpdateToOneWithWhereWithoutOrderProductInput = {
    where?: AddressUserWhereInput
    data: XOR<AddressUserUpdateWithoutOrderProductInput, AddressUserUncheckedUpdateWithoutOrderProductInput>
  }

  export type AddressUserUpdateWithoutOrderProductInput = {
    shipName?: NullableStringFieldUpdateOperationsInput | string | null
    shipAdress?: NullableStringFieldUpdateOperationsInput | string | null
    shipPhone?: NullableStringFieldUpdateOperationsInput | string | null
    shipEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAddressUserNestedInput
  }

  export type AddressUserUncheckedUpdateWithoutOrderProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    shipName?: NullableStringFieldUpdateOperationsInput | string | null
    shipAdress?: NullableStringFieldUpdateOperationsInput | string | null
    shipPhone?: NullableStringFieldUpdateOperationsInput | string | null
    shipEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypeShipUpsertWithoutOrderProductInput = {
    update: XOR<TypeShipUpdateWithoutOrderProductInput, TypeShipUncheckedUpdateWithoutOrderProductInput>
    create: XOR<TypeShipCreateWithoutOrderProductInput, TypeShipUncheckedCreateWithoutOrderProductInput>
    where?: TypeShipWhereInput
  }

  export type TypeShipUpdateToOneWithWhereWithoutOrderProductInput = {
    where?: TypeShipWhereInput
    data: XOR<TypeShipUpdateWithoutOrderProductInput, TypeShipUncheckedUpdateWithoutOrderProductInput>
  }

  export type TypeShipUpdateWithoutOrderProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypeShipUncheckedUpdateWithoutOrderProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUpsertWithoutOrderProductInput = {
    update: XOR<VoucherUpdateWithoutOrderProductInput, VoucherUncheckedUpdateWithoutOrderProductInput>
    create: XOR<VoucherCreateWithoutOrderProductInput, VoucherUncheckedCreateWithoutOrderProductInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutOrderProductInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutOrderProductInput, VoucherUncheckedUpdateWithoutOrderProductInput>
  }

  export type VoucherUpdateWithoutOrderProductInput = {
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    codeVoucher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typeVoucher?: TypeVoucherUpdateOneWithoutVoucherNestedInput
    VoucherUsed?: VoucherUsedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutOrderProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    codeVoucher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    VoucherUsed?: VoucherUsedUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type OrderDetaillUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderDetaillWhereUniqueInput
    update: XOR<OrderDetaillUpdateWithoutOrderInput, OrderDetaillUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderDetaillCreateWithoutOrderInput, OrderDetaillUncheckedCreateWithoutOrderInput>
  }

  export type OrderDetaillUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderDetaillWhereUniqueInput
    data: XOR<OrderDetaillUpdateWithoutOrderInput, OrderDetaillUncheckedUpdateWithoutOrderInput>
  }

  export type OrderDetaillUpdateManyWithWhereWithoutOrderInput = {
    where: OrderDetaillScalarWhereInput
    data: XOR<OrderDetaillUpdateManyMutationInput, OrderDetaillUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderDetaillScalarWhereInput = {
    AND?: OrderDetaillScalarWhereInput | OrderDetaillScalarWhereInput[]
    OR?: OrderDetaillScalarWhereInput[]
    NOT?: OrderDetaillScalarWhereInput | OrderDetaillScalarWhereInput[]
    id?: IntFilter<"OrderDetaill"> | number
    orderId?: IntNullableFilter<"OrderDetaill"> | number | null
    productId?: IntNullableFilter<"OrderDetaill"> | number | null
    quantity?: IntNullableFilter<"OrderDetaill"> | number | null
    realPrice?: IntNullableFilter<"OrderDetaill"> | number | null
    createdAt?: DateTimeNullableFilter<"OrderDetaill"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"OrderDetaill"> | Date | string | null
  }

  export type ProductCreateWithoutProductSizeInput = {
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    view?: number | null
    material?: string | null
    originalPrice?: number | null
    discountPrice?: number | null
    category?: CategoryCreateNestedOneWithoutProductInput
    brand?: BrandCreateNestedOneWithoutProductInput
    Comment?: CommentCreateNestedManyWithoutProductInput
    OrderDetaill?: OrderDetaillCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductSizeInput = {
    id?: number
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    categoryId?: number | null
    view?: number | null
    material?: string | null
    brandId?: number | null
    originalPrice?: number | null
    discountPrice?: number | null
    Comment?: CommentUncheckedCreateNestedManyWithoutProductInput
    OrderDetaill?: OrderDetaillUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductSizeInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductSizeInput, ProductUncheckedCreateWithoutProductSizeInput>
  }

  export type ShopCartCreateWithoutProductSizeInput = {
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutShopCartInput
  }

  export type ShopCartUncheckedCreateWithoutProductSizeInput = {
    id?: number
    userId?: number | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ShopCartCreateOrConnectWithoutProductSizeInput = {
    where: ShopCartWhereUniqueInput
    create: XOR<ShopCartCreateWithoutProductSizeInput, ShopCartUncheckedCreateWithoutProductSizeInput>
  }

  export type ShopCartCreateManyProductSizeInputEnvelope = {
    data: ShopCartCreateManyProductSizeInput | ShopCartCreateManyProductSizeInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutProductSizeInput = {
    update: XOR<ProductUpdateWithoutProductSizeInput, ProductUncheckedUpdateWithoutProductSizeInput>
    create: XOR<ProductCreateWithoutProductSizeInput, ProductUncheckedCreateWithoutProductSizeInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductSizeInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductSizeInput, ProductUncheckedUpdateWithoutProductSizeInput>
  }

  export type ProductUpdateWithoutProductSizeInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    category?: CategoryUpdateOneWithoutProductNestedInput
    brand?: BrandUpdateOneWithoutProductNestedInput
    Comment?: CommentUpdateManyWithoutProductNestedInput
    OrderDetaill?: OrderDetaillUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductSizeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    Comment?: CommentUncheckedUpdateManyWithoutProductNestedInput
    OrderDetaill?: OrderDetaillUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ShopCartUpsertWithWhereUniqueWithoutProductSizeInput = {
    where: ShopCartWhereUniqueInput
    update: XOR<ShopCartUpdateWithoutProductSizeInput, ShopCartUncheckedUpdateWithoutProductSizeInput>
    create: XOR<ShopCartCreateWithoutProductSizeInput, ShopCartUncheckedCreateWithoutProductSizeInput>
  }

  export type ShopCartUpdateWithWhereUniqueWithoutProductSizeInput = {
    where: ShopCartWhereUniqueInput
    data: XOR<ShopCartUpdateWithoutProductSizeInput, ShopCartUncheckedUpdateWithoutProductSizeInput>
  }

  export type ShopCartUpdateManyWithWhereWithoutProductSizeInput = {
    where: ShopCartScalarWhereInput
    data: XOR<ShopCartUpdateManyMutationInput, ShopCartUncheckedUpdateManyWithoutProductSizeInput>
  }

  export type ProductCreateWithoutProductImageInput = {
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    view?: number | null
    material?: string | null
    originalPrice?: number | null
    discountPrice?: number | null
    category?: CategoryCreateNestedOneWithoutProductInput
    brand?: BrandCreateNestedOneWithoutProductInput
    Comment?: CommentCreateNestedManyWithoutProductInput
    OrderDetaill?: OrderDetaillCreateNestedManyWithoutProductInput
    ProductSize?: ProductSizeCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductImageInput = {
    id?: number
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    categoryId?: number | null
    view?: number | null
    material?: string | null
    brandId?: number | null
    originalPrice?: number | null
    discountPrice?: number | null
    Comment?: CommentUncheckedCreateNestedManyWithoutProductInput
    OrderDetaill?: OrderDetaillUncheckedCreateNestedManyWithoutProductInput
    ProductSize?: ProductSizeUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductImageInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductImageInput, ProductUncheckedCreateWithoutProductImageInput>
  }

  export type ProductUpsertWithoutProductImageInput = {
    update: XOR<ProductUpdateWithoutProductImageInput, ProductUncheckedUpdateWithoutProductImageInput>
    create: XOR<ProductCreateWithoutProductImageInput, ProductUncheckedCreateWithoutProductImageInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductImageInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductImageInput, ProductUncheckedUpdateWithoutProductImageInput>
  }

  export type ProductUpdateWithoutProductImageInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    category?: CategoryUpdateOneWithoutProductNestedInput
    brand?: BrandUpdateOneWithoutProductNestedInput
    Comment?: CommentUpdateManyWithoutProductNestedInput
    OrderDetaill?: OrderDetaillUpdateManyWithoutProductNestedInput
    ProductSize?: ProductSizeUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    Comment?: CommentUncheckedUpdateManyWithoutProductNestedInput
    OrderDetaill?: OrderDetaillUncheckedUpdateManyWithoutProductNestedInput
    ProductSize?: ProductSizeUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CategoryCreateWithoutProductInput = {
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    brand?: BrandCreateNestedOneWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
    brandId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CategoryCreateOrConnectWithoutProductInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductInput, CategoryUncheckedCreateWithoutProductInput>
  }

  export type BrandCreateWithoutProductInput = {
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Category?: CategoryCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Category?: CategoryUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutProductInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutProductInput, BrandUncheckedCreateWithoutProductInput>
  }

  export type CommentCreateWithoutProductInput = {
    content?: string | null
    image?: string | null
    parentId?: number | null
    star?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutCommentInput
    blog?: BlogCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutProductInput = {
    id?: number
    content?: string | null
    image?: string | null
    parentId?: number | null
    userId?: number | null
    blogId?: number | null
    star?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CommentCreateOrConnectWithoutProductInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutProductInput, CommentUncheckedCreateWithoutProductInput>
  }

  export type CommentCreateManyProductInputEnvelope = {
    data: CommentCreateManyProductInput | CommentCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderDetaillCreateWithoutProductInput = {
    quantity?: number | null
    realPrice?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    order?: OrderProductCreateNestedOneWithoutOrderDetaillInput
  }

  export type OrderDetaillUncheckedCreateWithoutProductInput = {
    id?: number
    orderId?: number | null
    quantity?: number | null
    realPrice?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderDetaillCreateOrConnectWithoutProductInput = {
    where: OrderDetaillWhereUniqueInput
    create: XOR<OrderDetaillCreateWithoutProductInput, OrderDetaillUncheckedCreateWithoutProductInput>
  }

  export type OrderDetaillCreateManyProductInputEnvelope = {
    data: OrderDetaillCreateManyProductInput | OrderDetaillCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductSizeCreateWithoutProductInput = {
    size?: $Enums.Size | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ShopCart?: ShopCartCreateNestedManyWithoutProductSizeInput
  }

  export type ProductSizeUncheckedCreateWithoutProductInput = {
    id?: number
    size?: $Enums.Size | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ShopCart?: ShopCartUncheckedCreateNestedManyWithoutProductSizeInput
  }

  export type ProductSizeCreateOrConnectWithoutProductInput = {
    where: ProductSizeWhereUniqueInput
    create: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput>
  }

  export type ProductSizeCreateManyProductInputEnvelope = {
    data: ProductSizeCreateManyProductInput | ProductSizeCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductImageCreateWithoutProductInput = {
    image_url?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductImageUncheckedCreateWithoutProductInput = {
    id?: number
    image_url?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductImageCreateOrConnectWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageCreateManyProductInputEnvelope = {
    data: ProductImageCreateManyProductInput | ProductImageCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutProductInput = {
    update: XOR<CategoryUpdateWithoutProductInput, CategoryUncheckedUpdateWithoutProductInput>
    create: XOR<CategoryCreateWithoutProductInput, CategoryUncheckedCreateWithoutProductInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductInput, CategoryUncheckedUpdateWithoutProductInput>
  }

  export type CategoryUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: BrandUpdateOneWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BrandUpsertWithoutProductInput = {
    update: XOR<BrandUpdateWithoutProductInput, BrandUncheckedUpdateWithoutProductInput>
    create: XOR<BrandCreateWithoutProductInput, BrandUncheckedCreateWithoutProductInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutProductInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutProductInput, BrandUncheckedUpdateWithoutProductInput>
  }

  export type BrandUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Category?: CategoryUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Category?: CategoryUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutProductInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutProductInput, CommentUncheckedUpdateWithoutProductInput>
    create: XOR<CommentCreateWithoutProductInput, CommentUncheckedCreateWithoutProductInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutProductInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutProductInput, CommentUncheckedUpdateWithoutProductInput>
  }

  export type CommentUpdateManyWithWhereWithoutProductInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderDetaillUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderDetaillWhereUniqueInput
    update: XOR<OrderDetaillUpdateWithoutProductInput, OrderDetaillUncheckedUpdateWithoutProductInput>
    create: XOR<OrderDetaillCreateWithoutProductInput, OrderDetaillUncheckedCreateWithoutProductInput>
  }

  export type OrderDetaillUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderDetaillWhereUniqueInput
    data: XOR<OrderDetaillUpdateWithoutProductInput, OrderDetaillUncheckedUpdateWithoutProductInput>
  }

  export type OrderDetaillUpdateManyWithWhereWithoutProductInput = {
    where: OrderDetaillScalarWhereInput
    data: XOR<OrderDetaillUpdateManyMutationInput, OrderDetaillUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductSizeUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductSizeWhereUniqueInput
    update: XOR<ProductSizeUpdateWithoutProductInput, ProductSizeUncheckedUpdateWithoutProductInput>
    create: XOR<ProductSizeCreateWithoutProductInput, ProductSizeUncheckedCreateWithoutProductInput>
  }

  export type ProductSizeUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductSizeWhereUniqueInput
    data: XOR<ProductSizeUpdateWithoutProductInput, ProductSizeUncheckedUpdateWithoutProductInput>
  }

  export type ProductSizeUpdateManyWithWhereWithoutProductInput = {
    where: ProductSizeScalarWhereInput
    data: XOR<ProductSizeUpdateManyMutationInput, ProductSizeUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductSizeScalarWhereInput = {
    AND?: ProductSizeScalarWhereInput | ProductSizeScalarWhereInput[]
    OR?: ProductSizeScalarWhereInput[]
    NOT?: ProductSizeScalarWhereInput | ProductSizeScalarWhereInput[]
    id?: IntFilter<"ProductSize"> | number
    productId?: IntNullableFilter<"ProductSize"> | number | null
    size?: EnumSizeNullableFilter<"ProductSize"> | $Enums.Size | null
    quantity?: IntNullableFilter<"ProductSize"> | number | null
    createdAt?: DateTimeNullableFilter<"ProductSize"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ProductSize"> | Date | string | null
  }

  export type ProductImageUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    update: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    data: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
  }

  export type ProductImageUpdateManyWithWhereWithoutProductInput = {
    where: ProductImageScalarWhereInput
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductImageScalarWhereInput = {
    AND?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    OR?: ProductImageScalarWhereInput[]
    NOT?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    id?: IntFilter<"ProductImage"> | number
    productId?: IntNullableFilter<"ProductImage"> | number | null
    image_url?: StringNullableFilter<"ProductImage"> | string | null
    createdAt?: DateTimeNullableFilter<"ProductImage"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ProductImage"> | Date | string | null
  }

  export type UserCreateWithoutRoomMessagesOneInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedManyWithoutUserInput
    blog?: BlogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartCreateNestedManyWithoutUserInput
    roomMessagesTwo?: RoomMessageCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoomMessagesOneInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserUncheckedCreateNestedManyWithoutUserInput
    blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartUncheckedCreateNestedManyWithoutUserInput
    roomMessagesTwo?: RoomMessageUncheckedCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoomMessagesOneInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoomMessagesOneInput, UserUncheckedCreateWithoutRoomMessagesOneInput>
  }

  export type UserCreateWithoutRoomMessagesTwoInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedManyWithoutUserInput
    blog?: BlogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageCreateNestedManyWithoutUserOneInput
    Receipt?: ReceiptCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoomMessagesTwoInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserUncheckedCreateNestedManyWithoutUserInput
    blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartUncheckedCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageUncheckedCreateNestedManyWithoutUserOneInput
    Receipt?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoomMessagesTwoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoomMessagesTwoInput, UserUncheckedCreateWithoutRoomMessagesTwoInput>
  }

  export type MessageCreateWithoutRoomInput = {
    text?: string | null
    unRead?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutRoomInput = {
    id?: number
    text?: string | null
    userId?: number | null
    unRead?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MessageCreateOrConnectWithoutRoomInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRoomInput, MessageUncheckedCreateWithoutRoomInput>
  }

  export type MessageCreateManyRoomInputEnvelope = {
    data: MessageCreateManyRoomInput | MessageCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRoomMessagesOneInput = {
    update: XOR<UserUpdateWithoutRoomMessagesOneInput, UserUncheckedUpdateWithoutRoomMessagesOneInput>
    create: XOR<UserCreateWithoutRoomMessagesOneInput, UserUncheckedCreateWithoutRoomMessagesOneInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoomMessagesOneInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoomMessagesOneInput, UserUncheckedUpdateWithoutRoomMessagesOneInput>
  }

  export type UserUpdateWithoutRoomMessagesOneInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateManyWithoutUserNestedInput
    blog?: BlogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUpdateManyWithoutUserNestedInput
    roomMessagesTwo?: RoomMessageUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoomMessagesOneInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUncheckedUpdateManyWithoutUserNestedInput
    blog?: BlogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUncheckedUpdateManyWithoutUserNestedInput
    roomMessagesTwo?: RoomMessageUncheckedUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutRoomMessagesTwoInput = {
    update: XOR<UserUpdateWithoutRoomMessagesTwoInput, UserUncheckedUpdateWithoutRoomMessagesTwoInput>
    create: XOR<UserCreateWithoutRoomMessagesTwoInput, UserUncheckedCreateWithoutRoomMessagesTwoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoomMessagesTwoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoomMessagesTwoInput, UserUncheckedUpdateWithoutRoomMessagesTwoInput>
  }

  export type UserUpdateWithoutRoomMessagesTwoInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateManyWithoutUserNestedInput
    blog?: BlogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUpdateManyWithoutUserOneNestedInput
    Receipt?: ReceiptUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoomMessagesTwoInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUncheckedUpdateManyWithoutUserNestedInput
    blog?: BlogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUncheckedUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUncheckedUpdateManyWithoutUserOneNestedInput
    Receipt?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutRoomInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutRoomInput, MessageUncheckedUpdateWithoutRoomInput>
    create: XOR<MessageCreateWithoutRoomInput, MessageUncheckedCreateWithoutRoomInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutRoomInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutRoomInput, MessageUncheckedUpdateWithoutRoomInput>
  }

  export type MessageUpdateManyWithWhereWithoutRoomInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutRoomInput>
  }

  export type UserCreateWithoutShopCartInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedManyWithoutUserInput
    blog?: BlogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShopCartInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserUncheckedCreateNestedManyWithoutUserInput
    blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageUncheckedCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageUncheckedCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptUncheckedCreateNestedManyWithoutUserInput
    VoucherUsed?: VoucherUsedUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShopCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShopCartInput, UserUncheckedCreateWithoutShopCartInput>
  }

  export type ProductSizeCreateWithoutShopCartInput = {
    size?: $Enums.Size | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    product?: ProductCreateNestedOneWithoutProductSizeInput
  }

  export type ProductSizeUncheckedCreateWithoutShopCartInput = {
    id?: number
    productId?: number | null
    size?: $Enums.Size | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductSizeCreateOrConnectWithoutShopCartInput = {
    where: ProductSizeWhereUniqueInput
    create: XOR<ProductSizeCreateWithoutShopCartInput, ProductSizeUncheckedCreateWithoutShopCartInput>
  }

  export type UserUpsertWithoutShopCartInput = {
    update: XOR<UserUpdateWithoutShopCartInput, UserUncheckedUpdateWithoutShopCartInput>
    create: XOR<UserCreateWithoutShopCartInput, UserUncheckedCreateWithoutShopCartInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShopCartInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShopCartInput, UserUncheckedUpdateWithoutShopCartInput>
  }

  export type UserUpdateWithoutShopCartInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateManyWithoutUserNestedInput
    blog?: BlogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShopCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUncheckedUpdateManyWithoutUserNestedInput
    blog?: BlogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUncheckedUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUncheckedUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
    VoucherUsed?: VoucherUsedUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductSizeUpsertWithoutShopCartInput = {
    update: XOR<ProductSizeUpdateWithoutShopCartInput, ProductSizeUncheckedUpdateWithoutShopCartInput>
    create: XOR<ProductSizeCreateWithoutShopCartInput, ProductSizeUncheckedCreateWithoutShopCartInput>
    where?: ProductSizeWhereInput
  }

  export type ProductSizeUpdateToOneWithWhereWithoutShopCartInput = {
    where?: ProductSizeWhereInput
    data: XOR<ProductSizeUpdateWithoutShopCartInput, ProductSizeUncheckedUpdateWithoutShopCartInput>
  }

  export type ProductSizeUpdateWithoutShopCartInput = {
    size?: NullableEnumSizeFieldUpdateOperationsInput | $Enums.Size | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneWithoutProductSizeNestedInput
  }

  export type ProductSizeUncheckedUpdateWithoutShopCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableEnumSizeFieldUpdateOperationsInput | $Enums.Size | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderProductCreateWithoutTypeShipInput = {
    status?: $Enums.Status | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedOneWithoutOrderProductInput
    voucher?: VoucherCreateNestedOneWithoutOrderProductInput
    OrderDetaill?: OrderDetaillCreateNestedManyWithoutOrderInput
  }

  export type OrderProductUncheckedCreateWithoutTypeShipInput = {
    id?: number
    addressUserId?: number | null
    status?: $Enums.Status | null
    voucherId?: number | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderDetaill?: OrderDetaillUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderProductCreateOrConnectWithoutTypeShipInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutTypeShipInput, OrderProductUncheckedCreateWithoutTypeShipInput>
  }

  export type OrderProductCreateManyTypeShipInputEnvelope = {
    data: OrderProductCreateManyTypeShipInput | OrderProductCreateManyTypeShipInput[]
    skipDuplicates?: boolean
  }

  export type OrderProductUpsertWithWhereUniqueWithoutTypeShipInput = {
    where: OrderProductWhereUniqueInput
    update: XOR<OrderProductUpdateWithoutTypeShipInput, OrderProductUncheckedUpdateWithoutTypeShipInput>
    create: XOR<OrderProductCreateWithoutTypeShipInput, OrderProductUncheckedCreateWithoutTypeShipInput>
  }

  export type OrderProductUpdateWithWhereUniqueWithoutTypeShipInput = {
    where: OrderProductWhereUniqueInput
    data: XOR<OrderProductUpdateWithoutTypeShipInput, OrderProductUncheckedUpdateWithoutTypeShipInput>
  }

  export type OrderProductUpdateManyWithWhereWithoutTypeShipInput = {
    where: OrderProductScalarWhereInput
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyWithoutTypeShipInput>
  }

  export type VoucherCreateWithoutTypeVoucherInput = {
    fromDate?: Date | string | null
    toDate?: Date | string | null
    amount?: number | null
    codeVoucher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderProduct?: OrderProductCreateNestedManyWithoutVoucherInput
    VoucherUsed?: VoucherUsedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutTypeVoucherInput = {
    id?: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    amount?: number | null
    codeVoucher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutVoucherInput
    VoucherUsed?: VoucherUsedUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutTypeVoucherInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutTypeVoucherInput, VoucherUncheckedCreateWithoutTypeVoucherInput>
  }

  export type VoucherCreateManyTypeVoucherInputEnvelope = {
    data: VoucherCreateManyTypeVoucherInput | VoucherCreateManyTypeVoucherInput[]
    skipDuplicates?: boolean
  }

  export type VoucherUpsertWithWhereUniqueWithoutTypeVoucherInput = {
    where: VoucherWhereUniqueInput
    update: XOR<VoucherUpdateWithoutTypeVoucherInput, VoucherUncheckedUpdateWithoutTypeVoucherInput>
    create: XOR<VoucherCreateWithoutTypeVoucherInput, VoucherUncheckedCreateWithoutTypeVoucherInput>
  }

  export type VoucherUpdateWithWhereUniqueWithoutTypeVoucherInput = {
    where: VoucherWhereUniqueInput
    data: XOR<VoucherUpdateWithoutTypeVoucherInput, VoucherUncheckedUpdateWithoutTypeVoucherInput>
  }

  export type VoucherUpdateManyWithWhereWithoutTypeVoucherInput = {
    where: VoucherScalarWhereInput
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyWithoutTypeVoucherInput>
  }

  export type VoucherScalarWhereInput = {
    AND?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
    OR?: VoucherScalarWhereInput[]
    NOT?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
    id?: IntFilter<"Voucher"> | number
    fromDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    toDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    typeVoucherId?: IntNullableFilter<"Voucher"> | number | null
    amount?: IntNullableFilter<"Voucher"> | number | null
    codeVoucher?: StringNullableFilter<"Voucher"> | string | null
    createdAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Voucher"> | Date | string | null
  }

  export type TypeVoucherCreateWithoutVoucherInput = {
    typeVoucher?: $Enums.Discount | null
    value?: number | null
    maxValue?: number | null
    minValue?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TypeVoucherUncheckedCreateWithoutVoucherInput = {
    id?: number
    typeVoucher?: $Enums.Discount | null
    value?: number | null
    maxValue?: number | null
    minValue?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TypeVoucherCreateOrConnectWithoutVoucherInput = {
    where: TypeVoucherWhereUniqueInput
    create: XOR<TypeVoucherCreateWithoutVoucherInput, TypeVoucherUncheckedCreateWithoutVoucherInput>
  }

  export type OrderProductCreateWithoutVoucherInput = {
    status?: $Enums.Status | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedOneWithoutOrderProductInput
    typeShip?: TypeShipCreateNestedOneWithoutOrderProductInput
    OrderDetaill?: OrderDetaillCreateNestedManyWithoutOrderInput
  }

  export type OrderProductUncheckedCreateWithoutVoucherInput = {
    id?: number
    addressUserId?: number | null
    status?: $Enums.Status | null
    typeShipId?: number | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderDetaill?: OrderDetaillUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderProductCreateOrConnectWithoutVoucherInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutVoucherInput, OrderProductUncheckedCreateWithoutVoucherInput>
  }

  export type OrderProductCreateManyVoucherInputEnvelope = {
    data: OrderProductCreateManyVoucherInput | OrderProductCreateManyVoucherInput[]
    skipDuplicates?: boolean
  }

  export type VoucherUsedCreateWithoutVoucherInput = {
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutVoucherUsedInput
  }

  export type VoucherUsedUncheckedCreateWithoutVoucherInput = {
    id?: number
    userId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VoucherUsedCreateOrConnectWithoutVoucherInput = {
    where: VoucherUsedWhereUniqueInput
    create: XOR<VoucherUsedCreateWithoutVoucherInput, VoucherUsedUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherUsedCreateManyVoucherInputEnvelope = {
    data: VoucherUsedCreateManyVoucherInput | VoucherUsedCreateManyVoucherInput[]
    skipDuplicates?: boolean
  }

  export type TypeVoucherUpsertWithoutVoucherInput = {
    update: XOR<TypeVoucherUpdateWithoutVoucherInput, TypeVoucherUncheckedUpdateWithoutVoucherInput>
    create: XOR<TypeVoucherCreateWithoutVoucherInput, TypeVoucherUncheckedCreateWithoutVoucherInput>
    where?: TypeVoucherWhereInput
  }

  export type TypeVoucherUpdateToOneWithWhereWithoutVoucherInput = {
    where?: TypeVoucherWhereInput
    data: XOR<TypeVoucherUpdateWithoutVoucherInput, TypeVoucherUncheckedUpdateWithoutVoucherInput>
  }

  export type TypeVoucherUpdateWithoutVoucherInput = {
    typeVoucher?: NullableEnumDiscountFieldUpdateOperationsInput | $Enums.Discount | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TypeVoucherUncheckedUpdateWithoutVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeVoucher?: NullableEnumDiscountFieldUpdateOperationsInput | $Enums.Discount | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    maxValue?: NullableIntFieldUpdateOperationsInput | number | null
    minValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderProductUpsertWithWhereUniqueWithoutVoucherInput = {
    where: OrderProductWhereUniqueInput
    update: XOR<OrderProductUpdateWithoutVoucherInput, OrderProductUncheckedUpdateWithoutVoucherInput>
    create: XOR<OrderProductCreateWithoutVoucherInput, OrderProductUncheckedCreateWithoutVoucherInput>
  }

  export type OrderProductUpdateWithWhereUniqueWithoutVoucherInput = {
    where: OrderProductWhereUniqueInput
    data: XOR<OrderProductUpdateWithoutVoucherInput, OrderProductUncheckedUpdateWithoutVoucherInput>
  }

  export type OrderProductUpdateManyWithWhereWithoutVoucherInput = {
    where: OrderProductScalarWhereInput
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyWithoutVoucherInput>
  }

  export type VoucherUsedUpsertWithWhereUniqueWithoutVoucherInput = {
    where: VoucherUsedWhereUniqueInput
    update: XOR<VoucherUsedUpdateWithoutVoucherInput, VoucherUsedUncheckedUpdateWithoutVoucherInput>
    create: XOR<VoucherUsedCreateWithoutVoucherInput, VoucherUsedUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherUsedUpdateWithWhereUniqueWithoutVoucherInput = {
    where: VoucherUsedWhereUniqueInput
    data: XOR<VoucherUsedUpdateWithoutVoucherInput, VoucherUsedUncheckedUpdateWithoutVoucherInput>
  }

  export type VoucherUsedUpdateManyWithWhereWithoutVoucherInput = {
    where: VoucherUsedScalarWhereInput
    data: XOR<VoucherUsedUpdateManyMutationInput, VoucherUsedUncheckedUpdateManyWithoutVoucherInput>
  }

  export type UserCreateWithoutVoucherUsedInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedManyWithoutUserInput
    blog?: BlogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVoucherUsedInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserUncheckedCreateNestedManyWithoutUserInput
    blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartUncheckedCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageUncheckedCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageUncheckedCreateNestedManyWithoutUserTwoInput
    Receipt?: ReceiptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVoucherUsedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVoucherUsedInput, UserUncheckedCreateWithoutVoucherUsedInput>
  }

  export type VoucherCreateWithoutVoucherUsedInput = {
    fromDate?: Date | string | null
    toDate?: Date | string | null
    amount?: number | null
    codeVoucher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    typeVoucher?: TypeVoucherCreateNestedOneWithoutVoucherInput
    OrderProduct?: OrderProductCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutVoucherUsedInput = {
    id?: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    typeVoucherId?: number | null
    amount?: number | null
    codeVoucher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    OrderProduct?: OrderProductUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutVoucherUsedInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutVoucherUsedInput, VoucherUncheckedCreateWithoutVoucherUsedInput>
  }

  export type UserUpsertWithoutVoucherUsedInput = {
    update: XOR<UserUpdateWithoutVoucherUsedInput, UserUncheckedUpdateWithoutVoucherUsedInput>
    create: XOR<UserCreateWithoutVoucherUsedInput, UserUncheckedCreateWithoutVoucherUsedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVoucherUsedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVoucherUsedInput, UserUncheckedUpdateWithoutVoucherUsedInput>
  }

  export type UserUpdateWithoutVoucherUsedInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateManyWithoutUserNestedInput
    blog?: BlogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVoucherUsedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUncheckedUpdateManyWithoutUserNestedInput
    blog?: BlogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUncheckedUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUncheckedUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUncheckedUpdateManyWithoutUserTwoNestedInput
    Receipt?: ReceiptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VoucherUpsertWithoutVoucherUsedInput = {
    update: XOR<VoucherUpdateWithoutVoucherUsedInput, VoucherUncheckedUpdateWithoutVoucherUsedInput>
    create: XOR<VoucherCreateWithoutVoucherUsedInput, VoucherUncheckedCreateWithoutVoucherUsedInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutVoucherUsedInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutVoucherUsedInput, VoucherUncheckedUpdateWithoutVoucherUsedInput>
  }

  export type VoucherUpdateWithoutVoucherUsedInput = {
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    codeVoucher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typeVoucher?: TypeVoucherUpdateOneWithoutVoucherNestedInput
    OrderProduct?: OrderProductUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutVoucherUsedInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typeVoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    codeVoucher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type UserCreateWithoutReceiptInput = {
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserCreateNestedManyWithoutUserInput
    blog?: BlogCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Message?: MessageCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageCreateNestedManyWithoutUserTwoInput
    VoucherUsed?: VoucherUsedCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceiptInput = {
    id?: number
    email: string
    password: string
    firstName: string
    lastName: string
    address?: string | null
    gender?: $Enums.Gender | null
    phoneNumber?: string | null
    image?: string | null
    dob?: Date | string | null
    isActiveEmail?: boolean | null
    roleId?: $Enums.Role
    status?: $Enums.Status | null
    userToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    addressUser?: AddressUserUncheckedCreateNestedManyWithoutUserInput
    blog?: BlogUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Message?: MessageUncheckedCreateNestedManyWithoutUserInput
    ShopCart?: ShopCartUncheckedCreateNestedManyWithoutUserInput
    roomMessagesOne?: RoomMessageUncheckedCreateNestedManyWithoutUserOneInput
    roomMessagesTwo?: RoomMessageUncheckedCreateNestedManyWithoutUserTwoInput
    VoucherUsed?: VoucherUsedUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceiptInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceiptInput, UserUncheckedCreateWithoutReceiptInput>
  }

  export type UserUpsertWithoutReceiptInput = {
    update: XOR<UserUpdateWithoutReceiptInput, UserUncheckedUpdateWithoutReceiptInput>
    create: XOR<UserCreateWithoutReceiptInput, UserUncheckedCreateWithoutReceiptInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceiptInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceiptInput, UserUncheckedUpdateWithoutReceiptInput>
  }

  export type UserUpdateWithoutReceiptInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateManyWithoutUserNestedInput
    blog?: BlogUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Message?: MessageUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUpdateManyWithoutUserTwoNestedInput
    VoucherUsed?: VoucherUsedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceiptInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveEmail?: NullableBoolFieldUpdateOperationsInput | boolean | null
    roleId?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    userToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUncheckedUpdateManyWithoutUserNestedInput
    blog?: BlogUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Message?: MessageUncheckedUpdateManyWithoutUserNestedInput
    ShopCart?: ShopCartUncheckedUpdateManyWithoutUserNestedInput
    roomMessagesOne?: RoomMessageUncheckedUpdateManyWithoutUserOneNestedInput
    roomMessagesTwo?: RoomMessageUncheckedUpdateManyWithoutUserTwoNestedInput
    VoucherUsed?: VoucherUsedUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BrandCreateWithoutCategoryInput = {
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Product?: ProductCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Product?: ProductUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutCategoryInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutCategoryInput, BrandUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateWithoutCategoryInput = {
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    view?: number | null
    material?: string | null
    originalPrice?: number | null
    discountPrice?: number | null
    brand?: BrandCreateNestedOneWithoutProductInput
    Comment?: CommentCreateNestedManyWithoutProductInput
    OrderDetaill?: OrderDetaillCreateNestedManyWithoutProductInput
    ProductSize?: ProductSizeCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: number
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    view?: number | null
    material?: string | null
    brandId?: number | null
    originalPrice?: number | null
    discountPrice?: number | null
    Comment?: CommentUncheckedCreateNestedManyWithoutProductInput
    OrderDetaill?: OrderDetaillUncheckedCreateNestedManyWithoutProductInput
    ProductSize?: ProductSizeUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BrandUpsertWithoutCategoryInput = {
    update: XOR<BrandUpdateWithoutCategoryInput, BrandUncheckedUpdateWithoutCategoryInput>
    create: XOR<BrandCreateWithoutCategoryInput, BrandUncheckedCreateWithoutCategoryInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutCategoryInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutCategoryInput, BrandUncheckedUpdateWithoutCategoryInput>
  }

  export type BrandUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Product?: ProductUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Product?: ProductUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringNullableFilter<"Product"> | string | null
    contentHTML?: StringNullableFilter<"Product"> | string | null
    contentMarkdown?: StringNullableFilter<"Product"> | string | null
    status?: EnumStatusNullableFilter<"Product"> | $Enums.Status | null
    categoryId?: IntNullableFilter<"Product"> | number | null
    view?: IntNullableFilter<"Product"> | number | null
    material?: StringNullableFilter<"Product"> | string | null
    brandId?: IntNullableFilter<"Product"> | number | null
    originalPrice?: IntNullableFilter<"Product"> | number | null
    discountPrice?: IntNullableFilter<"Product"> | number | null
  }

  export type ProductCreateWithoutBrandInput = {
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    view?: number | null
    material?: string | null
    originalPrice?: number | null
    discountPrice?: number | null
    category?: CategoryCreateNestedOneWithoutProductInput
    Comment?: CommentCreateNestedManyWithoutProductInput
    OrderDetaill?: OrderDetaillCreateNestedManyWithoutProductInput
    ProductSize?: ProductSizeCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBrandInput = {
    id?: number
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    categoryId?: number | null
    view?: number | null
    material?: string | null
    originalPrice?: number | null
    discountPrice?: number | null
    Comment?: CommentUncheckedCreateNestedManyWithoutProductInput
    OrderDetaill?: OrderDetaillUncheckedCreateNestedManyWithoutProductInput
    ProductSize?: ProductSizeUncheckedCreateNestedManyWithoutProductInput
    ProductImage?: ProductImageUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBrandInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductCreateManyBrandInputEnvelope = {
    data: ProductCreateManyBrandInput | ProductCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutBrandInput = {
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Product?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutBrandInput = {
    id?: number
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Product?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutBrandInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutBrandInput, CategoryUncheckedCreateWithoutBrandInput>
  }

  export type CategoryCreateManyBrandInputEnvelope = {
    data: CategoryCreateManyBrandInput | CategoryCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
  }

  export type ProductUpdateManyWithWhereWithoutBrandInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBrandInput>
  }

  export type CategoryUpsertWithWhereUniqueWithoutBrandInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutBrandInput, CategoryUncheckedUpdateWithoutBrandInput>
    create: XOR<CategoryCreateWithoutBrandInput, CategoryUncheckedCreateWithoutBrandInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutBrandInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutBrandInput, CategoryUncheckedUpdateWithoutBrandInput>
  }

  export type CategoryUpdateManyWithWhereWithoutBrandInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutBrandInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    brandId?: IntNullableFilter<"Category"> | number | null
    createdAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
  }

  export type AddressUserCreateManyUserInput = {
    id?: number
    shipName?: string | null
    shipAdress?: string | null
    shipPhone?: string | null
    shipEmail?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BlogCreateManyUserInput = {
    id?: number
    title?: string | null
    subject?: $Enums.Subject | null
    status?: $Enums.Status | null
    image?: string | null
    contentMarkdown?: string | null
    contentHTML?: string | null
    view?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CommentCreateManyUserInput = {
    id?: number
    content?: string | null
    image?: string | null
    parentId?: number | null
    productId?: number | null
    blogId?: number | null
    star?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MessageCreateManyUserInput = {
    id?: number
    text?: string | null
    roomId?: number | null
    unRead?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ShopCartCreateManyUserInput = {
    id?: number
    productSizeId?: number | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RoomMessageCreateManyUserOneInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userTwoId?: number | null
  }

  export type RoomMessageCreateManyUserTwoInput = {
    id?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userOneId?: number | null
  }

  export type ReceiptCreateManyUserInput = {
    id?: number
    supplierId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VoucherUsedCreateManyUserInput = {
    id?: number
    voucherId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AddressUserUpdateWithoutUserInput = {
    shipName?: NullableStringFieldUpdateOperationsInput | string | null
    shipAdress?: NullableStringFieldUpdateOperationsInput | string | null
    shipPhone?: NullableStringFieldUpdateOperationsInput | string | null
    shipEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderProduct?: OrderProductUpdateManyWithoutAddressUserNestedInput
  }

  export type AddressUserUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipName?: NullableStringFieldUpdateOperationsInput | string | null
    shipAdress?: NullableStringFieldUpdateOperationsInput | string | null
    shipPhone?: NullableStringFieldUpdateOperationsInput | string | null
    shipEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutAddressUserNestedInput
  }

  export type AddressUserUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    shipName?: NullableStringFieldUpdateOperationsInput | string | null
    shipAdress?: NullableStringFieldUpdateOperationsInput | string | null
    shipPhone?: NullableStringFieldUpdateOperationsInput | string | null
    shipEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BlogUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableEnumSubjectFieldUpdateOperationsInput | $Enums.Subject | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Comment?: CommentUpdateManyWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableEnumSubjectFieldUpdateOperationsInput | $Enums.Subject | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Comment?: CommentUncheckedUpdateManyWithoutBlogNestedInput
  }

  export type BlogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableEnumSubjectFieldUpdateOperationsInput | $Enums.Subject | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUpdateWithoutUserInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneWithoutCommentNestedInput
    blog?: BlogUpdateOneWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    blogId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    blogId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpdateWithoutUserInput = {
    text?: NullableStringFieldUpdateOperationsInput | string | null
    unRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    room?: RoomMessageUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    unRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: NullableStringFieldUpdateOperationsInput | string | null
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    unRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShopCartUpdateWithoutUserInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productSize?: ProductSizeUpdateOneWithoutShopCartNestedInput
  }

  export type ShopCartUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productSizeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShopCartUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    productSizeId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoomMessageUpdateWithoutUserOneInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userTwo?: UserUpdateOneWithoutRoomMessagesTwoNestedInput
    messages?: MessageUpdateManyWithoutRoomNestedInput
  }

  export type RoomMessageUncheckedUpdateWithoutUserOneInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userTwoId?: NullableIntFieldUpdateOperationsInput | number | null
    messages?: MessageUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomMessageUncheckedUpdateManyWithoutUserOneInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userTwoId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomMessageUpdateWithoutUserTwoInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userOne?: UserUpdateOneWithoutRoomMessagesOneNestedInput
    messages?: MessageUpdateManyWithoutRoomNestedInput
  }

  export type RoomMessageUncheckedUpdateWithoutUserTwoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userOneId?: NullableIntFieldUpdateOperationsInput | number | null
    messages?: MessageUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomMessageUncheckedUpdateManyWithoutUserTwoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userOneId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReceiptUpdateWithoutUserInput = {
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiptUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiptUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUsedUpdateWithoutUserInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voucher?: VoucherUpdateOneWithoutVoucherUsedNestedInput
  }

  export type VoucherUsedUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUsedUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    voucherId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderProductCreateManyAddressUserInput = {
    id?: number
    status?: $Enums.Status | null
    typeShipId?: number | null
    voucherId?: number | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderProductUpdateWithoutAddressUserInput = {
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    typeShip?: TypeShipUpdateOneWithoutOrderProductNestedInput
    voucher?: VoucherUpdateOneWithoutOrderProductNestedInput
    OrderDetaill?: OrderDetaillUpdateManyWithoutOrderNestedInput
  }

  export type OrderProductUncheckedUpdateWithoutAddressUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    typeShipId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderDetaill?: OrderDetaillUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderProductUncheckedUpdateManyWithoutAddressUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    typeShipId?: NullableIntFieldUpdateOperationsInput | number | null
    voucherId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateManyBlogInput = {
    id?: number
    content?: string | null
    image?: string | null
    parentId?: number | null
    productId?: number | null
    userId?: number | null
    star?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CommentUpdateWithoutBlogInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneWithoutCommentNestedInput
    user?: UserUpdateOneWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutBlogInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUncheckedUpdateManyWithoutBlogInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderDetaillCreateManyOrderInput = {
    id?: number
    productId?: number | null
    quantity?: number | null
    realPrice?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderDetaillUpdateWithoutOrderInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    realPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneWithoutOrderDetaillNestedInput
  }

  export type OrderDetaillUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    realPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderDetaillUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    realPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShopCartCreateManyProductSizeInput = {
    id?: number
    userId?: number | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ShopCartUpdateWithoutProductSizeInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutShopCartNestedInput
  }

  export type ShopCartUncheckedUpdateWithoutProductSizeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShopCartUncheckedUpdateManyWithoutProductSizeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateManyProductInput = {
    id?: number
    content?: string | null
    image?: string | null
    parentId?: number | null
    userId?: number | null
    blogId?: number | null
    star?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderDetaillCreateManyProductInput = {
    id?: number
    orderId?: number | null
    quantity?: number | null
    realPrice?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductSizeCreateManyProductInput = {
    id?: number
    size?: $Enums.Size | null
    quantity?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductImageCreateManyProductInput = {
    id?: number
    image_url?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CommentUpdateWithoutProductInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutCommentNestedInput
    blog?: BlogUpdateOneWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    blogId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    blogId?: NullableIntFieldUpdateOperationsInput | number | null
    star?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderDetaillUpdateWithoutProductInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    realPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderProductUpdateOneWithoutOrderDetaillNestedInput
  }

  export type OrderDetaillUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    realPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderDetaillUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    realPrice?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductSizeUpdateWithoutProductInput = {
    size?: NullableEnumSizeFieldUpdateOperationsInput | $Enums.Size | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShopCart?: ShopCartUpdateManyWithoutProductSizeNestedInput
  }

  export type ProductSizeUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: NullableEnumSizeFieldUpdateOperationsInput | $Enums.Size | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ShopCart?: ShopCartUncheckedUpdateManyWithoutProductSizeNestedInput
  }

  export type ProductSizeUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    size?: NullableEnumSizeFieldUpdateOperationsInput | $Enums.Size | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductImageUpdateWithoutProductInput = {
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductImageUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductImageUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateManyRoomInput = {
    id?: number
    text?: string | null
    userId?: number | null
    unRead?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MessageUpdateWithoutRoomInput = {
    text?: NullableStringFieldUpdateOperationsInput | string | null
    unRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    unRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    unRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderProductCreateManyTypeShipInput = {
    id?: number
    addressUserId?: number | null
    status?: $Enums.Status | null
    voucherId?: number | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderProductUpdateWithoutTypeShipInput = {
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateOneWithoutOrderProductNestedInput
    voucher?: VoucherUpdateOneWithoutOrderProductNestedInput
    OrderDetaill?: OrderDetaillUpdateManyWithoutOrderNestedInput
  }

  export type OrderProductUncheckedUpdateWithoutTypeShipInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    voucherId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderDetaill?: OrderDetaillUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderProductUncheckedUpdateManyWithoutTypeShipInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    voucherId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherCreateManyTypeVoucherInput = {
    id?: number
    fromDate?: Date | string | null
    toDate?: Date | string | null
    amount?: number | null
    codeVoucher?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VoucherUpdateWithoutTypeVoucherInput = {
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    codeVoucher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderProduct?: OrderProductUpdateManyWithoutVoucherNestedInput
    VoucherUsed?: VoucherUsedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutTypeVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    codeVoucher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderProduct?: OrderProductUncheckedUpdateManyWithoutVoucherNestedInput
    VoucherUsed?: VoucherUsedUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateManyWithoutTypeVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableIntFieldUpdateOperationsInput | number | null
    codeVoucher?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderProductCreateManyVoucherInput = {
    id?: number
    addressUserId?: number | null
    status?: $Enums.Status | null
    typeShipId?: number | null
    image?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VoucherUsedCreateManyVoucherInput = {
    id?: number
    userId?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderProductUpdateWithoutVoucherInput = {
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addressUser?: AddressUserUpdateOneWithoutOrderProductNestedInput
    typeShip?: TypeShipUpdateOneWithoutOrderProductNestedInput
    OrderDetaill?: OrderDetaillUpdateManyWithoutOrderNestedInput
  }

  export type OrderProductUncheckedUpdateWithoutVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    typeShipId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    OrderDetaill?: OrderDetaillUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderProductUncheckedUpdateManyWithoutVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressUserId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    typeShipId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUsedUpdateWithoutVoucherInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutVoucherUsedNestedInput
  }

  export type VoucherUsedUncheckedUpdateWithoutVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUsedUncheckedUpdateManyWithoutVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateManyCategoryInput = {
    id?: number
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    view?: number | null
    material?: string | null
    brandId?: number | null
    originalPrice?: number | null
    discountPrice?: number | null
  }

  export type ProductUpdateWithoutCategoryInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    brand?: BrandUpdateOneWithoutProductNestedInput
    Comment?: CommentUpdateManyWithoutProductNestedInput
    OrderDetaill?: OrderDetaillUpdateManyWithoutProductNestedInput
    ProductSize?: ProductSizeUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    Comment?: CommentUncheckedUpdateManyWithoutProductNestedInput
    OrderDetaill?: OrderDetaillUncheckedUpdateManyWithoutProductNestedInput
    ProductSize?: ProductSizeUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductCreateManyBrandInput = {
    id?: number
    name?: string | null
    contentHTML?: string | null
    contentMarkdown?: string | null
    status?: $Enums.Status | null
    categoryId?: number | null
    view?: number | null
    material?: string | null
    originalPrice?: number | null
    discountPrice?: number | null
  }

  export type CategoryCreateManyBrandInput = {
    id?: number
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProductUpdateWithoutBrandInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    category?: CategoryUpdateOneWithoutProductNestedInput
    Comment?: CommentUpdateManyWithoutProductNestedInput
    OrderDetaill?: OrderDetaillUpdateManyWithoutProductNestedInput
    ProductSize?: ProductSizeUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
    Comment?: CommentUncheckedUpdateManyWithoutProductNestedInput
    OrderDetaill?: OrderDetaillUncheckedUpdateManyWithoutProductNestedInput
    ProductSize?: ProductSizeUncheckedUpdateManyWithoutProductNestedInput
    ProductImage?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    contentHTML?: NullableStringFieldUpdateOperationsInput | string | null
    contentMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableEnumStatusFieldUpdateOperationsInput | $Enums.Status | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableIntFieldUpdateOperationsInput | number | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    originalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    discountPrice?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoryUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Product?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Product?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressUserCountOutputTypeDefaultArgs instead
     */
    export type AddressUserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressUserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogCountOutputTypeDefaultArgs instead
     */
    export type BlogCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderProductCountOutputTypeDefaultArgs instead
     */
    export type OrderProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductSizeCountOutputTypeDefaultArgs instead
     */
    export type ProductSizeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductSizeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomMessageCountOutputTypeDefaultArgs instead
     */
    export type RoomMessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomMessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TypeShipCountOutputTypeDefaultArgs instead
     */
    export type TypeShipCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TypeShipCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TypeVoucherCountOutputTypeDefaultArgs instead
     */
    export type TypeVoucherCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TypeVoucherCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VoucherCountOutputTypeDefaultArgs instead
     */
    export type VoucherCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VoucherCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandCountOutputTypeDefaultArgs instead
     */
    export type BrandCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressUserDefaultArgs instead
     */
    export type AddressUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressUserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BannerDefaultArgs instead
     */
    export type BannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BannerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlogDefaultArgs instead
     */
    export type BlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDetaillDefaultArgs instead
     */
    export type OrderDetaillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDetaillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderProductDefaultArgs instead
     */
    export type OrderProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductSizeDefaultArgs instead
     */
    export type ProductSizeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductSizeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductImageDefaultArgs instead
     */
    export type ProductImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomMessageDefaultArgs instead
     */
    export type RoomMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShopCartDefaultArgs instead
     */
    export type ShopCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShopCartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TypeShipDefaultArgs instead
     */
    export type TypeShipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TypeShipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TypeVoucherDefaultArgs instead
     */
    export type TypeVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TypeVoucherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VoucherDefaultArgs instead
     */
    export type VoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VoucherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VoucherUsedDefaultArgs instead
     */
    export type VoucherUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VoucherUsedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceiptDefaultArgs instead
     */
    export type ReceiptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceiptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReceiptDetailDefaultArgs instead
     */
    export type ReceiptDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReceiptDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandDefaultArgs instead
     */
    export type BrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}